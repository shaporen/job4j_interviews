##### [job4j_interviews](https://github.com/shaporen/job4j_interviews/blob/main/README.md)
#### Оглавление
+ [1. Что такое поток ввода-вывода?](#1-Что-такое-поток-ввода-вывода)
+ [2. Что такое Java IO?](#2-Что-такое-Java-IO)
+ [3. Что такое Java NIO?](#3-Что-такое-Java-NIO)
+ [4. Что такое NIO.2?](#4-Что-такое-NIO2)
+ [5. Что такое Scanner?](#5-Что-такое-Scanner)
+ [6. Как работает Scanner внутри?](#6-Как-работает-Scanner-внутри)
+ [7. Какие базовые методы существуют в Scanner?](#7-Какие-базовые-методы-существуют-в-Scanner)
+ [8. Что такое байтовый поток? Как он реализован внутри?](#8-Что-такое-байтовый-поток-Как-он-реализован-внутри)
+ [9. Что такое символьный поток? Как он реализован внутри?](#9-Что-такое-символьный-поток-Как-он-реализован-внутри)
+ [10. Что такое буферизированный поток?](#10-Что-такое-буферизированный-поток)
+ [11. Какие классы-обёртки позволяют ускорить чтение/запись за счет использования буфера?](#11-Какие-классы-обёртки-позволяют-ускорить-чтениезапись-за-счет-использования-буфера)
+ [12. Как осуществляется ввод и вывод из командной строки?](#12-Как-осуществляется-ввод-и-вывод-из-командной-строки)
+ [13. Что такое класс Console? Расскажите его API.](#13-Что-такое-класс-Console-Расскажите-его-API)
+ [14. Что такое поток данных? Data stream.](#14-Что-такое-поток-данных-Data-stream)
+ [15. Что такое поток объектов? Object stream.](#15-Что-такое-поток-объектов-Object-stream)
+ [16. Что такое Path? Как он реализуется на разных ОС?](#16-Что-такое-Path-Как-он-реализуется-на-разных-ОС)
+ [17. Как получить список файлов?](#17-Как-получить-список-файлов)
+ [18. Как проверить что файловая сущность является файлом или папкой?](#18-Как-проверить-что-файловая-сущность-является-файлом-или-папкой)
+ [19. Как удалить файл?](#19-Как-удалить-файл)
+ [20. Как переместить файл?](#20-Как-переместить-файл)
+ [21. Как управлять атрибутами файла?](#21-Как-управлять-атрибутами-файла)
+ [22. Как создать файл?](#22-Как-создать-файл)
+ [23. Как создать директорию?](#23-Как-создать-директорию)
+ [24. Как записать в файл?](#24-Как-записать-в-файл)
+ [25. Как прочитать данные из файла?](#25-Как-прочитать-данные-из-файла)
+ [26. Для чего нужны классы PrintStream и PrintWriter? В чем их различие?](#26-Для-чего-нужны-классы-PrintStream-и-PrintWriter-В-чем-их-различие)
+ [27. Что такое потоки байтовых массивов? Как они устроены?](#27-Что-такое-потоки-байтовых-массивов-Как-они-устроены)
+ [28. Зачем нужен класс RandomAccessFile?](#28-Зачем-нужен-класс-RandomAccessFile)
+ [29. Данные в каком виде можно считывать байтовыми и символьными потоками?](#29-Данные-в-каком-виде-можно-считывать-байтовыми-и-символьными-потоками)
+ [30. Что такое Socket?](#30-Что-такое-Socket)
+ [31. Какие виды сокетов есть в Java? С каким протоколом они работают?](#31-Какие-виды-сокетов-есть-в-Java-С-каким-протоколом-они-работают)
+ [32. Как отправить через сокет сообщение?](#32-Как-отправить-через-сокет-сообщение)
+ [33. Что такое логирование?](#33-Что-такое-логирование)
+ [34. Какие уровни логирования вы знаете?](#34-Какие-уровни-логирования-вы-знаете)
+ [35. Какая библиотека для логирования используется в курсе? Как ее настроить?](#35-Какая-библиотека-для-логирования-используется-в-курсе-Как-ее-настроить)
+ [36. Опишите из каких элементов состоит формат JSON.](#36-Опишите-из-каких-элементов-состоит-формат-JSON)
+ [37. Как преобразовать POJO в/из JSON?](#37-Как-преобразовать-POJO-виз-JSON)
+ [38. Опишите из каких элементов состоит формат XML.](#38-Опишите-из-каких-элементов-состоит-формат-XML)
+ [39. Как преобразовать POJO в/из XML?](#39-Как-преобразовать-POJO-виз-XML)
+ [40. Что такое сериализация/десериализация?](#40-Что-такое-сериализациядесериализация)
+ [41. Что такое регулярные выражения? Зачем они нужны?](#41-Что-такое-регулярные-выражения-Зачем-они-нужны)
+ [42. Как создать регулярное выражение в Java?](#42-Как-создать-регулярное-выражение-в-Java)
+ [43. Что такое метасимволы? Для чего они применяются в регулярных выражениях?](#43-Что-такое-метасимволы-Для-чего-они-применяются-в-регулярных-выражениях)


#### 1. Что такое поток ввода-вывода?

Поток ввода-вывода (I/O Stream) — это абстрактный механизм в Java, который обеспечивает  чтение данных из источника (например, файл, сеть, клавиатура) и запись данных в приемник (например, файл, сеть, экран).

**Ключевые понятия:**
+ Поток: последовательность байтов (или символов), которые передаются между источником и приемником. 
+ Ввод: чтение данных из источника.
+ Вывод: запись данных в приемник.

**Типы потоков:**
+ Потоки байтов: работают с байтами (например, `InputStream`, `OutputStream`).
+ Потоки символов: работают с символами (например, `Reader`, `Writer`).

**Преимущества использования потоков ввода-вывода:**
+ Абстракция: скрывает сложность взаимодействия с различными источниками и приемниками.
+ Гибкость: позволяет легко перенаправлять данные между различными компонентами.
+ Эффективность: оптимизирован для работы с различными типами данных.

**Основные классы потоков в Java:**
+ `InputStream`: абстрактный класс для потоков ввода байтов.
+ `OutputStream`: абстрактный класс для потоков вывода байтов.
+ `Reader`: абстрактный класс для потоков ввода символов.
+ `Writer`: абстрактный класс для потоков вывода символов.

**Пример использования:**

```java
// Чтение данных из файла
try (FileInputStream fis = new FileInputStream("file.txt")) {
  int data;
  while ((data = fis.read()) != -1) {
    System.out.print((char) data);
  }
} catch (IOException e) {
  e.printStackTrace();
}

// Запись данных в файл
try (FileOutputStream fos = new FileOutputStream("output.txt")) {
  fos.write("Hello, world!".getBytes());
} catch (IOException e) {
  e.printStackTrace();
}
```

[_к оглавлению_](#Оглавление)
#### 2. Что такое Java IO?

Java IO (Input/Output, Ввод/Вывод) - это система, которая позволяет программам Java взаимодействовать с внешним миром. Она предоставляет набор классов и интерфейсов для чтения данных из источников (файлов, сети, консоли) и записи данных в различные места (файлы, сеть, консоль). 

**Основные принципы Java IO:**
+ Потоки: Java IO использует концепцию потоков. Поток - это последовательность байтов, передаваемых между программой и внешним источником.
+ Byte streams: работают с байтовыми данными.
+ Character streams: работают с символами (например, текст).
+ Buffered streams: используют буфер для оптимизации ввода-вывода, что повышает производительность.
+ Filters:  фильтры  могут преобразовывать данные (например, сжатие) или выполнять дополнительные операции (например, шифрование).

**Основные классы Java IO:**

**1. Основные классы:**
+ InputStream: базовый класс для входных потоков.
+ OutputStream: базовый класс для выходных потоков.
+ Reader: базовый класс для входных потоков символов.
+ Writer: базовый класс для выходных потоков символов.

**2. Классы для работы с файлами:**
+ File: представляет файл или директорию.
+ FileInputStream: чтение данных из файла.
+ FileOutputStream: запись данных в файл.
+ FileReader: чтение символов из файла.
+ FileWriter: запись символов в файл.
+ RandomAccessFile: доступ к данным в файле в произвольном порядке.

**3. Классы для работы с сетью:**
+ Socket: представляет сокет, используемый для сетевого общения.
+ ServerSocket: представляет серверный сокет, используемый для прослушивания подключений.
+ InputStreamReader: чтение символов из сетевого потока.
+ OutputStreamWriter: запись символов в сетевой поток.

**4. Буферизированные потоки:**
+ BufferedInputStream:  вспомогательный класс для чтения данных из потока с использованием буфера.
+ BufferedOutputStream:  вспомогательный класс для записи данных в поток с использованием буфера.
+ BufferedReader:  вспомогательный класс для чтения символов из потока с использованием буфера.
+ BufferedWriter:  вспомогательный класс для записи символов в поток с использованием буфера.

**5. Фильтры:**
+ InputStreamReader: преобразует байтовый поток в поток символов.
+ OutputStreamWriter: преобразует поток символов в байтовый поток.
+ DataInputStream:  чтение примитивных типов данных из потока.
+ DataOutputStream:  запись примитивных типов данных в поток.
+ GZIPInputStream:  декомпрессия потока данных, сжатого алгоритмом GZIP.
+ GZIPOutputStream:  компрессия потока данных алгоритмом GZIP.

**Примеры использования классов:**
**1. Чтение данных из файла:**
```java
try (FileReader reader = new FileReader("file.txt")) {
    int data;
    while ((data = reader.read()) != -1) {
        System.out.print((char) data);
    }
} catch (IOException e) {
    System.err.println("Ошибка чтения файла: " + e.getMessage());
}
```

**2. Запись данных в файл:**
```java
try (FileWriter writer = new FileWriter("file.txt")) {
    writer.write("Это тестовая запись в файл.");
} catch (IOException e) {
    System.err.println("Ошибка записи в файл: " + e.getMessage());
}
```

**3. Создание сетевого сокета:**
```java
try (Socket socket = new Socket("localhost", 8080)) {
    // Общение по сокету
} catch (IOException e) {
    System.err.println("Ошибка подключения к серверу: " + e.getMessage());
}
```

**4. Использование буферизированного потока:**
```java
try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException e) {
    System.err.println("Ошибка чтения файла: " + e.getMessage());
}
```

**5. Использование фильтра для сжатия данных:**
```java
try (GZIPOutputStream gzip = new GZIPOutputStream(new FileOutputStream("compressed.gz"))) {
    // Запись данных в сжатый поток
} catch (IOException e) {
    System.err.println("Ошибка сжатия данных: " + e.getMessage());
}
```

[Основные отличия Java IO и Java NIO](https://habr.com/ru/articles/235585/)

[_к оглавлению_](#Оглавление)
#### 3. Что такое Java NIO?

Java NIO (New Input/Output) — это пакет, введенный в Java 1.4, который предоставляет более гибкий и эффективный способ работы с вводом и выводом по сравнению с традиционными потоками ввода-вывода (Java IO). Основной целью NIO является улучшение производительности и добавление функциональности, такой как поддержка неблокирующего ввода-вывода и возможность работы с большими объемами данных.

**Основные компоненты Java NIO**

1. Channels (Каналы) - каналы представляют собой абстракцию для взаимодействия с источниками и приемниками данных (файлы, сокеты и т. д.). Они могут работать как в блокирующем, так и в неблокирующем режиме.

Примеры классов:
- FileChannel: для работы с файлами.
- SocketChannel: для работы с сетевыми соединениями.

2. Buffers (Буферы) - буферы представляют собой массивы байтов или других типов, которые используются для хранения данных временно во время передач.

Примеры классов:
- ByteBuffer: для работы с массивами байтов.
- CharBuffer: для работы с символами и строками.

3. Selectors (Селекторы) - cелекторы предоставляют возможность мониторинга состояния нескольких каналов, позволяя работать с ними в неблокирующем режиме.

Пример класса:
- Selector: непосредственно для отслеживания нескольких подключений. 

**Пример работы с FileChannel**
```java
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.StandardOpenOption;
import java.nio.file.Paths;
import java.nio.file.Path;

import java.io.File;
import java.io.IOException;

public class FileChannelExample {
    public static void main(String[] args) {
        Path path = Paths.get("example.txt");
        String text = "Hello, NIO!";
        
        try (FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {
            ByteBuffer buffer = ByteBuffer.allocate(48);
            buffer.clear(); // очищаем буфер перед записью
            buffer.put(text.getBytes());
            buffer.flip(); // переключаемся в режим чтения
            
            while (buffer.hasRemaining()) {
                fileChannel.write(buffer);
            }

            System.out.println("Данные записаны в файл: " + path.toAbsolutePath());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
**Пример работы с SocketChannel**
```java
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

public class SocketChannelExample {
    public static void main(String[] args) {
        try (SocketChannel socketChannel = SocketChannel.open()) {
            socketChannel.connect(new InetSocketAddress("localhost", 9999));
            
            String message = "Hello, Server!";
            ByteBuffer buffer = ByteBuffer.allocate(256);
            buffer.clear();
            buffer.put(message.getBytes());
            buffer.flip(); // переключаемся в режим чтения
            
            while (buffer.hasRemaining()) {
                socketChannel.write(buffer);
            }

            System.out.println("Сообщение отправлено на сервер.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

**Пример работы с Selector**
```java
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.Selector;
import java.nio.channels.SelectionKey;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;

public class SelectorExample {

    public static void main(String[] args) throws IOException {
        Selector selector = Selector.open();
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.bind(new InetSocketAddress(9999));
        serverSocketChannel.configureBlocking(false);
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

        while (true) {
            selector.select(); // блокировать до появления событий

            var selectedKeys = selector.selectedKeys();
            var keyIterator = selectedKeys.iterator();

            while (keyIterator.hasNext()) {
                SelectionKey key = keyIterator.next();

                if (key.isAcceptable()) {
                    SocketChannel client = serverSocketChannel.accept();
                    client.configureBlocking(false);
                    client.register(selector, SelectionKey.OP_READ);

                    System.out.println("Присоединился клиент: " + client.getRemoteAddress());
                } else if (key.isReadable()) {
                    SocketChannel client = (SocketChannel) key.channel();
                    ByteBuffer buffer = ByteBuffer.allocate(256);
                    int bytesRead = client.read(buffer);
                    
                    if (bytesRead > 0) {
                        buffer.flip(); // переключаемся в режим чтения
                        System.out.println("Получены данные: " + new String(buffer.array(), 0, bytesRead));
                    }
                }
                
                keyIterator.remove();
            }
        }
    }
}
```
[Основные отличия Java IO и Java NIO](https://habr.com/ru/articles/235585/)

[_к оглавлению_](#Оглавление)
#### 4. Что такое NIO.2?
[_к оглавлению_](#Оглавление)
#### 5. Что такое Scanner?
[_к оглавлению_](#Оглавление)
#### 6. Как работает Scanner внутри?
[_к оглавлению_](#Оглавление)
#### 7. Какие базовые методы существуют в Scanner?
[_к оглавлению_](#Оглавление)
#### 8. Что такое байтовый поток? Как он реализован внутри?
[_к оглавлению_](#Оглавление)
#### 9. Что такое символьный поток? Как он реализован внутри?
[_к оглавлению_](#Оглавление)
#### 10. Что такое буферизированный поток?
[_к оглавлению_](#Оглавление)
#### 11. Какие классы-обёртки позволяют ускорить чтение/запись за счет использования буфера?
[_к оглавлению_](#Оглавление)
#### 12. Как осуществляется ввод и вывод из командной строки?
[_к оглавлению_](#Оглавление)
#### 13. Что такое класс Console? Расскажите его API.
[_к оглавлению_](#Оглавление)
#### 14. Что такое поток данных? Data stream.
[_к оглавлению_](#Оглавление)
#### 15. Что такое поток объектов? Object stream.
[_к оглавлению_](#Оглавление)
#### 16. Что такое Path? Как он реализуется на разных ОС?
[_к оглавлению_](#Оглавление)
#### 17. Как получить список файлов?
[_к оглавлению_](#Оглавление)
#### 18. Как проверить что файловая сущность является файлом или папкой?
[_к оглавлению_](#Оглавление)
#### 19. Как удалить файл?
[_к оглавлению_](#Оглавление)
#### 20. Как переместить файл?
[_к оглавлению_](#Оглавление)
#### 21. Как управлять атрибутами файла?
[_к оглавлению_](#Оглавление)
#### 22. Как создать файл?
[_к оглавлению_](#Оглавление)
#### 23. Как создать директорию?
[_к оглавлению_](#Оглавление)
#### 24. Как записать в файл?
[_к оглавлению_](#Оглавление)
#### 25. Как прочитать данные из файла?
[_к оглавлению_](#Оглавление)
#### 26. Для чего нужны классы PrintStream и PrintWriter? В чем их различие?
[_к оглавлению_](#Оглавление)
#### 27. Что такое потоки байтовых массивов? Как они устроены?
[_к оглавлению_](#Оглавление)
#### 28. Зачем нужен класс RandomAccessFile?
[_к оглавлению_](#Оглавление)
#### 29. Данные в каком виде можно считывать байтовыми и символьными потоками?
[_к оглавлению_](#Оглавление)
#### 30. Что такое Socket?
[_к оглавлению_](#Оглавление)
#### 31. Какие виды сокетов есть в Java? С каким протоколом они работают?
[_к оглавлению_](#Оглавление)
#### 32. Как отправить через сокет сообщение?
[_к оглавлению_](#Оглавление)
#### 33. Что такое логирование?
[_к оглавлению_](#Оглавление)
#### 34. Какие уровни логирования вы знаете?
[_к оглавлению_](#Оглавление)
#### 35. Какая библиотека для логирования используется в курсе? Как ее настроить?
[_к оглавлению_](#Оглавление)
#### 36. Опишите из каких элементов состоит формат JSON.
[_к оглавлению_](#Оглавление)
#### 37. Как преобразовать POJO в/из JSON?
[_к оглавлению_](#Оглавление)
#### 38. Опишите из каких элементов состоит формат XML.
[_к оглавлению_](#Оглавление)
#### 39. Как преобразовать POJO в/из XML?
[_к оглавлению_](#Оглавление)
#### 40. Что такое сериализация/десериализация?
[_к оглавлению_](#Оглавление)
#### 41. Что такое регулярные выражения? Зачем они нужны?
[_к оглавлению_](#Оглавление)
#### 42. Как создать регулярное выражение в Java?
[_к оглавлению_](#Оглавление)
#### 43. Что такое метасимволы? Для чего они применяются в регулярных выражениях?
[_к оглавлению_](#Оглавление)
