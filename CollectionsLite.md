##### [job4j_interviews](https://github.com/shaporen/job4j_interviews/blob/main/README.md)
#### Оглавление
+ [1. Что такое "коллекция".](#1-Что-такое-коллекция)
+ [2. Перечислите основные методы из интерфейса Collection.](#2-Перечислите-основные-методы-из-интерфейса-Collection)
+ [3. Назовите преимущества использования коллекций по сравнению с массивами.](#3-Назовите-преимущества-использования-коллекций-по-сравнению-с-массивами)
+ [4. Какие данные могут хранить коллекции?](#4-Какие-данные-могут-хранить-коллекции)
+ [5. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций List, Set, Map.](#5-Какие-есть-типы-коллекций-Как-они-характеризуются-Расскажите-про-иерархию-коллекций-List-Set-Map)
+ [6. В чём отличие ArrayList от LinkedList?](#6-В-чём-отличие-ArrayList-от-LinkedList)
+ [7. В чём отличие HashSet от TreeSet?](#7-В-чём-отличие-HashSet-от-TreeSet)
+ [8. В чём отличие Set от Map?](#8-В-чём-отличие-Set-от-Map)
+ [9. Как задается порядок следования объектов в коллекции? Как отсортировать коллекцию?](#9-Как-задается-порядок-следования-объектов-в-коллекции-Как-отсортировать-коллекцию)
+ [10. Чем отличается Comparable от Comparator?](#10-Чем-отличается-Comparable-от-Comparator)
+ [11. Что такое сортировка по принципу Natural Order?](#11-Что-такое-сортировка-по-принципу-Natural-Order)
+ [12. Что такое equals() и hashcode()?](#12-Что-такое-equals-и-hashcode)
+ [13. Какие есть способы перебора всех элементов List?](#13-Какие-есть-способы-перебора-всех-элементов-List)
+ [14. Расскажите о методах интерфейса Map.](#14-Расскажите-о-методах-интерфейса-Map)
+ [15. Расскажите, какие классы реализовывают интерфейс Map?](#15-Расскажите-какие-классы-реализовывают-интерфейс-Map)
+ [16. Расскажите о методах интерфейса Map - keySet() и entrySet()? Что такое Entry?](#16-Расскажите-о-методах-интерфейса-Map---keySet-и-entrySet-Что-такое-Entry)
+ [17. Что будет если вызвать метод map.put() несколько раз с одинаковым ключом?](#17-Что-будет-если-вызвать-метод-map-put-несколько-раз-с-одинаковым-ключом)
+ [18. Как реализован цикл foreach?](#18-Как-реализован-цикл-foreach)
+ [19. В чем разница между Iterator и Iterable?](#19-В-чем-разница-между-Iterator-и-Iterable)
+ [20. Как происходит удаление элементов из ArrayList?](#20-Как-происходит-удаление-элементов-из-ArrayList)
+ [21. Как происходит удаление элементов из LinkedList?](#21-Как-происходит-удаление-элементов-из-LinkedList)
+ [22. Что такое автоупаковка и распаковка? Зачем они нужны?](#22-Что-такое-автоупаковка-и-распаковка-Зачем-они-нужны)
+ [23. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?](#23-В-каком-случае-при-работе-с-упакованными-значениями-может-возникнуть-проблема-с-производительностью)
+ [24. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.](#24-Опишите-недостатки-и-преимущества-в-использовании-примитивных-типов-и-классов-оберток)
+ [25. Что такое очередь? Расскажите принцип работы и для чего она используется.](#25-Что-такое-очередь-Расскажите-принцип-работы-и-для-чего-она-используется)
+ [26. Расскажите про интерфейсы Queue, Deque и их иерархию.](#26-Расскажите-про-интерфейсы-Queue-Deque-и-их-иерархию)
+ [27. В чем отличие метода poll() от remove()?](#27-В-чем-отличие-метода-poll-от-remove)
+ [28. В чем отличие метода element() от peek()?](#28-В-чем-отличие-метода-element-от-peek)
+ [29. В чем отличие метода element() от poll()?](#29-В-чем-отличие-метода-element-от-poll)
+ [30. Перечислите наиболее часто используемые реализации интерфейса Queue.](#30-Перечислите-наиболее-часто-используемые-реализации-интерфейса-Queue)
+ [31. Что такое ограниченные и неограниченные очереди?](#31-Что-такое-ограниченные-и-неограниченные-очереди)
+ [32. Что такой односторонние и двусторонние очереди?](#32-Что-такой-односторонние-и-двусторонние-очереди)
+ [33. В чём отличие Deque от Queue?](#33-В-чём-отличие-Deque-от-Queue)
+ [34. В чём отличие методов removeLast() и pollLast()?](#34-В-чём-отличие-методов-removeLast-и-pollLast)
+ [35. Назовите самую распространенную реализацию Deque.](#35-Назовите-самую-распространенную-реализацию-Deque)

#### 1. Что такое "коллекция".
   
Коллекции - это хранилища, поддерживающие различные способы накопления и упорядочивания объектов с целью обеспечения эффективного доступа к ним.

Они представляют собой реализации абстрактных структур данных, поддерживающих различные способы хранения данных, а также операции добавления, удаления и изменения элементов. Т.е. это набор интерфейсов и реализующих их классов.

[_к оглавлению_](#Оглавление)

#### 2. Перечислите основные методы из интерфейса Collection.

- **_boolean_ add(E e)** - добавляет указанный элемент в коллекцию. Возвращает true, если элемент был успешно добавлен, и false в противном случае;

- **_boolean_ addAll(Collection<? extends E> c)** - добавляет все элементы из указанной коллекции в текущую коллекцию. Возвращает true, если хотя бы один элемент был успешно добавлен, и false в противном случае;

- **_void_ clear()** - удаляет все элементы из коллекции, делая ее пустой;

- **_boolean_ contains(Object o)** - проверяет, содержится ли указанный элемент в коллекции. Возвращает true, если элемент присутствует, и false в противном случае;

- **_boolean_ containsAll(Collection<?> c)** - проверяет, содержатся ли все элементы из указанной коллекции в текущей коллекции. Возвращает true, если все элементы присутствуют, и false в противном случае;

- **_boolean_ equals(Object o)** - сравнивает указанный объект с этой коллекцией на предмет равенства. Возвращает true, если равен, и false в противном случае;

- **_int_ hashCode()** - возвращает значение хеш-кода для этой коллекции;

- **_boolean_ isEmpty()** - возвращает значение true, если эта коллекция не содержит элементов;

- **_Iterator<E>_ iterator()** - возвращает итератор по элементам коллекции;

- **_boolean_ remove(Object o)** - удаляет указанный элемент из коллекции, если он присутствует. Возвращает true, если элемент был успешно удален, и false в противном случае;

- **_boolean_ removeAll(Collection<?> c)** - удаляет из текущей коллекции все элементы, которые присутствуют в указанной коллекции. Возвращает true, если хотя бы один элемент был удален, и false в противном случае;

- **_default boolean_ removeIf(Predicate<? super E> filter)** - удаляет все элементы этой коллекции, удовлетворяющие заданному предикату;

- **_boolean_ retainAll(Collection<?> c)** - удаляет все элементы исходной коллекции, кроме тех, что в переданной. Возвращает true, если хотя бы один элемент был удален, и false в противном случае;

- **_int_ size()** - возвращает количество элементов в коллекции;

- **_default Spliterator<E>_ spliterator()** - создает Spliterator для элементов коллекции;

- **_default Stream<E>_ stream()** - возвращает поток элементов коллекции;

- **_default Stream<E>_ parallelStream()** - преобразует последовательный поток в параллельный;

-  **_Object[]_ toArray()** - возвращает массив, содержащий все элементы коллекции;

-  **.<T> T[] toArray(T[] a)** - возвращает массив, содержащий все элементы коллекции, преобразованные в указанный тип. Этот метод позволяет контролировать тип элементов в возвращаемом массиве

[_к оглавлению_](#Оглавление)

#### 3. Назовите преимущества использования коллекций по сравнению с массивами.

1. Массив имеет фиксированный размер. Коллекция может динамически менять размер в процессе выполнения программы.
2. Коллекция может содержать в себе элементы разных типов, массив - только одного.
3. Коллекция предоставляет набор методов для работы с элементами коллекций, массив методов не имеет.
4. Коллекции более эффективны для работы с большими объемами данных.

[_к оглавлению_](#Оглавление)
#### 4. Какие данные могут хранить коллекции?

1. Примитивные типы данных (int, double, boolean, char и т. д.) в классах-обертках
2. Объекты любого класса (String, Integer, Double и т. д.)
3. Другие коллекции (ArrayList, LinkedList, HashSet и т. д.)
4. Массивы
5. null (пустое значение)

[_к оглавлению_](#Оглавление)
#### 5. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций List, Set, Map.

![img](https://github.com/shaporen/job4j_interviews/blob/main/resources/collections_hierarchy.jpg)

+ List - список.
+ Set - множество
+ Queue - очередь
+ Map - пара "ключ - значение"

**Реализации List:**
+ ArrayList - это список, который реализован как массив. Это означает, что элементы в ArrayList хранятся в последовательном порядке и могут быть доступны по индексу. Основные характеристики ArrayList включают динамическое увеличение размера, высокую производительность при доступе к элементам по индексу и возможность изменения элементов. Применяется, когда в процессе работы предполагается частое обращение к элементам по индексу. Следует избегать, если предполагается частое добавление/удаление элементов в середину списка. Позволяет хранить любые значения, в том числе null. Не потокобезопасен.
+ LinkedList - это двусвязный список (можно использовать как стэк или очередь), в котором каждый элемент содержит ссылки на предыдущий и следующий элементы. Это означает, что вставка и удаление элементов в середине списка выполняются быстрее, чем в ArrayList. Однако доступ к элементам по индексу в LinkedList более медленный. Позволяет хранить любые значения, в том числе null. Не потокобезопасен.
+ Vector - похож на ArrayList. Синхронизирован. Содержит много устаревших методов, которые не являются частью структуры коллекций. Не рекомендуется использовать, если не требуется потокобезопасность.
+ Stack - это реализация стека, который представляет собой упорядоченный список элементов, где добавление и удаление элементов происходит в конце списка (LIFO - last in, first out). После добавления интерфейса Queue не рекомендуется к использованию.

Все эти коллекции реализуют интерфейс List, что означает, что они поддерживают операции добавления, удаления и доступа к элементам по индексу.

**Реализации Queue:**
+ PriorityQueue - это класс, который реализует очередь с приоритетом. Он характеризуется тем, что элементы добавляются в очередь с учетом их приоритета и извлекаются в порядке возрастания или убывания приоритета. PriorityQueue может быть использована для реализации алгоритмов, таких как алгоритм Дейкстры или алгоритм сортировки слиянием. Не работает с null и non-comparable элементами. По умолчанию сортировка по принципу naturalOrder. Порядок сортировки задается c использованием Comparator. Не потокобезопасен.

+ LinkedList - это двусвязный список (можно использовать как стэк или очередь), в котором каждый элемент содержит ссылки на предыдущий и следующий элементы. Это означает, что вставка и удаление элементов в середине списка выполняются быстрее, чем в ArrayList. Однако доступ к элементам по индексу в LinkedList более медленный. Позволяет хранить любые значения, в том числе null. Не потокобезопасен.

+ ArrayDeque - это класс, который реализует двустороннюю очередь. Он характеризуется тем, что позволяет добавлять и удалять элементы как в начало, так и в конец очереди за O(1) времени. Также ArrayDeque имеет фиксированный размер и может быть использован как стек. Реализован с использованием массивов, однако не позволяет обращаться к элементам по индексу и хранить null.

В целом, все эти коллекции позволяют добавлять, извлекать и просматривать элементы в порядке их добавления или в соответствии с определенным приоритетом.

**Реализации Set:**
+ HashSet - это наиболее распространенная реализация Set, основанная на хэш-таблице (что позволяет постоянство по времени на поиск, удаление и добавление элементов). Он не гарантирует порядок элементов при их добавлении. Не допускает дубликатов. Хранит только объекты (примитивы заворачивает в обертки). Не потокобезопасен.
+ LinkedHashSet - это реализация Set, которая поддерживает порядок элементов в том порядке, в котором они были добавлены (именно порядок вставки, а не значения элементов). Как и HashSet, она не допускает дублирования элементов. Постоянное время добавления, поиска и удаления элементов. Не потокобезопасен.
+ TreeSet - это реализация Set, которая хранит элементы в отсортированном порядке. Он использует красно-черное дерево для хранения элементов и гарантирует, что они будут отсортированы в естественном порядке (например, числа в возрастающем порядке, строки в алфавитном порядке). Не работает с null и non-comparable элементами. По умолчанию сортировка по принципу naturalOrder. Порядок сортировки задается c использованием Comparator.

**Реализации Map:**
+ HashMap - основанный на хэш-таблице класс, который обеспечивает постоянное время выполнения операций добавления, удаления и поиска элементов. Однако порядок элементов в HashMap не определен. При попытке вставить элемент по уже имеющемуся ключу - заменит значение на новое. Допускает значение ключа null. Не потокобезопасен. Содержит только уникальные ключи.
+ LinkedHashMap - класс, который расширяет HashMap и хранит элементы в порядке их вставки. Поиск элементов в LinkedHashMap происходит чуть медленнее, чем в HashMap, но можно обеспечить итерацию элементов в порядке, в котором они были добавлены. Не потокобезопасен.
+ TreeMap - класс, основанный на структуре красно-черного дерева, который хранит элементы в отсортированном порядке по ключу. По умолчанию сортировка по принципу naturalOrder. Порядок сортировки задается c использованием Comparator. Поиск элементов в TreeMap выполняется за время log(n).
+ ConcurrentHashMap - класс, аналогичный HashMap, но с многопоточной поддержкой. Он обеспечивает безопасную работу с коллекцией в многопоточной среде.

[_к оглавлению_](#Оглавление)

#### 6. В чём отличие ArrayList от LinkedList?

**1) Структура данных:**
+ ArrayList - реализован на динамическом массиве.
+ LinkedList - двусвязный список.

**2) Вставка и удаление элементов**
+ ArrayList - медленная, так как при этом может потребоваться перемещение всех элементов после вставленного или удаленного элемента.
+ LinkedList - быстрее, так как достаточно изменить ссылки на предыдущий и следующий элементы, не требуя перемещения всех элементов.

**3) Итерация по элементам:**
+ При итерации по элементам ArrayList быстрее, так как доступ к элементам по индексу работает быстро.
+ При итерации по элементам LinkedList может быть медленнее из-за линейной сложности доступа к элементам.

**4) Использование памяти:**
+ ArrayList требует больше памяти, так как он выделяет фиксированный кусок памяти для хранения элементов, который может быть увеличен, если размер структуры данных увеличивается.
+ LinkedList требует меньше памяти, так как каждый элемент хранит ссылки только на предыдущий и следующий элементы.

**5) Применение:**
+ ArrayList - для быстрого доступа по индексу в малоизменяемых списках.
+ LinkedList - для частых вставок и удалений элементов и малом числе поиска элементов.

[_к оглавлению_](#Оглавление)
#### 7. В чём отличие HashSet от TreeSet?

**1) Структура данных:**
+ HashSet - хэш-таблица.
+ TreeSet - красно-черное дерево.

**2) Упорядоченность элементов:**
+ TreeSet - хранит элементы в отсортированном порядке (в соответствии с их естественным порядком или с использованием Comparator).
+ HashSet - порядок не гарантирован и может меняться.

**3) Производительность операций:**
+ TreeSet обеспечивает логарифмическую производительность для операций добавления, удаления и поиска элемента (O(log n)).
+ HashSet производительность для операций добавления, удаления и поиска элемента в среднем константная (O(1)). Однако, в худшем случае производительность HashSet может быть линейной (O(n)) из-за коллизий.

**4) Использование памяти:**
+ TreeSet требует больше памяти для хранения элементов из-за дополнительных структур данных, необходимых для хранения красно-чёрного дерева.
+ HashSet требует меньше памяти.

**5) Поддержка нулевого значения:**
+ TreeSet не позволяет хранить значения null.
+ HashSet позволяет хранить null элементы.

**6) Использование:**
+ TreeSet - если необходимо хранить элементы в отсортированном порядке и производительность операций не является критической.
+ HashSet - если требуется быстрое добавление, удаление и поиск элементов.

[_к оглавлению_](#Оглавление)
#### 8. В чём отличие Set от Map?

**1) Структура данных:**
+ Set - коллекцию уникальных элементов без какого-либо определенного порядка.
+ Map - коллекция "пар ключ-значение", где каждый ключ уникален.

**2) Скорость:**
+ Set - при поиске будет перебирать на соответствие.
+ Map - прямой доступ по ключу.

**3) Добавление дубликатов:**
+ Set - проигнорирует добавление дубликата.
+ Map - перезапишет значение по ключу-дубликату.

**4) Использование:**
+ Set - когда нужно хранить уникальные значения.
+ Map - когда нужно хранить пары "ключ-значение" и получать доступ к значению по ключу.

[_к оглавлению_](#Оглавление)
#### 9. Как задается порядок следования объектов в коллекции? Как отсортировать коллекцию?

Порядок следования объектов в коллекции в Java зависит от типа коллекции. Например, объекты в ArrayList хранятся в порядке их добавления, а объекты в TreeSet хранятся в отсортированном порядке.

Для сортировки коллекции в Java можно использовать метод Collections.sort(), который работает с любой коллекцией, реализующей интерфейс List и элементы которой реализуют интерфейс Comparable. Например:

```java
List<Integer> list = new ArrayList<>();
list.add(3);
list.add(1);
list.add(2);

Collections.sort(list);

System.out.println(list);
```

Если нужно отсортировать коллекцию объектов, не реализующих интерфейс Comparable, можно использовать метод Collections.sort() с передачей вторым аргументом объекта Comparator. Например, если нужно отсортировать список объектов по полю name:

```java
List<Person> list = new ArrayList<>();
list.add(new Person("Alice"));
list.add(new Person("Bob"));
list.add(new Person("Charlie"));

Collections.sort(list, Comparator.comparing(Person::getName));

System.out.println(list);
```

[_к оглавлению_](#Оглавление)
#### 10. Чем отличается Comparable от Comparator?

Comparable и Comparator - два интерфейса, используемых для сравнения объектов в Java.

1. Comparable:
- Comparable - это интерфейс, который должен быть реализован объектами, которые хотят быть сравниваемыми.
- Comparable содержит метод compareTo(), который возвращает отрицательное число, ноль или положительное число, в зависимости от того, какой объект меньше, равен или больше, чем другой.
- Метод compareTo() используется для сравнения объектов по их "естественному" порядку, который определен в самом объекте.
- Comparable используется для сортировки объектов в естественном порядке.

2. Comparator:
- Comparator - это интерфейс, который используется для сравнения объектов, не имеющих реализации Comparable или для сортировки объектов в другом порядке.
- Comparator содержит метод compare(), который принимает два объекта и возвращает отрицательное число, ноль или положительное число, указывающее на относительное положение объектов.
- Comparator позволяет создавать несколько различных способов сравнения объектов, в отличие от Comparable, который использует только "естественный" порядок объектов.

Таким образом, основное различие между Comparable и Comparator заключается в том, что Comparable используется для сравнения объектов по их "естественному" порядку, в то время как Comparator позволяет определять несколько различных способов сравнения объектов.

[_к оглавлению_](#Оглавление)
#### 11. Что такое сортировка по принципу Natural Order?

Сортировка по принципу Natural Order в Java означает сортировку элементов по их "естественному" порядку, то есть по порядку, в котором они были бы отсортированы, если бы не применялась никакая другая специальная логика сортировки. Например, строки сортируются по алфавиту, целые числа - по возрастанию, дробные числа - также по возрастанию и т.д.

Для сортировки объектов по принципу Natural Order в Java можно использовать метод `Collections.sort()` для списков или метод `Arrays.sort()` для массивов, при условии, что элементы коллекции или массива реализуют интерфейс `Comparable`, который определяет метод `compareTo()`, задающий естественный порядок элементов.

Также можно использовать функциональный метод `sorted()` для потоков данных (streams) в Java 8 и выше, например:

```java
List<String> list = Arrays.asList("b", "a", "c");
list.stream()
    .sorted()
    .forEach(System.out::println);
```

Этот код отсортирует список строк по принципу Natural Order и выведет элементы в отсортированном порядке.

[_к оглавлению_](#Оглавление)
#### 12. Что такое equals() и hashcode()?

Оба метода являются частью универсального комплекта правил, определенных в классе Object, который является родительским классом для всех объектов в Java. Методы используются для сравнения объектов в Java.

Метод equals() используется для сравнения содержимого двух объектов. По умолчанию, метод equals() сравнивает ссылки объектов, но его можно переопределить в классе, чтобы сравнивать содержимое объектов. Метод equals() должен быть переопределен вместе с методом hashCode(), чтобы обеспечить правильное поведение объектов при использовании в коллекциях, таких как HashMap или HashSet.

Метод hashCode() используется для генерации хеш-кода объекта. Хеш-код - это числовое значение, которое используется для быстрого доступа к объектам в коллекциях. Объекты с одинаковым содержимым должны иметь одинаковый хеш-код, поэтому метод hashCode() также должен быть переопределен вместе с методом equals().

[_к оглавлению_](#Оглавление)
#### 13. Какие есть способы перебора всех элементов List?

1. Цикл for:
```java
for (int i = 0; i < list.size(); i++) {
     // обработка элемента list.get(i)
}
```
2. For-Each цикл:
```java
for (Элемент элемент : list) {
     // обработка элемента
}
```
3. Использование Iterator:
```java
Iterator<Элемент> iterator = list.iterator();
while (iterator.hasNext()) {
     // обработка элемента iterator.next()
}
```
4. Использование forEach метода:
```java
list.forEach(element -> {
    // обработка элемента
});
```
5. Использование Stream API:
```java
list.stream().forEach(element -> {
    // обработка элемента
});
```
[_к оглавлению_](#Оглавление)
#### 14. Расскажите о методах интерфейса Map.

Ниже приведены основные методы интерфейса Map:

1. put(K key, V value): добавляет элемент в Map с указанным ключом и значением. Если элемент с таким ключом уже существует, то старое значение заменяется новым. Метод возвращает предыдущее значение, связанное с ключом, или null, если ключа ранее не существовало.
2. get(Object key): возвращает значение по указанному ключу. Если ключ не существует, возвращается null.
3. containsKey(Object key): проверяет наличие ключа в Map.
4. containsValue(Object value): проверяет наличие значения в Map.
5. remove(Object key): удаляет элемент по указанному ключу и возвращает его значение. Если ключ не существует, возвращается null.
6. size(): возвращает количество элементов в Map.
7. keySet(): возвращает множество всех ключей в Map.
8. values(): возвращает коллекцию всех значений в Map.
9. entrySet(): возвращает множество объектов Entry, представляющих пару "ключ-значение".
10. isEmpty(): проверяет коллекцию на пустоту (возвращает true - если пустая, false - есть элементы).

[_к оглавлению_](#Оглавление)
#### 15. Расскажите, какие классы реализовывают интерфейс Map?
[_к оглавлению_](#Оглавление)
#### 16. Расскажите о методах интерфейса Map - keySet() и entrySet()? Что такое Entry?
[_к оглавлению_](#Оглавление)
#### 17. Что будет если вызвать метод map put() несколько раз с одинаковым ключом?
[_к оглавлению_](#Оглавление)
#### 18. Как реализован цикл foreach?
[_к оглавлению_](#Оглавление)
#### 19. В чем разница между Iterator и Iterable?
[_к оглавлению_](#Оглавление)
#### 20. Как происходит удаление элементов из ArrayList?
[_к оглавлению_](#Оглавление)
#### 21. Как происходит удаление элементов из LinkedList?
[_к оглавлению_](#Оглавление)
#### 22. Что такое автоупаковка и распаковка? Зачем они нужны?
[_к оглавлению_](#Оглавление)
#### 23. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?
[_к оглавлению_](#Оглавление)
#### 24. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.
[_к оглавлению_](#Оглавление)
#### 25. Что такое очередь? Расскажите принцип работы и для чего она используется.
[_к оглавлению_](#Оглавление)
#### 26. Расскажите про интерфейсы Queue, Deque и их иерархию.
[_к оглавлению_](#Оглавление)
#### 27. В чем отличие метода poll() от remove()?
[_к оглавлению_](#Оглавление)
#### 28. В чем отличие метода element() от peek()?
[_к оглавлению_](#Оглавление)
#### 29. В чем отличие метода element() от poll()?
[_к оглавлению_](#Оглавление)
#### 30. Перечислите наиболее часто используемые реализации интерфейса Queue.
[_к оглавлению_](#Оглавление)
#### 31. Что такое ограниченные и неограниченные очереди?
[_к оглавлению_](#Оглавление)
#### 32. Что такой односторонние и двусторонние очереди?
[_к оглавлению_](#Оглавление)
#### 33. В чём отличие Deque от Queue?
[_к оглавлению_](#Оглавление)
#### 34. В чём отличие методов removeLast() и pollLast()?
[_к оглавлению_](#Оглавление)
#### 35. Назовите самую распространенную реализацию Deque.
[_к оглавлению_](#Оглавление)
