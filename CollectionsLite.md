##### [job4j_interviews](https://github.com/shaporen/job4j_interviews/blob/main/README.md)
#### Оглавление
+ [1. Что такое "коллекция".](#1-Что-такое-коллекция)
+ [2. Перечислите основные методы из интерфейса Collection.](#2-Перечислите-основные-методы-из-интерфейса-Collection)
+ [3. Назовите преимущества использования коллекций по сравнению с массивами.](#3-Назовите-преимущества-использования-коллекций-по-сравнению-с-массивами)
+ [4. Какие данные могут хранить коллекции?](#4-Какие-данные-могут-хранить-коллекции)
+ [5. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций List, Set, Map.](#5-Какие-есть-типы-коллекций-Как-они-характеризуются-Расскажите-про-иерархию-коллекций-List-Set-Map)
+ [6. В чём отличие ArrayList от LinkedList?](#6-В-чём-отличие-ArrayList-от-LinkedList)
+ [7. В чём отличие HashSet от TreeSet?](#7-В-чём-отличие-HashSet-от-TreeSet)
+ [8. В чём отличие Set от Map?](#8-В-чём-отличие-Set-от-Map)
+ [9. Как задается порядок следования объектов в коллекции? Как отсортировать коллекцию?](#9-Как-задается-порядок-следования-объектов-в-коллекции-Как-отсортировать-коллекцию)
+ [10. Чем отличается Comparable от Comparator?](#10-Чем-отличается-Comparable-от-Comparator)
+ [11. Что такое сортировка по принципу Natural Order?](#11-Что-такое-сортировка-по-принципу-Natural-Order)
+ [12. Что такое equals() и hashcode()?](#12-Что-такое-equals-и-hashcode)
+ [13. Какие есть способы перебора всех элементов List?](#13-Какие-есть-способы-перебора-всех-элементов-List)
+ [14. Расскажите о методах интерфейса Map.](#14-Расскажите-о-методах-интерфейса-Map)
+ [15. Расскажите, какие классы реализовывают интерфейс Map?](#15-Расскажите-какие-классы-реализовывают-интерфейс-Map)
+ [16. Расскажите о методах интерфейса Map - keySet() и entrySet()? Что такое Entry?](#16-Расскажите-о-методах-интерфейса-Map---keySet-и-entrySet-Что-такое-Entry)
+ [17. Что будет если вызвать метод map.put() несколько раз с одинаковым ключом?](#17-Что-будет-если-вызвать-метод-map-put-несколько-раз-с-одинаковым-ключом)
+ [18. Как реализован цикл foreach?](#18-Как-реализован-цикл-foreach)
+ [19. В чем разница между Iterator и Iterable?](#19-В-чем-разница-между-Iterator-и-Iterable)
+ [20. Как происходит удаление элементов из ArrayList?](#20-Как-происходит-удаление-элементов-из-ArrayList)
+ [21. Как происходит удаление элементов из LinkedList?](#21-Как-происходит-удаление-элементов-из-LinkedList)
+ [22. Что такое автоупаковка и распаковка? Зачем они нужны?](#22-Что-такое-автоупаковка-и-распаковка-Зачем-они-нужны)
+ [23. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?](#23-В-каком-случае-при-работе-с-упакованными-значениями-может-возникнуть-проблема-с-производительностью)
+ [24. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.](#24-Опишите-недостатки-и-преимущества-в-использовании-примитивных-типов-и-классов-оберток)
+ [25. Что такое очередь? Расскажите принцип работы и для чего она используется.](#25-Что-такое-очередь-Расскажите-принцип-работы-и-для-чего-она-используется)
+ [26. Расскажите про интерфейсы Queue, Deque и их иерархию.](#26-Расскажите-про-интерфейсы-Queue-Deque-и-их-иерархию)
+ [27. В чем отличие метода poll() от remove()?](#27-В-чем-отличие-метода-poll-от-remove)
+ [28. В чем отличие метода element() от peek()?](#28-В-чем-отличие-метода-element-от-peek)
+ [29. В чем отличие метода element() от poll()?](#29-В-чем-отличие-метода-element-от-poll)
+ [30. Перечислите наиболее часто используемые реализации интерфейса Queue.](#30-Перечислите-наиболее-часто-используемые-реализации-интерфейса-Queue)
+ [31. Что такое ограниченные и неограниченные очереди?](#31-Что-такое-ограниченные-и-неограниченные-очереди)
+ [32. Что такое односторонние и двусторонние очереди?](#32-Что-такое-односторонние-и-двусторонние-очереди)
+ [33. В чём отличие Deque от Queue?](#33-В-чём-отличие-Deque-от-Queue)
+ [34. В чём отличие методов removeLast() и pollLast()?](#34-В-чём-отличие-методов-removeLast-и-pollLast)
+ [35. Назовите самую распространенную реализацию Deque.](#35-Назовите-самую-распространенную-реализацию-Deque)

#### 1. Что такое "коллекция".
   
Коллекции - это хранилища, поддерживающие различные способы накопления и упорядочивания объектов с целью обеспечения эффективного доступа к ним.

Они представляют собой реализации абстрактных структур данных, поддерживающих различные способы хранения данных, а также операции добавления, удаления и изменения элементов. Т.е. это набор интерфейсов и реализующих их классов.

Об устройстве коллекций - https://habr.com/ru/articles/696184/

[_к оглавлению_](#Оглавление)

#### 2. Перечислите основные методы из интерфейса Collection.

- **_boolean_ add(E e)** - добавляет указанный элемент в коллекцию. Возвращает true, если элемент был успешно добавлен, и false в противном случае;

- **_boolean_ addAll(Collection<? extends E> c)** - добавляет все элементы из указанной коллекции в текущую коллекцию. Возвращает true, если хотя бы один элемент был успешно добавлен, и false в противном случае;

- **_void_ clear()** - удаляет все элементы из коллекции, делая ее пустой;

- **_boolean_ contains(Object o)** - проверяет, содержится ли указанный элемент в коллекции. Возвращает true, если элемент присутствует, и false в противном случае;

- **_boolean_ containsAll(Collection<?> c)** - проверяет, содержатся ли все элементы из указанной коллекции в текущей коллекции. Возвращает true, если все элементы присутствуют, и false в противном случае;

- **_boolean_ equals(Object o)** - сравнивает указанный объект с этой коллекцией на предмет равенства. Возвращает true, если равен, и false в противном случае;

- **_int_ hashCode()** - возвращает значение хеш-кода для этой коллекции;

- **_boolean_ isEmpty()** - возвращает значение true, если эта коллекция не содержит элементов;

- **_Iterator<E>_ iterator()** - возвращает итератор по элементам коллекции;

- **_boolean_ remove(Object o)** - удаляет указанный элемент из коллекции, если он присутствует. Возвращает true, если элемент был успешно удален, и false в противном случае;

- **_boolean_ removeAll(Collection<?> c)** - удаляет из текущей коллекции все элементы, которые присутствуют в указанной коллекции. Возвращает true, если хотя бы один элемент был удален, и false в противном случае;

- **_default boolean_ removeIf(Predicate<? super E> filter)** - удаляет все элементы этой коллекции, удовлетворяющие заданному предикату;

- **_boolean_ retainAll(Collection<?> c)** - удаляет все элементы исходной коллекции, кроме тех, что в переданной. Возвращает true, если хотя бы один элемент был удален, и false в противном случае;

- **_int_ size()** - возвращает количество элементов в коллекции;

- **_default Spliterator<E>_ spliterator()** - создает Spliterator для элементов коллекции;

- **_default Stream<E>_ stream()** - возвращает поток элементов коллекции;

- **_default Stream<E>_ parallelStream()** - преобразует последовательный поток в параллельный;

-  **_Object[]_ toArray()** - возвращает массив, содержащий все элементы коллекции;

-  **.<T> T[] toArray(T[] a)** - возвращает массив, содержащий все элементы коллекции, преобразованные в указанный тип. Этот метод позволяет контролировать тип элементов в возвращаемом массиве

[_к оглавлению_](#Оглавление)

#### 3. Назовите преимущества использования коллекций по сравнению с массивами.

1. Массив имеет фиксированный размер. Коллекция может динамически менять размер в процессе выполнения программы.
2. Коллекция может содержать в себе элементы разных типов, массив - только одного.
3. Коллекция предоставляет набор методов для работы с элементами коллекций, массив методов не имеет.
4. Коллекции более эффективны для работы с большими объемами данных.

[_к оглавлению_](#Оглавление)
#### 4. Какие данные могут хранить коллекции?

1. Примитивные типы данных (int, double, boolean, char и т. д.) в классах-обертках
2. Объекты любого класса (String, Integer, Double и т. д.)
3. Другие коллекции (ArrayList, LinkedList, HashSet и т. д.)
4. Массивы
5. null (пустое значение)

[_к оглавлению_](#Оглавление)
#### 5. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций List, Set, Map.

![img](https://github.com/shaporen/job4j_interviews/blob/main/resources/Collections.png)

+ List - список.
+ Set - множество
+ Queue - очередь
+ Map - пара "ключ - значение"

**Реализации List:**
+ ***ArrayList*** - это список, который реализован как массив. Это означает, что элементы в ArrayList хранятся в последовательном порядке и могут быть доступны по индексу. Основные характеристики ArrayList включают динамическое увеличение размера, высокую производительность при доступе к элементам по индексу и возможность изменения элементов. Применяется, когда в процессе работы предполагается частое обращение к элементам по индексу. Следует избегать, если предполагается частое добавление/удаление элементов в середину списка. Позволяет хранить любые значения, в том числе null. Не потокобезопасен.
+ ***LinkedList*** - это двусвязный список (можно использовать как стэк или очередь), в котором каждый элемент содержит ссылки на предыдущий и следующий элементы. Это означает, что вставка и удаление элементов в середине списка выполняются быстрее, чем в ArrayList. Однако доступ к элементам по индексу в LinkedList более медленный. Позволяет хранить любые значения, в том числе null. Не потокобезопасен.
+ ***Vector*** - похож на ArrayList. Синхронизирован. Содержит много устаревших методов, которые не являются частью структуры коллекций. Не рекомендуется использовать, если не требуется потокобезопасность.
+ ***Stack*** - это реализация стека, который представляет собой упорядоченный список элементов, где добавление и удаление элементов происходит в конце списка (LIFO - last in, first out). После добавления интерфейса Queue не рекомендуется к использованию.

Все эти коллекции реализуют интерфейс List, что означает, что они поддерживают операции добавления, удаления и доступа к элементам по индексу.

**Реализации Queue:**
+ ***PriorityQueue*** - это класс, который реализует очередь с приоритетом. Он характеризуется тем, что элементы добавляются в очередь с учетом их приоритета и извлекаются в порядке возрастания или убывания приоритета. PriorityQueue может быть использована для реализации алгоритмов, таких как алгоритм Дейкстры или алгоритм сортировки слиянием. Не работает с null и non-comparable элементами. По умолчанию сортировка по принципу naturalOrder. Порядок сортировки задается c использованием Comparator. Не потокобезопасен.
+ ***LinkedList*** - это двусвязный список (можно использовать как стэк или очередь), в котором каждый элемент содержит ссылки на предыдущий и следующий элементы. Это означает, что вставка и удаление элементов в середине списка выполняются быстрее, чем в ArrayList. Однако доступ к элементам по индексу в LinkedList более медленный. Позволяет хранить любые значения, в том числе null. Не потокобезопасен.
+ ***ArrayDeque*** - это класс, который реализует двустороннюю очередь. Он характеризуется тем, что позволяет добавлять и удалять элементы как в начало, так и в конец очереди за O(1) времени. Также ArrayDeque имеет фиксированный размер и может быть использован как стек. Реализован с использованием массивов, однако не позволяет обращаться к элементам по индексу и хранить null.

В целом, все эти коллекции позволяют добавлять, извлекать и просматривать элементы в порядке их добавления или в соответствии с определенным приоритетом.

**Реализации Set:**
+ ***HashSet*** - это наиболее распространенная реализация Set, основанная на хэш-таблице (что позволяет постоянство по времени на поиск, удаление и добавление элементов). Он не гарантирует порядок элементов при их добавлении. Не допускает дубликатов. Хранит только объекты (примитивы заворачивает в обертки). Не потокобезопасен.
+ ***LinkedHashSet*** - это реализация Set, которая поддерживает порядок элементов в том порядке, в котором они были добавлены (именно порядок вставки, а не значения элементов). Как и HashSet, она не допускает дублирования элементов. Постоянное время добавления, поиска и удаления элементов. Не потокобезопасен.
+ ***TreeSet*** - это реализация Set, которая хранит элементы в отсортированном порядке. Он использует красно-черное дерево для хранения элементов и гарантирует, что они будут отсортированы в естественном порядке (например, числа в возрастающем порядке, строки в алфавитном порядке). Не работает с null и non-comparable элементами. По умолчанию сортировка по принципу naturalOrder. Порядок сортировки задается c использованием Comparator.

**Реализации Map:**
+ ***HashMap*** - основанный на хэш-таблице класс, который обеспечивает постоянное время выполнения операций добавления, удаления и поиска элементов. Однако порядок элементов в HashMap не определен. При попытке вставить элемент по уже имеющемуся ключу - заменит значение на новое. Допускает значение ключа null. Не потокобезопасен. Содержит только уникальные ключи.
+ ***LinkedHashMap*** - класс, который расширяет HashMap и хранит элементы в порядке их вставки. Поиск элементов в LinkedHashMap происходит чуть медленнее, чем в HashMap, но можно обеспечить итерацию элементов в порядке, в котором они были добавлены. Не потокобезопасен.
+ ***TreeMap*** - класс, основанный на структуре красно-черного дерева, который хранит элементы в отсортированном порядке по ключу. По умолчанию сортировка по принципу naturalOrder. Порядок сортировки задается c использованием Comparator. Поиск элементов в TreeMap выполняется за время log(n).
+ ***ConcurrentHashMap*** - класс, аналогичный HashMap, но с многопоточной поддержкой. Он обеспечивает безопасную работу с коллекцией в многопоточной среде.

[_к оглавлению_](#Оглавление)

#### 6. В чём отличие ArrayList от LinkedList?

**1) Структура данных:**
+ ArrayList - реализован на динамическом массиве.
+ LinkedList - двусвязный список.

**2) Вставка и удаление элементов**
+ ArrayList - медленная, так как при этом может потребоваться перемещение всех элементов после вставленного или удаленного элемента.
+ LinkedList - быстрее, так как достаточно изменить ссылки на предыдущий и следующий элементы, не требуя перемещения всех элементов.

**3) Итерация по элементам:**
+ При итерации по элементам ArrayList быстрее, так как доступ к элементам по индексу работает быстро.
+ При итерации по элементам LinkedList может быть медленнее из-за линейной сложности доступа к элементам.

**4) Использование памяти:**
+ ArrayList требует больше памяти, так как он выделяет фиксированный кусок памяти для хранения элементов, который может быть увеличен, если размер структуры данных увеличивается.
+ LinkedList требует меньше памяти, так как каждый элемент хранит ссылки только на предыдущий и следующий элементы.

**5) Применение:**
+ ArrayList - для быстрого доступа по индексу в малоизменяемых списках.
+ LinkedList - для частых вставок и удалений элементов и малом числе поиска элементов.

[_к оглавлению_](#Оглавление)
#### 7. В чём отличие HashSet от TreeSet?

**1) Структура данных:**
+ HashSet - хэш-таблица.
+ TreeSet - красно-черное дерево.

**2) Упорядоченность элементов:**
+ TreeSet - хранит элементы в отсортированном порядке (в соответствии с их естественным порядком или с использованием Comparator).
+ HashSet - порядок не гарантирован и может меняться.

**3) Производительность операций:**
+ TreeSet обеспечивает логарифмическую производительность для операций добавления, удаления и поиска элемента (O(log n)).
+ HashSet производительность для операций добавления, удаления и поиска элемента в среднем константная (O(1)). Однако, в худшем случае производительность HashSet может быть линейной (O(n)) из-за коллизий.

**4) Использование памяти:**
+ TreeSet требует больше памяти для хранения элементов из-за дополнительных структур данных, необходимых для хранения красно-чёрного дерева.
+ HashSet требует меньше памяти.

**5) Поддержка нулевого значения:**
+ TreeSet не позволяет хранить значения null.
+ HashSet позволяет хранить null элементы.

**6) Использование:**
+ TreeSet - если необходимо хранить элементы в отсортированном порядке и производительность операций не является критической.
+ HashSet - если требуется быстрое добавление, удаление и поиск элементов.

[_к оглавлению_](#Оглавление)
#### 8. В чём отличие Set от Map?

**1) Структура данных:**
+ Set - коллекцию уникальных элементов без какого-либо определенного порядка.
+ Map - коллекция "пар ключ-значение", где каждый ключ уникален.

**2) Скорость:**
+ Set - при поиске будет перебирать на соответствие.
+ Map - прямой доступ по ключу.

**3) Добавление дубликатов:**
+ Set - проигнорирует добавление дубликата.
+ Map - перезапишет значение по ключу-дубликату.

**4) Использование:**
+ Set - когда нужно хранить уникальные значения.
+ Map - когда нужно хранить пары "ключ-значение" и получать доступ к значению по ключу.

[_к оглавлению_](#Оглавление)
#### 9. Как задается порядок следования объектов в коллекции? Как отсортировать коллекцию?

Порядок следования объектов в коллекции в Java зависит от типа коллекции. Например, объекты в ArrayList хранятся в порядке их добавления, а объекты в TreeSet хранятся в отсортированном порядке.

Для сортировки коллекции в Java можно использовать метод Collections.sort(), который работает с любой коллекцией, реализующей интерфейс List и элементы которой реализуют интерфейс Comparable. Например:

```java
List<Integer> list = new ArrayList<>();
list.add(3);
list.add(1);
list.add(2);

Collections.sort(list);

System.out.println(list); // [1, 2, 3]
```

Если нужно отсортировать коллекцию объектов, не реализующих интерфейс Comparable, можно использовать метод Collections.sort() с передачей вторым аргументом объекта Comparator. Например, если нужно отсортировать список объектов по полю name:

```java
List<Person> list = new ArrayList<>();
list.add(new Person("Alice"));
list.add(new Person("Bob"));
list.add(new Person("Charlie"));

Collections.sort(list, Comparator.comparing(Person::getName));

System.out.println(list); // [Alice, Bob, Charlie]
```

[_к оглавлению_](#Оглавление)
#### 10. Чем отличается Comparable от Comparator?

Comparable и Comparator - два интерфейса, используемых для сравнения объектов в Java.

**1. Comparable:**
- Comparable - это интерфейс, который должен быть реализован объектами, которые хотят быть сравниваемыми.
- Comparable содержит метод compareTo(), который возвращает отрицательное число, ноль или положительное число, в зависимости от того, какой объект меньше, равен или больше, чем другой.
- Метод compareTo() используется для сравнения объектов по их "естественному" порядку, который определен в самом объекте.
- Comparable используется для сортировки объектов в естественном порядке.

**2. Comparator:**
- Comparator - это интерфейс, который используется для сравнения объектов, не имеющих реализации Comparable или для сортировки объектов в другом порядке.
- Comparator содержит метод compare(), который принимает два объекта и возвращает отрицательное число, ноль или положительное число, указывающее на относительное положение объектов.
- Comparator позволяет создавать несколько различных способов сравнения объектов, в отличие от Comparable, который использует только "естественный" порядок объектов.

Таким образом, основное различие между Comparable и Comparator заключается в том, что Comparable используется для сравнения объектов по их "естественному" порядку, в то время как Comparator позволяет определять несколько различных способов сравнения объектов.

[_к оглавлению_](#Оглавление)
#### 11. Что такое сортировка по принципу Natural Order?

Сортировка по принципу Natural Order в Java означает сортировку элементов по их "естественному" порядку, то есть по порядку, в котором они были бы отсортированы, если бы не применялась никакая другая специальная логика сортировки. Например, строки сортируются по алфавиту, целые числа - по возрастанию, дробные числа - также по возрастанию и т.д.

Для сортировки объектов по принципу Natural Order в Java можно использовать метод `Collections.sort()` для списков или метод `Arrays.sort()` для массивов, при условии, что элементы коллекции или массива реализуют интерфейс `Comparable`, который определяет метод `compareTo()`, задающий естественный порядок элементов.

Также можно использовать функциональный метод `sorted()` для потоков данных (streams) в Java 8 и выше, например:

```java
List<String> list = Arrays.asList("b", "a", "c");
list.stream()
    .sorted()
    .forEach(System.out::print); // abc
```

Этот код отсортирует список строк по принципу Natural Order и выведет элементы в отсортированном порядке.

[_к оглавлению_](#Оглавление)
#### 12. Что такое equals() и hashcode()?

Оба метода являются частью универсального комплекта правил, определенных в классе Object, который является родительским классом для всех объектов в Java. Методы используются для сравнения объектов в Java.

Метод equals() используется для сравнения содержимого двух объектов. По умолчанию, метод equals() сравнивает ссылки объектов, но его можно переопределить в классе, чтобы сравнивать содержимое объектов. Метод equals() должен быть переопределен вместе с методом hashCode(), чтобы обеспечить правильное поведение объектов при использовании в коллекциях, таких как HashMap или HashSet.

Метод hashCode() используется для генерации хеш-кода объекта. Хеш-код - это числовое значение, которое используется для быстрого доступа к объектам в коллекциях. Объекты с одинаковым содержимым должны иметь одинаковый хеш-код, поэтому метод hashCode() также должен быть переопределен вместе с методом equals().

[_к оглавлению_](#Оглавление)
#### 13. Какие есть способы перебора всех элементов List?

1. Цикл for:
```java
for (int i = 0; i < list.size(); i++) {
     // обработка элемента list.get(i)
}
```
2. For-Each цикл:
```java
for (Элемент элемент : list) {
     // обработка элемента
}
```
3. Использование Iterator:
```java
Iterator<Элемент> iterator = list.iterator();
while (iterator.hasNext()) {
     // обработка элемента iterator.next()
}
```
4. Использование forEach метода:
```java
list.forEach(element -> {
    // обработка элемента
});
```
5. Использование Stream API:
```java
list.stream().forEach(element -> {
    // обработка элемента
});
```
[_к оглавлению_](#Оглавление)
#### 14. Расскажите о методах интерфейса Map.

Ниже приведены основные методы интерфейса Map:

1. put(K key, V value): добавляет элемент в Map с указанным ключом и значением. Если элемент с таким ключом уже существует, то старое значение заменяется новым. Метод возвращает предыдущее значение, связанное с ключом, или null, если ключа ранее не существовало.
2. get(Object key): возвращает значение по указанному ключу. Если ключ не существует, возвращается null.
3. containsKey(Object key): проверяет наличие ключа в Map.
4. containsValue(Object value): проверяет наличие значения в Map.
5. remove(Object key): удаляет элемент по указанному ключу и возвращает его значение. Если ключ не существует, возвращается null.
6. size(): возвращает количество элементов в Map.
7. keySet(): возвращает множество всех ключей в Map.
8. values(): возвращает коллекцию всех значений в Map.
9. entrySet(): возвращает множество объектов Entry, представляющих пару "ключ-значение".
10. isEmpty(): проверяет коллекцию на пустоту (возвращает true - если пустая, false - есть элементы).

[_к оглавлению_](#Оглавление)
#### 15. Расскажите, какие классы реализовывают интерфейс Map?

- ***HashMap*** - хэш-таблица, самая распространенная и широко используемая реализация интерфейса Map. Она основана на хэш-таблицах и предоставляет эффективный доступ к элементам по ключу. HashMap позволяет хранить значения в виде пар ключ-значение и обеспечивает доступ к ним за константное время в среднем случае.
- ***LinkedHashMap*** - класс, который расширяет функциональность HashMap, сохраняя порядок добавления элементов. LinkedHashMap предоставляет доступ к элементам в порядке их добавления или последнего доступа. Это может быть полезно, если важен порядок элементов или нужно управлять итерацией по коллекции.
- ***TreeMap*** - класс, реализующий интерфейс Map с использованием красно-черного дерева. TreeMap хранит элементы в отсортированном порядке по ключу. Поиск, добавление и удаление элементов в TreeMap происходит за время O(log n), что делает его эффективным выбором для приложений, требующих отсортированные данные.
- ***HashTable*** - устаревшая версия HashMap, синхронизированная версия.
- ***ConcurrentHashMap*** - реализация интерфейса Map, оптимизированная для многопоточных приложений. ConcurrentHashMap обеспечивает безопасный доступ к элементам коллекции из нескольких потоков, минимизируя блокировки с помощью распределения данных по сегментам. Это делает ConcurrentHashMap подходящим выбором для параллельных вычислений.
- ***EnumMap*** - перечисления в качестве ключей, благодаря чему - высокая производительность.
- ***IdentityMap*** - сравнивает ключи по `==` вместо `equals()`. Полезна в случае, когда требуется точное сравнение объектов по их ссылке.

[_к оглавлению_](#Оглавление)
#### 16. Расскажите о методах интерфейса Map - keySet() и entrySet()? Что такое Entry?

Интерфейс `Map` в Java предоставляет два ключевых метода для работы с ключами и парами ключ-значение: `keySet()` и `entrySet()`. 

1. Метод `keySet()`:

+ Возвращает: `Set` объектов, которые представляют ключи всех записей в `Map`.
+ Использование: Используется, когда нужно получить доступ к ключам `Map` и выполнить операции, не связанные с значениями.

Пример:

```java
Map<String, Integer> ages = new HashMap<>();
ages.put("Alice", 25);
ages.put("Bob", 30);
ages.put("Charlie", 28);

Set<String> keys = ages.keySet();
System.out.println("Keys: " + keys); // Keys: [Bob, Alice, Charlie]

for (String key : keys) {
    System.out.println(key);
}

Bob
Alice
Charlie

```

2. Метод `entrySet()`:

+ Возвращает: `Set` объектов типа `Map.Entry`, который представляет собой пару ключ-значение.
+ Использование: Используется, когда нужно получить доступ как к ключам, так и к значениям `Map` одновременно. 

Пример:

```java
Map<String, Integer> ages = new HashMap<>();
ages.put("Alice", 25);
ages.put("Bob", 30);
ages.put("Charlie", 28);

Set<Map.Entry<String, Integer>> entries = ages.entrySet();
System.out.println("Entries: " + entries); //Entries: [Bob=30, Alice=25, Charlie=28]

for (Map.Entry<String, Integer> entry : entries) {
    System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
}

Key: Bob, Value: 30
Key: Alice, Value: 25
Key: Charlie, Value: 28

```

Ключевые моменты:

+ `Set` гарантирует, что ключи (или пары ключ-значение) не будут дублироваться.
+ Методы `keySet()` и `entrySet()` возвращают неизменяемые представления `Map`. Изменения в полученных `Set` не повлияют на исходную `Map`.
+ Используйте `keySet()` для работы только с ключами.
+ Используйте `entrySet()` для работы с ключами и значениями одновременно.

Преимущества:

+ Предоставляют удобный способ получить доступ к ключам и значениям `Map`.
+ Обеспечивают удобную итерацию по элементам `Map`.
+ Упрощают манипуляции с элементами `Map`.

Дополнительная информация:

+ Интерфейс `Map` также предоставляет метод `values()`, который возвращает `Collection` всех значений `Map`.
+ Методы `keySet()`, `entrySet()` и `values()` возвращают только представления `Map`, а не её копии.
+ Операции модификации на полученных `Set` или `Collection` могут привести к непредсказуемому поведению.

Entry в `Map` - это пара "ключ-значение". Ключ - это уникальный идентификатор для элемента в `Map`. Он используется для доступа к соответствующему значению. Значение - это фактическая информация, связанная с ключом. 

Пример: представьте, что у вас есть `Map`, которая хранит информацию о студентах. Ключом может быть номер студенческого билета, а значением - имя студента.

```java
Map<Integer, String> студенты = new HashMap<>();

студенты.put(12345, "Иван Иванов");
студенты.put(67890, "Мария Петрова");
```

В этом случае, `(12345, "Иван Иванов")` и `(67890, "Мария Петрова")` - это entries в `Map`. 

Методы для работы с entries:

+ `entrySet()`: Возвращает набор всех `entries` в `Map`.
+ `containsKey(Object key)`: Проверяет, существует ли ключ в `Map`.
+ `containsValue(Object value)`: Проверяет, существует ли значение в `Map`.
+ `get(Object key)`: Возвращает значение, соответствующее заданному ключу.
+ `put(K key, V value)`: Добавляет или обновляет `entry` в `Map`.
+ `remove(Object key)`: Удаляет `entry` с заданным ключом из `Map`.

Использование `entries`: `еntries` в `Map` используются для хранения и извлечения данных, где для каждой записи есть уникальный ключ, который позволяет быстро и эффективно найти соответствующее значение.

[_к оглавлению_](#Оглавление)
#### 17. Что будет если вызвать метод map put() несколько раз с одинаковым ключом?

Если вы вызовете метод `map.put()` несколько раз с одинаковым ключом, то последнее значение, которое вы добавите, перезапишет предыдущее значение, связанное с этим ключом. 

Пример:
```java
Map<String, String> myMap = new HashMap<>();

myMap.put("name", "John"); // Добавляем пару ключ-значение
myMap.put("name", "Jane"); // Добавляем пару ключ-значение с тем же ключом

System.out.println(myMap.get("name")); // Вывод: Jane
```
В этом примере мы сначала добавляем пару "name" - "John" в `myMap`. Затем мы добавляем пару "name" - "Jane" с тем же ключом. В результате, значение "Jane" перезаписывает "John", и `myMap` будет содержать только одну пару "name" - "Jane".

Важно:

+ `HashMap` (и другие реализации `Map`) не поддерживают дубликатов ключей.
+ Если вы хотите сохранить все значения, связанные с одним ключом, вам нужно использовать другую структуру данных, например, `List` или `Set`.
+ Поведение `put()` может отличаться в зависимости от конкретной реализации `Map`.

[_к оглавлению_](#Оглавление)
#### 18. Как реализован цикл foreach?

Цикл `foreach` в Java не является самостоятельным оператором, а является синтаксическим сахаром для итерации по элементам итерабельных объектов (реализующих интерфейс `Iterable`). 

1. Итерабельный объект: 

Цикл `foreach` работает с объектами, реализующими интерфейс `Iterable`.  Этот интерфейс определяет единственный метод:

```java
Iterator<T> iterator();
```

Этот метод возвращает объект `Iterator`, который позволяет перебирать элементы итерабельного объекта. 

2. Iterator:

Класс `Iterator` предоставляет следующие методы:

+ `hasNext()`: Возвращает `true`, если в итераторе есть следующий элемент.
+ `next()`: Возвращает следующий элемент итерации.
+ `remove()`: Удаляет последний элемент, возвращенный методом `next()`. (Необязательный метод)

3. Реализация цикла `foreach`:

Компилятор Java преобразует цикл `foreach` в код, использующий итератор. Пример:

```java
for (int number : numbers) { 
    System.out.println(number);
}
```

Этот код будет преобразован в:

```java
Iterator<Integer> iterator = numbers.iterator();
while (iterator.hasNext()) {
    int number = iterator.next();
    System.out.println(number);
}
```

4. Процесс итерации:

+ Цикл `foreach` вызывает метод `iterator()` на итерабельном объекте.
+ Он получает объект `Iterator` и использует его для перебора элементов.
+ Метод `hasNext()` используется для проверки, есть ли следующий элемент.
+ Если есть, метод `next()` возвращает следующий элемент.
+ Элемент присваивается переменной в цикле `foreach`.
+ Тело цикла `foreach` выполняется.
+ Процесс повторяется, пока `hasNext()` не вернет `false`.

5.  Преимущества цикла `foreach`:

+ Простой синтаксис: Более простой и читаемый код, чем использование обычных циклов `for`.
+ Безопасность:  Избегает ошибок, связанных с индексами.
+ Универсальность: Работает с любым итерабельным объектом.

6. Ограничения:

+ Невозможность изменения коллекции во время итерации: изменение коллекции (добавление или удаление элементов) во время итерации может привести к ошибкам.
+ Невозможность доступа к индексу элементов:  если вам нужен доступ к индексу элемента, необходимо использовать обычный цикл `for`.

[_к оглавлению_](#Оглавление)
#### 19. В чем разница между Iterator и Iterable?

***Iterable:***

Определение: интерфейс, который определяет, что объект может быть итерирован (пройден в цикле). Простыми словами - определяет, что объект можно итерировать

Метод: имеет единственный метод `iterator()`, который возвращает объект `Iterator`.

Пример: класс `ArrayList` реализует интерфейс `Iterable`, что позволяет нам использовать цикл `for-each` для итерации по элементам списка.

***Iterator:***

Определение: интерфейс, который обеспечивает механизм для итерации по элементам коллекции.

Методы: 
+ `hasNext()`: Возвращает `true`, если в коллекции есть еще элементы для итерации.
+ `next()`: Возвращает следующий элемент в коллекции.
+ `remove()`: Удаляет последний элемент, возвращенный методом `next()`.

Пример:  мы используем `Iterator` для итерации по коллекции и управления итерацией. Простыми словами - предоставляет механизм для итерации.

```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class Main {

    public static void main(String[] args) {

        List<String> names = new ArrayList<>();
        names.add("Alice");
        names.add("Bob");
        names.add("Charlie");

        // Using Iterable
        for (String name : names) {
            System.out.println(name);
        }

        // Using Iterator
        Iterator<String> iterator = names.iterator();
        while (iterator.hasNext()) {
            String name = iterator.next();
            System.out.println(name);
        }
    }
}
```

[_к оглавлению_](#Оглавление)
#### 20. Как происходит удаление элементов из ArrayList?

Удаление элементов из `ArrayList` в Java можно осуществить разными способами:

1. По индексу - метод `remove(int index)`:

   + Удаляет элемент по заданному индексу.
   + Возвращает удаленный элемент.
   + Сдвигает все последующие элементы на одну позицию влево.

Пример:

```java
ArrayList<String> fruits = new ArrayList<>(Arrays.asList("яблоко", "банан", "груша"));
String removedFruit = fruits.remove(1); // Удаляем "банан"
System.out.println("Удаленный элемент: " + removedFruit); // Вывод: Удаленный элемент: банан
System.out.println(fruits); // Вывод: [яблоко, груша]
```

2. По значению - метод `remove(Object o)`:

   + Удаляет первое вхождение заданного объекта.
   + Возвращает `true`, если элемент был удален, иначе `false`.
   + Сдвигает все последующие элементы на одну позицию влево.

Пример:

```java
ArrayList<String> fruits = new ArrayList<>(Arrays.asList("яблоко", "банан", "груша", "банан"));
boolean removed = fruits.remove("банан"); // Удаляем первый "банан"
System.out.println("Удален ли элемент: " + removed); // Вывод: Удален ли элемент: true
System.out.println(fruits); // Вывод: [яблоко, груша, банан]
```

3. Итерация и удаление:

   + Вы можете итерировать по `ArrayList` с помощью цикла `for` или `Iterator`.
   + Внутри цикла используйте метод `remove(int index)` или `remove(Object o)` для удаления элементов.

Пример:

```java
ArrayList<String> fruits = new ArrayList<>(Arrays.asList("яблоко", "банан", "груша", "банан"));
for (int i = fruits.size() - 1; i >= 0; i--) {
  if (fruits.get(i).equals("банан")) {
    fruits.remove(i);
  }
}
System.out.println(fruits); // Вывод: [яблоко, груша]
```

4. По условию - метод removeIf(predicate)

   + Принимает предикат: Метод `removeIf()` принимает в качестве аргумента предикат - функцию, которая принимает элемент `ArrayList` и возвращает `true`, если этот элемент должен быть удален, и `false` в противном случае. 
   + Итерирует по элементам: Метод последовательно проходит по каждому элементу `ArrayList`.
   + Проверяет предикат: Для каждого элемента он вызывает предикат, чтобы проверить, должен ли он быть удален.
   + Удаляет элементы: Если предикат возвращает `true`, элемент удаляется из `ArrayList`.

Синтаксис:

```java
boolean removeIf(Predicate<? super E> filter)
```

Где:

 `filter` - предикат, который определяет, должен ли элемент быть удален.

Пример:

```java
import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public class RemoveIfExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));

        // Удалить все четные числа
        Predicate<Integer> isEven = number -> number % 2 == 0;
        numbers.removeIf(isEven);

        System.out.println("Список после удаления четных чисел: " + numbers);
    }
}
```

Результат:

```
Список после удаления четных чисел: [1, 3, 5, 7, 9]
```

5. Очистить список целиком - метод clear()

Метод делает список пустым, но не удаляет его из памяти.

Особенности:

   + Метод `clear()` выполняется за время O(n), где n - количество элементов в списке. 
   + После вызова `clear()`, размер списка становится равным нулю.
   + Метод `clear()` не возвращает значение.

Использование:

Метод `clear()` полезен, когда вам нужно очистить список и подготовить его для добавления новых элементов. Например, вы можете использовать его для очистки временных списков или для сброса списка к его первоначальному состоянию.

***Важно:***

+ Удаление элементов из `ArrayList` во время итерации может привести к неожиданным результатам.
+ Использование `Iterator` для итерации и `Iterator.remove()` для удаления элементов является более безопасным и предпочтительным способом.
+ После удаления элементов размер `ArrayList` уменьшается.
+ Индексы элементов, следующих за удаленным элементом, сдвигаются.

[_к оглавлению_](#Оглавление)
#### 21. Как происходит удаление элементов из LinkedList?

Набор методов для удаления элементов из LinkedList аналогичен п. 20. Дополнительно можно использовать следующие методы:

+ `removeFirst()` и `removeLast()` - удаляют соответственно первый и последний элементы списка и возвращают его. Удаления происходит за константное время О(1). При отсутствии элементов выбрасывает исключение `NoSuchElementException`.
+ `pollFirst()` и `pollLast()` - удаляют соответственно первый и последний элементы списка и возвращают его. Удаления происходит за константное время О(1). При отсутствии элементов возвращает `null`.

Важно:

+ Удаление элементов из `LinkedList` может быть более медленным, чем удаление элементов из `ArrayList`, особенно если вы удаляете элементы не в начале или конце списка. Это происходит из-за дополнительных действий для перезаписи ссылок на предыдущий и следующий элементы, особенно в случае удаления по индексу или значению - сначала будет осуществляться поиск элемента переьором по всему списку, вместо прямого доступа к элементу по индексу (для ArrayList).
+ Используйте `remove(Object o)` или `remove(int index)` для удаления элементов по значению или индексу.
+ Используйте итератор с методом `remove()`, если вам нужно удалять элементы во время итерации по списку.
+ Обратите внимание, что метод `remove(Object o)` удаляет только первое вхождение объекта в списке. Если вам нужно удалить все вхождения объекта, вам нужно использовать цикл.

[_к оглавлению_](#Оглавление)
#### 22. Что такое автоупаковка и распаковка? Зачем они нужны?

Автоупаковка и распаковка — это два механизма, которые облегчают работу с примитивными типами данных в Java.

Автоупаковка: Преобразование примитивного типа данных в соответствующий объект-оболочку. Например, преобразование `int` в `Integer`, `double` в `Double` и т.д.

Автораспаковка: Преобразование объекта-оболочки в соответствующий примитивный тип данных. Например, преобразование `Integer` в `int`, `Double` в `double` и т.д.

Зачем они нужны:

+ Удобство:  автоупаковка и распаковка позволяют использовать примитивные типы данных в контекстах, где требуется объект, например, в коллекциях, методах, принимающих объекты и т.д., не прибегая к ручному созданию объектов-оболочек.
+ Сокращение кода:  использование автоупаковки и распаковки позволяет сократить объем кода, делая его более читаемым и лаконичным.
+ Совместимость: позволяет использовать примитивы и объекты-оболочки в одном контексте без явного преобразования.

Пример:

```java
int num = 10; // Примитивный тип данных
Integer numObj = num; // Автоупаковка int в Integer
int num2 = numObj; // Автораспаковка Integer в int
```

Важно отметить:

+ Автоупаковка и распаковка работают только с соответствующими примитивными типами данных и объектами-оболочками. Например, нельзя автоупаковать `float` в `Integer`.
+ Не рекомендуется использовать автоупаковку и распаковку в циклах, где могут быть созданы тысячи объектов-оболочек, так как это может привести к проблемам с памятью.
+ Вместо автоупаковки можно использовать методы `valueOf()` класса-оболочки для создания объекта из примитивного значения. Например, `Integer.valueOf(10)` создает объект `Integer` со значением 10.

[_к оглавлению_](#Оглавление)
#### 23. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?

Несколько вариантов проблем с производительностью при использовании упакованных значений:
+ Избыточное использование памяти.
+ Затраты на производительность (упаковка/распаковка) при работе с циклами, коллекциями.
+ Возможно неожиданное поведение при кэшировании.

[_к оглавлению_](#Оглавление)
#### 24. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.

**Примитивные типы данных**

***Преимущества:***
+ используют мало памяти;
+ операции с примитивами выполняются значительно быстрее;
+ простота (проще объявлять, не требуется создавать объекты для объявления, применять конструкторы);
+ простота логических операций (==, <> и т.д.).

***Недостатки:***
+ отсутствуют `null`-значения;
+ неявные преобразования (потеря точности при использовании в арифметических операциях разных типов данных);
+ отсутствие методов;
+ ограниченный функционал (не поддерживают концепции ООП: полиморфизм, наследование, инкапсуляция).

**Классы-обертки**

***Преимущества:***
+ использование таких классов как объекты открывает доступ к методам и функциональности ООП;
+ имеют `null`-значения;
+ можно использовать в коллекциях и обобщениях;

***Недостатки:***
+ погрешность и производительность (избыточное использование памяти);
+ может создавать дополнительный уровень иерархии классов из-за использования объектов;
+ использование может привести к ошибкам в коде при отсутствии проверки на `null`.

[_к оглавлению_](#Оглавление)
#### 25. Что такое очередь? Расскажите принцип работы и для чего она используется.

Очередь (Queue) в Java – это абстрактный тип данных, который реализует принцип FIFO (First In, First Out - первый вошел, первый вышел). Это означает, что элементы добавляются в конец очереди, а извлекаются из начала. Представьте, как люди стоят в очереди в магазине – первый человек, кто пришел, первым и будет обслуживаться кассиром. 

Интерфейс Deque расширяет вышеописанный интерфейс Queue и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, либо как стек, действующий по принципу LIFO (Last In, First Out - последний вошел, первый вышел).

Принцип работы:

+ Добавление элементов (enqueue): новый элемент добавляется в конец очереди.
+ Извлечение элементов (dequeue): извлекается элемент, находящийся в начале очереди.

Реализации очереди в Java:

+ `java.util.LinkedList`: Очередь, основанная на связном списке. Быстрая работа с добавлением и удалением элементов в начале и конце очереди.
+ `java.util.ArrayDeque`: Очередь, основанная на массиве. Эффективная работа, если требуется частое добавление элементов в конец очереди.

Для чего используются очереди:

+ Обработка задач: очередь может использоваться для хранения задач, которые должны быть обработаны в определенном порядке. Например, в многопоточном приложении очередь может хранить задачи, которые должны быть выполнены отдельными потоками.
+ Обработка событий: очередь может использоваться для хранения событий, которые должны быть обработаны в определенном порядке. Например, в веб-приложении очередь может хранить запросы пользователей, которые должны быть обработаны сервером.
+ Многопоточная синхронизация: очередь может использоваться для синхронизации доступа к ресурсам между несколькими потоками. Например, очередь может использоваться для хранения данных, которые должны быть обработаны несколькими потоками, но только один поток может получить доступ к данным в один момент времени.
+ Системы обмена сообщениями: очереди широко используются в системах обмена сообщениями для отправки и получения сообщений между различными компонентами системы.

Пример использования очереди:

```java
import java.util.LinkedList;
import java.util.Queue;

public class QueueExample {

    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();

        // Добавление элементов в очередь
        queue.offer("Element 1");
        queue.offer("Element 2");
        queue.offer("Element 3");

        // Извлечение элементов из очереди
        while (!queue.isEmpty()) {
            System.out.println(queue.poll());
        }
    }
}
```

Этот пример демонстрирует, как создать очередь, добавить в нее элементы и затем извлечь их в порядке, в котором они были добавлены.

Важно отметить: очереди являются мощным инструментом для организации и обработки данных в Java. Выбор реализации очереди зависит от конкретных потребностей приложения.

[_к оглавлению_](#Оглавление)
#### 26. Расскажите про интерфейсы Queue, Deque и их иерархию.

**Очередь (Queue) в Java** – это абстрактный тип данных, который реализует принцип FIFO (First In, First Out - первый вошел, первый вышел). Это означает, что элементы добавляются в конец очереди, а извлекаются из начала. Представьте, как люди стоят в очереди в магазине – первый человек, кто пришел, первым и будет обслуживаться кассиром.

Основные реализации Queue:

***PriorityQueue:***

Основные свойства:
+ Основана на куче (heap).
+ Порядок элементов определяется заданным компаратором (если компаратор не задан - NaturalOrder).
+ Обеспечивает быструю вставку и удаление элементов с минимальным значением.

Преимущества:
+ Эффективность при необходимости быстрого доступа к минимальному элементу.
+ Подходит для задач, требующих сортировки по приоритету.

Интерфейс `java.util.Queue` предоставляет основные операции с очередями:

+ `add(E element)`: добавляет элемент в конец очереди.
+ `E element()`: возвращает, но не удаляет, элемент из начала очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `boolean offer(E obj)`: добавляет элемент `obj` в конец очереди. Если элемент удачно добавлен, возвращает `true`, иначе - `false`.
+ `E peek()`: возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение `null`.
+ `E poll()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение `null`.
+ `E remove()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.

**Интерфейс Deque** - расширяет вышеописанный интерфейс Queue и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, либо как стек, действующий по принципу LIFO (Last In, First Out - последний вошел, первый вышел).

**Основные реализации Deque:**

***ArrayDeque:*** - использует массив для хранения элементов.

Основные свойства:
+ Быстрая работа с добавлением и удалением элементов с обоих концов.
+ Неэффективна при добавлении и удалении элементов из середины.
+ Не подходит для хранения больших объемов данных, так как при достижении предела размера массива требуется перераспределение памяти.

Применение: оптимально для небольших коллекций, где требуется быстрый доступ к элементам с обоих концов.

***LinkedList*** - использует двусвязный список для хранения элементов.

Основные свойства:
+ Эффективна при добавлении и удалении элементов из любой позиции.
+ Доступ к элементам по индексу может быть медленным.
+ Требует больше памяти, чем `ArrayDeque`.

Применение: оптимально для коллекций с частыми операциями добавления и удаления элементов в произвольных местах.

***ConcurrentLinkedDeque*** - использует двусвязный список для хранения элементов. Обеспечивает потокобезопасность.

Основные свойства:
+ Эффективна при добавлении и удалении элементов из любой позиции.
+ Доступ к элементам по индексу может быть медленным.
+ Требует больше памяти, чем `ArrayDeque`.
+ Гарантирует потокобезопасность, что делает ее подходящей для многопоточной среды.

Применение: оптимально для коллекций, которые используются в многопоточной среде и требуют потокобезопасной работы с элементами.

Выбор оптимальной реализации `Deque` зависит от конкретной задачи и требований к производительности.

+ Для небольших коллекций с частыми операциями добавления и удаления с обоих концов `ArrayDeque` будет наиболее эффективной.
+ Для коллекций с частыми операциями добавления и удаления из любой позиции, а также для больших объемов данных `LinkedList` будет более подходящим выбором.
+ Для многопоточной среды `ConcurrentLinkedDeque` предоставляет потокобезопасную работу с коллекцией.

Интерфейс Deque определяет следующие методы:

+ `void addFirst(E obj)`: добавляет элемент в начало очереди.
+ `void addLast(E obj)`: добавляет элемент `obj` в конец очереди.
+ `E getFirst()`: возвращает без удаления элемент из головы очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `E getLast()`: возвращает без удаления последний элемент очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `boolean offerFirst(E obj)`: добавляет элемент `obj` в самое начало очереди. Если элемент удачно добавлен, возвращает `true`, иначе - `false`.
+ `boolean offerLast(E obj)`: добавляет элемент `obj` в конец очереди. Если элемент удачно добавлен, возвращает `true`, иначе - `false`.
+ `E peekFirst()`: возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение `null`.
+ `E peekLast()`: возвращает без удаления последний элемент очереди. Если очередь пуста, возвращает значение `null`.
+ `E pollFirst()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение `null`.
+ `E pollLast()`: возвращает с удалением последний элемент очереди. Если очередь пуста, возвращает значение `null`.
+ `E pop()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `void push(E element)`: добавляет элемент в самое начало очереди.
+ `E removeFirst()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `E removeLast()`: возвращает с удалением элемент из конца очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `boolean removeFirstOccurrence(Object obj)`: удаляет первый встреченный элемент `obj` из очереди. Если удаление произшло, то возвращает `true`, иначе возвращает `false`.
+ `boolean removeLastOccurrence(Object obj)`: удаляет последний встреченный элемент `obj` из очереди. Если удаление произшло, то возвращает `true`, иначе возвращает `false`.

Таким образом, наличие методов pop и push позволяет классам, реализующим этот элемент, действовать в качестве стека. В тоже время имеющийся функционал также позволяет создавать двунаправленные очереди, что делает классы, применяющие данный интерфейс, довольно гибкими.

[_к оглавлению_](#Оглавление)
#### 27. В чем отличие метода poll() от remove()?

Методы `poll()` и `remove()` используются для удаления элементов из коллекций в Java, но они имеют ключевое отличие:

`poll()`
+ Удаляет и возвращает первый элемент коллекции.
+ Возвращает `null`, если коллекция пуста.
+ Не выбрасывает исключения.

`remove()`
+ Удаляет элемент по указанному индексу или значению.
+ Возвращает удаленный элемент.
+ Выбрасывает `NoSuchElementException`, если элемент не найден.
+ В некоторых случаях может выбрасывать другие исключения, например, `IndexOutOfBoundsException`.

[_к оглавлению_](#Оглавление)
#### 28. В чем отличие метода element() от peek()?

Оба метода, `element()` и `peek()`, предназначены для получения элемента из коллекции, но у них есть важное различие:

`element()`:
+ Возвращает первый элемент коллекции.
+ Не удаляет элемент из коллекции.
+ Бросает `NoSuchElementException`, если коллекция пуста.

`peek()`:
+ Возвращает первый элемент коллекции.
+ Не удаляет элемент из коллекции.
+ Возвращает `null`, если коллекция пуста.

[_к оглавлению_](#Оглавление)
#### 29. В чем отличие метода element() от poll()?

Оба метода, `element()` и `poll()`, предназначены для получения элемента из коллекции, но у них есть важное различие:

`element()`:
+ Возвращает первый элемент коллекции.
+ Не удаляет элемент из коллекции.
+ Бросает `NoSuchElementException`, если коллекция пуста.

`poll()`
+ Удаляет и возвращает первый элемент коллекции.
+ Возвращает `null`, если коллекция пуста.
+ Не выбрасывает исключения.

[_к оглавлению_](#Оглавление)
#### 30. Перечислите наиболее часто используемые реализации интерфейса Queue.

Наиболее часто используемые реализации интерфейса Queue:

***LinkedList*** - использует двусвязный список для хранения элементов.

Основные свойства:
+ Эффективна при добавлении и удалении элементов из любой позиции.
+ Доступ к элементам по индексу может быть медленным.
+ Требует больше памяти, чем `ArrayDeque`.

Применение: оптимально для коллекций с частыми операциями добавления и удаления элементов в произвольных местах.

***PriorityQueue:***

Основные свойства:
+ Основана на куче (heap).
+ Порядок элементов определяется заданным компаратором (если компаратор не задан - NaturalOrder).
+ Обеспечивает быструю вставку и удаление элементов с минимальным значением.

Преимущества:
+ Эффективность при необходимости быстрого доступа к минимальному элементу.
+ Подходит для задач, требующих сортировки по приоритету.

***ArrayDeque:*** - использует массив для хранения элементов.

Основные свойства:
+ Быстрая работа с добавлением и удалением элементов с обоих концов.
+ Неэффективна при добавлении и удалении элементов из середины.
+ Не подходит для хранения больших объемов данных, так как при достижении предела размера массива требуется перераспределение памяти.

Применение: оптимально для небольших коллекций, где требуется быстрый доступ к элементам с обоих концов.

Дополнительные реализации:

+ ConcurrentLinkedQueue:  очередь, которая позволяет выполнять многопоточные операции над элементами. Она основана на связном списке и обеспечивает потокобезопасную очередь. 
+ LinkedBlockingQueue:  очередь, которая позволяет выполнять многопоточные операции над элементами, блокируя потоки, которые пытаются получить доступ к пустой очереди или добавить элемент в полную очередь. 
+ DelayQueue: очередь, которая позволяет хранить элементы, которые имеют определенное время задержки. Элементы извлекаются из очереди только по достижении времени задержки.

[_к оглавлению_](#Оглавление)
#### 31. Что такое ограниченные и неограниченные очереди?

Ограниченная очередь имеет фиксированный размер, определенный при создании, то есть она может хранить только определенное количество элементов. Попытка добавить элемент в переполненную очередь приведет к исключению. Ограниченные очереди рекомендуется использовать, если нужно управлять количеством элементов в очереди и предотвращать переполнение (перегрузку) системы.
+ Например: ArrayBlockingQueue (блокирующая очередь) - при попытке добавления элементов в полную очередь поток будет заблокирован до освобождения в ней места.

Неограниченная очередь не имеет ограничения по размеру и может хранить неограниченное количество элементов, динамически расширяется при необходимости (пока позволяет память). Неограниченные очереди рекомендуется использовать, если размер очереди не является критическим и нужно хранить большое количество данных.

[_к оглавлению_](#Оглавление)
#### 32. Что такое односторонние и двусторонние очереди?

Односторонняя очередь (или очередь в классическом понимании) позволяет добавлять элементы с одного конца и удалять их с другого.

Двусторонняя очередь (или дека) позволяет добавлять и удалять элементы с обоих концов.

Пример кода:

```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.Deque;

public class QueueExample {

    public static void main(String[] args) {

        // Односторонняя очередь
        Queue<String> queue = new LinkedList<>();
        queue.offer("A"); // Добавление элемента в конец очереди
        queue.offer("B");
        queue.offer("C");

        System.out.println("Односторонняя очередь:");
        while (!queue.isEmpty()) {
            System.out.println(queue.poll()); // Удаление и получение элемента из начала очереди
        }

        // Двусторонняя очередь
        Deque<String> deque = new LinkedList<>();
        deque.offerFirst("A"); // Добавление элемента в начало деки
        deque.offerLast("B"); // Добавление элемента в конец деки
        deque.offerFirst("C");

        System.out.println("\nДвусторонняя очередь:");
        while (!deque.isEmpty()) {
            System.out.println(deque.pollFirst()); // Удаление и получение элемента из начала деки
        }
    }
}
```

Вывод программы:

```
Односторонняя очередь:
A
B
C

Двусторонняя очередь:
C
A
B
```

Объяснение:
+ В примере мы используем класс `LinkedList` для реализации как односторонней, так и двусторонней очереди.
+ `Queue` - это интерфейс, который представляет одностороннюю очередь. 
+ `Deque` - это интерфейс, который представляет двустороннюю очередь.
+ Метод `offer()` добавляет элемент в очередь. В односторонней очереди этот метод добавляет элемент в конец очереди, а в двусторонней очереди - в конец деки.
+ Метод `poll()` удаляет и возвращает элемент из очереди. В односторонней очереди этот метод удаляет элемент из начала очереди, а в двусторонней очереди - из начала деки.
+ Методы `offerFirst()`, `offerLast()`, `pollFirst()` и `pollLast()` доступны только для двусторонней очереди.

Примеры использования:
+ Односторонняя очередь: обработка событий, управление задачами в многопоточном программировании, создание буферов для передачи данных.
+ Двусторонняя очередь: история команд в текстовом редакторе, отмена действий, реализация стека и очереди в одной структуре данных.

Преимущества и недостатки:

Односторонняя очередь:
+ Преимущества: простота реализации, эффективный доступ к первому элементу.
+ Недостатки: ограниченная функциональность, нельзя получить доступ к последнему элементу без удаления всех предыдущих.

Двусторонняя очередь:

+ Преимущества: Более гибкая функциональность, возможность доступа к элементам с обоих концов.
+ Недостатки: Более сложная реализация, может быть менее эффективной, чем односторонняя очередь.

[_к оглавлению_](#Оглавление)
#### 33. В чём отличие Deque от Queue?

[см. п. 32](#32-Что-такое-односторонние-и-двусторонние-очереди)

[_к оглавлению_](#Оглавление)
#### 34. В чём отличие методов removeLast() и pollLast()?

`removeLast()`:
+ Удаляет последний элемент.
+ Возвращает удаленный элемент.
+ Бросает исключение `NoSuchElementException`, если коллекция пуста.

`pollLast()`:
+ Удаляет последний элемент.
+ Возвращает удаленный элемент, если коллекция не пуста, иначе возвращает `null`.
+ Не бросает исключения.

[_к оглавлению_](#Оглавление)
#### 35. Назовите самую распространенную реализацию Deque.

***LinkedList*** - использует двусвязный список для хранения элементов.

Основные свойства:
+ Эффективна при добавлении и удалении элементов из любой позиции.
+ Доступ к элементам по индексу может быть медленным.
+ Требует больше памяти, чем `ArrayDeque`.

Применение: оптимально для коллекций с частыми операциями добавления и удаления элементов в произвольных местах.

***ArrayDeque:*** - использует массив для хранения элементов.

Основные свойства:
+ Быстрая работа с добавлением и удалением элементов с обоих концов.
+ Неэффективна при добавлении и удалении элементов из середины.
+ Не подходит для хранения больших объемов данных, так как при достижении предела размера массива требуется перераспределение памяти.

Применение: оптимально для небольших коллекций, где требуется быстрый доступ к элементам с обоих концов.


[_к оглавлению_](#Оглавление)
