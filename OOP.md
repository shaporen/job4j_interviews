##### [job4j_interviews](https://github.com/shaporen/job4j_interviews/blob/main/README.md)
### Оглавление
[1. Что такое ООП?](#1-Что-такое-ООП)

[2. Базовые концепции ООП.](#2-Базовые-концепции-ООП)

[3. Укажите из каких элементов состоит класс. Расскажите о каждом из них.](#3-Укажите-из-каких-элементов-состоит-класс-Расскажите-о-каждом-из-них)

[4. Что такое конструктор?](#4-Что-такое-конструктор)

[5. Можно ли наследовать конструктор?](#5-Можно-ли-наследовать-конструктор)

[6. Что такое перегрузка конструктора?](#6-Что-такое-перегрузка-конструктора)

[7. Что такое статический метод?](#7-Что-такое-статический-метод)

[8. Что такое не статический метод?](#8-Что-такое-не-статический-метод)

[9. Для чего используется ключевое слово this?](#9-Для-чего-используется-ключевое-слово-this)

[10. Какой класс является базовым родительским классом для всех классов?](#10-Какой-класс-является-базовым-родительским-классом-для-всех-классов)

[11. Что такое наследование? Приведите примеры из реальной жизни.](#11-Что-такое-наследование-Приведите-примеры-из-реальной-жизни)

[12. Опишите процесс создания нового объекта.](#12-Опишите-процесс-создания-нового-объекта)

[13. Как вызвать метод из родительского класса?](#13-Как-вызвать-метод-из-родительского-класса)

[14. Что такое переопределение метода?](#14-Что-такое-переопределение-метода)

[15. Можно ли переопределить статический метод?](#15-Можно-ли-переопределить-статический-метод)

[16. Что такое сокрытие метода?](#16-Что-такое-сокрытие-метода)

[17. Что такое виртуальная функция и используются ли они в Java?](#17-Что-такое-виртуальная-функция-и-используются-ли-они-в-Java)

[18. Что такое перегрузка метода?](#18-Что-такое-перегрузка-метода)

[19. Можно ли изменить тип возвращаемых данных при перегрузке метода?](#19-Можно-ли-изменить-тип-возвращаемых-данных-при-перегрузке-метода)

[20. Что такое множественное наследование? Как его можно реализовать в Java.](#20-Что-такое-множественное-наследование-Как-его-можно-реализовать-в-Java)

[21. Что такое полиморфизм? Приведите примеры из реальной жизни.](#21-Что-такое-полиморфизм-Приведите-примеры-из-реальной-жизни)

[22. Что такое инкапсуляция?](#22-Что-такое-инкапсуляция)

[23. Как реализована инкапсуляция в Java?](#23-Как-реализована-инкапсуляция-в-Java)

[24. Можно ли применить модификаторы доступа к конструкторам?](#24-Можно-ли-применить-модификаторы-доступа-к-конструкторам)

[25. Что такое интерфейс?](#25-Что-такое-интерфейс)

[26. Перечислите элементы, которые может содержать интерфейс.](#26-Перечислите-элементы-которые-может-содержать-интерфейс)

[27. Можно ли создать объект интерфейса? Если да, то как?](#27-Можно-ли-создать-объект-интерфейса-Если-да-то-как)

[28. Может ли интерфейс содержать какие-либо методы с реализацией? Если да, то какие?](#28-Может-ли-интерфейс-содержать-какие-либо-методы-с-реализацией-Если-да-то-какие)

[29. Что такое абстракция?](#29-Что-такое-абстракция)

[30. Что такое абстрактный класс?](#30-Что-такое-абстрактный-класс)

[31. Сколько абстрактных методов должен и может содержать абстрактный класс?](#31-Сколько-абстрактных-методов-должен-и-может-содержать-абстрактный-класс)

[32. Может ли абстрактный класс содержать обычные методы?](#32-Может-ли-абстрактный-класс-содержать-обычные-методы)

[33. Сколько объектов абстрактного класса можно создать в программе?](#33-Сколько-объектов-абстрактного-класса-можно-создать-в-программе)

[34. Что нужно делать, если наследник абстрактного класса не переопределяет все абстрактные методы родителя?](#34-Что-нужно-делать-если-наследник-абстрактного-класса-не-переопределяет-все-абстрактные-методы-родителя)

[35. Чем отличается интерфейс от абстрактного класса?](#35-Чем-отличается-интерфейс-от-абстрактного-класса)

[36. Что такое вложенные классы? Зачем они нужны?](#36-Что-такое-вложенные-классы-Зачем-они-нужны)

[37. Какие типы вложенных классов существуют в Java?](#37-Какие-типы-вложенных-классов-существуют-в-Java)

[38. Что такое внутренний класс? Когда он применяется?](#38-Что-такое-внутренний-класс-Когда-он-применяется)

[39. Что такое статический вложенный класс? Когда он применяется?](#39-Что-такое-статический-вложенный-класс-Когда-он-применяется)

[40. Сколько объектов статического вложенного класса можно создать в программе?](#40-Сколько-объектов-статического-вложенного-класса-можно-создать-в-программе)

[41. Что такое локальный класс? Когда он применяется?](#41-Что-такое-локальный-класс-Когда-он-применяется)

[42. Что такое анонимный класс? Когда он применяется?](#42-Что-такое-анонимный-класс-Когда-он-применяется)

[43. Сколько объектов анонимного класса можно создать в программе?](#43-Сколько-объектов-анонимного-класса-можно-создать-в-программе)

[44. Что такое исключения? Какие типы исключительных ситуаций бывают?](#44-Что-такое-исключения-Какие-типы-исключительных-ситуаций-бывают)

[45. Назовите основные методы класса Object?](#45-Назовите-основные-методы-класса-Object)

[46. Что такое шаблоны проектирования?](#46-Что-такое-шаблоны-проектирования)

[47. Объясните шаблон - декоратор. Придумайте пример, не относящийся к технике.](#47-Объясните-шаблон---декоратор-Придумайте-пример-не-относящийся-к-технике)

[48. Объясните шаблон - стратегия. Придумайте пример, не относящийся к технике.](#48-Объясните-шаблон---стратегия-Придумайте-пример-не-относящийся-к-технике)

[49. Объясните шаблон - синглтон. Придумайте пример, не относящийся к технике.](#49-Объясните-шаблон---синглтон-Придумайте-пример-не-относящийся-к-технике)

[50. Объясните шаблон - фабричный метод. Придумайте пример, не относящийся к технике.](#50-Объясните-шаблон---фабричный-метод-Придумайте-пример-не-относящийся-к-технике)

[51. Что такое enum? Когда можно его применять?](#51-Что-такое-enum-Когда-можно-его-применять)

[52. Что такое record? Когда можно его применять?](#52-Что-такое-record-Когда-можно-его-применять)

[53. Зачем нужны StringBuilder, StringBuffer, StringJoiner? Что они делают?](#53-Зачем-нужны-StringBuilder-StringBuffer-StringJoiner-Что-они-делают)

[54. Чем отличаются StringBuffer и StringBuilder?](#54-Чем-отличаются-StringBuffer-и-StringBuilder)

[55. Каким образом производится экранирование символов и зачем это нужно?](#55-Каким-образом-производится-экранирование-символов-и-зачем-это-нужно)

[56. Что такое управляющие последовательности?](#56-Что-такое-управляющие-последовательности)

[57. Зачем нужно форматирование данных? Метод format().](#57-Зачем-нужно-форматирование-данных-Метод-format())

[58. Что такое varargs? В каких случаях стоит его применять?](#58-Что-такое-varargs-В-каких-случаях-стоит-его-применять)

[59. В каких случаях может возникнуть неоднозначность при работе с varargs?](#59-В-каких-случаях-может-возникнуть-неоднозначность-при-работе-с-varargs)

[60. Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вывод?](#60-Что-такое-форматированный-вывод-Какие-механизмы-позволяют-осуществить-форматированный-вывод)

#### 1. Что такое ООП?
Подход (методология) к программированию ориентированный на объекты. Представление программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

Важным элементом ООП является абстракция. Эффективным средством применения абстракции служат иерархические конструкции. Это позволяет упрощать понимание сложных систем, разбивая их на более управляемые части.

Например, внешне автомобиль выглядит единым объектом. Но внутрион состоит из нескольких подсистем: рулевого управления, двигатель, тормоза, аудиосистемы и т.п. Каждая из этих подсистем, также собрана из более специализированных узлов. Т.е. структуру автомобиля (или любой сложной системы) можно описать с помощью иерархических абстракций. Это применимо и к компьютерным программам.

Суть ООП - с помощью абстракций организовать данные компьютерной программы в виде объектов, а последовательность этапов ее выполнения — в совокупность сообщений, передаваемых между этими объектами. Т.е. каждый из этих объектов описывает свое особое поведение. Эти объекты можно считать конкретными сущностями, реагирующими на сообщения, предписывающие им выполнить конкретное действие.

[_к оглавлению_](#Оглавление)
#### 2. Базовые концепции ООП.
+ **Инкапсуляция** - это сокрытие данных и методов класса от внешнего мира, предоставляя доступ к ним только через определенные методы. Это позволяет контролировать доступ к данным и защищать целостность объекта.
```java
public class Car {
    private String model; // Приватное поле
    private int year; 

    public String getModel() { // Метод для получения значения поля model
        return model;
    }

    public void setModel(String model) { // Метод для установки значения поля model
        this.model = model;
    }
    // ... другие методы
}
```
В этом примере поля `model` и `year` объявлены как `private`, что ограничивает доступ к ним извне класса.  Доступ к ним осуществляется через методы `getModel()` и `setModel()`.

+ **Наследование** - Наследование — это механизм, позволяющий создавать новые классы (подклассы), наследующие свойства и методы от существующего класса (суперкласса).
```java
public class SportsCar extends Car {
    public void drift() {
        System.out.println("Автомобиль дрифтует");
    }
}
```
В этом примере `SportsCar` — это подкласс, наследующий все свойства и методы от суперкласса `Car`.  Он также добавляет свой собственный метод `drift()`.

+ **Полиморфизм** - это способность объектов разных классов реагировать по-разному на один и тот же вызов метода.
```java
public class Main {
    public static void main(String[] args) {
        Car myCar = new Car();
        SportsCar mySportsCar = new SportsCar();

        drive(myCar); // Вызов метода drive() для объекта класса Car
        drive(mySportsCar); // Вызов метода drive() для объекта класса SportsCar
    }

    public static void drive(Car car) {
        car.startEngine();
        car.accelerate();
    }
}
```
В этом примере метод `drive()` принимает объект класса `Car`.  Но когда он вызывается с объектом `mySportsCar`, метод `drift()` также будет вызван, потому что `SportsCar` наследует от `Car`.

+ **Абстракция** - это одна из ключевых концепций объектно-ориентированного программирования (ООП). Она позволяет нам скрыть детали реализации и сосредоточиться на том, как объекты используются, а не на том, как они работают внутри. 

Пример: Автомобиль

Представьте, что вам нужно написать программу для управления автомобилем. Вам не нужно знать все детали о том, как работают двигатель, коробка передач, тормоза и т.д. Вам нужна абстракция, которая позволяет управлять автомобилем на высоком уровне: запустить, разогнать, повернуть, затормозить.

**В Java абстракция реализуется двумя способами:**

**1. Абстрактные классы:**

    * Абстрактный класс — это класс, который нельзя напрямую инстанцировать (создавать объекты). 
    * Он служит как шаблон для других классов, которые наследуют от него. 
    * Абстрактные классы могут содержать как абстрактные методы, так и обычные методы.

```java
    public abstract class Vehicle { // Абстрактный класс
        public abstract void start(); // Абстрактный метод
        public void stop() { // Обычный метод
            System.out.println("Остановка...");
        }
    }

    public class Car extends Vehicle { // Класс, наследующий от Vehicle
        @Override
        public void start() {
            System.out.println("Запускаем двигатель...");
        }
    }
```

В этом примере `Vehicle` — это абстрактный класс, который определяет общий интерфейс для всех транспортных средств. Метод `start()` абстрактный, то есть он не имеет реализации в абстрактном классе. Класс `Car` наследует от `Vehicle` и должен предоставить реализацию для метода `start()`.

**2. Интерфейсы:**

    * Интерфейс — это  контракт, который определяет набор абстрактных методов без реализации. 
    * Классы, которые реализуют интерфейс, должны предоставить свою собственную реализацию этих методов. 
```java
    public interface Flyable { // Интерфейс
        public void takeOff();
        public void land();
    }

    public class Airplane implements Flyable { // Класс, реализующий интерфейс
        @Override
        public void takeOff() {
            System.out.println("Самолет взлетает...");
        }

        @Override
        public void land() {
            System.out.println("Самолет приземляется...");
        }
    }
```
    * `Flyable` — это интерфейс, который определяет методы, необходимые для полета.
    * `Airplane` — это класс, который реализует этот интерфейс, предоставляя собственные реализации методов `takeOff()` и `land()`.

Преимущества абстракции:

* Упрощение кода: Скрывая детали реализации, абстракция делает код более читаемым и понятным.
* Гибкость: Абстрактные классы и интерфейсы позволяют создавать более гибкие структуры кода, которые легко адаптировать под разные потребности.
* Повторное использование кода: Абстрактные классы и интерфейсы облегчают повторное использование кода, так как классы, реализующие их, могут иметь разные реализации одних и тех же методов.

В заключение:

Абстракция в Java помогает создавать более чистый, гибкий и удобный в использовании код, отделяя детали реализации от логики использования объектов.

[_к оглавлению_](#Оглавление)
#### 3. Укажите из каких элементов состоит класс. Расскажите о каждом из них.

Класс в Java — это  шаблон или чертеж для создания объектов. Он определяет характеристики (атрибуты) и поведение (методы) объектов этого класса. Класс состоит из следующих элементов:

1. Модификатор доступа:

* Определяет уровень видимости класса. 
* В Java доступны следующие модификаторы доступа:
    * `public`: класс виден всем.
    * `protected`: класс виден только в том же пакете или в подклассах.
    * `private`: класс виден только внутри самого класса.
    * (без модификатора):  класс виден только в том же пакете.

2.  Ключевое слово `class`:

* Обозначает, что это определение класса.

3. Имя класса:

* Должно начинаться с большой буквы и следовать правилам именования идентификаторов в Java.

4. Тело класса:

* Ограничено фигурными скобками `{}`.
* Содержит:
    * Поля (переменные класса):
        * Хранят данные, которые описывают состояние объекта. 
        * Могут быть объявлены с использованием различных типов данных (например, `int`, `String`, `boolean`).
        * Могут иметь различные модификаторы доступа (`public`, `protected`, `private`).
    * Методы (функции класса):
        * Определяют поведение объекта, то есть то, что он может делать.
        * Имеют имя, список параметров и тип возвращаемого значения.
        * Могут использовать поля класса для доступа к данным объекта.
        * Могут иметь различные модификаторы доступа (`public`, `protected`, `private`, `static`).
    * Конструкторы:
        * Специальные методы, которые вызываются при создании объекта.
        * Используются для инициализации полей объекта.
        * Имеют то же имя, что и класс.
        * Не имеют типа возвращаемого значения.
    * Вложенные классы:
        * Классы, которые определены внутри другого класса.
        * Могут быть `static` или `non-static`.
        * Могут иметь различные модификаторы доступа.
    * Статические блоки:
        * Используются для инициализации статических членов класса.
        * Выполняются только один раз, при загрузке класса.
```java
public class Dog { // Модификатор доступа (public), ключевое слово (class), имя класса (Dog)

    public String name; // Поле (public)
    private int age; // Поле (private)

    public Dog(String name, int age) { // Конструктор
        this.name = name;
        this.age = age;
    }

    public void bark() { // Метод (public)
        System.out.println("Гав-гав!");
    }

    public static void main(String[] args) { // Статический метод (main)
        Dog myDog = new Dog("Рекс", 3); // Создание объекта
        myDog.bark(); // Вызов метода объекта
    }
}
```
[_к оглавлению_](#Оглавление)
#### 4. Что такое конструктор?

**Конструктор класса** — это специальный метод, который вызывается автоматически при создании нового объекта. Он отвечает за инициализацию полей объекта, то есть за присвоение им начальных значений.

**Основные характеристики конструктора:**

* Имя:  Имя конструктора всегда совпадает с именем класса.
* Тип возвращаемого значения:  Конструктор не имеет типа возвращаемого значения.
* Вызов: Конструктор вызывается автоматически при использовании оператора `new` для создания нового объекта.
* Перегрузка:  В классе может быть несколько конструкторов с разными параметрами (перегрузка конструкторов).
```java
public class Dog {
    public String name;
    private int age;

    // Конструктор без параметров
    public Dog() {
        name = "Безымянный";
        age = 0;
    }

    // Конструктор с двумя параметрами
    public Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Метод для вывода информации о собаке
    public void displayInfo() {
        System.out.println("Имя: " + name + ", Возраст: " + age);
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog1 = new Dog(); // Создание объекта с использованием конструктора без параметров
        dog1.displayInfo();

        Dog dog2 = new Dog("Рекс", 3); // Создание объекта с использованием конструктора с параметрами
        dog2.displayInfo();
    }
}
```
**В этом примере:**

* `Dog` — это класс, который имеет два конструктора: один без параметров и один с двумя параметрами.
* При создании объекта `dog1` используется конструктор без параметров, поэтому по умолчанию имя собаки будет "Безымянный", а возраст 0.
* При создании объекта `dog2` используется конструктор с параметрами, поэтому имя собаки будет "Рекс", а возраст 3.

Зачем нужны конструкторы?

* Инициализация: Конструкторы позволяют инициализировать поля объекта сразу после его создания. 
* Контроль:  Конструкторы обеспечивают контроль над тем, как создаются объекты.  
* Проверка данных: Конструкторы могут содержать проверку данных, чтобы убедиться, что объект создается с корректными значениями.

Важно:

* Если вы не создадите ни одного конструктора в классе, Java автоматически сгенерирует конструктор без параметров.
* Конструкторы могут вызывать друг друга с помощью ключевого слова `this`. 

Конструкторы — важная часть любого класса, которая позволяет правильно инициализировать объекты и контролировать их создание.

[_к оглавлению_](#Оглавление)
#### 5. Можно ли наследовать конструктор?

В Java нельзя напрямую наследовать конструктор класса. Конструкторы не являются частью наследования.

**Почему нельзя наследовать конструкторы?**

* Конструкторы не являются частью наследования.  Наследование в Java относится к свойствам и методам класса. Конструкторы — это специальные методы, которые отвечают за создание объекта, а не за его поведение.
* Каждый класс должен иметь свою собственную инициализацию.  Наследование позволяет подклассам использовать свойства и методы суперкласса, но они также должны иметь возможность инициализировать свои собственные уникальные свойства.
* Конструкторы не могут быть абстрактными.  Абстрактные методы должны быть реализованы в подклассах, но конструкторы не могут быть абстрактными.

**Как можно решить проблему инициализации в подклассах?**

**1. Вызов конструктора суперкласса:** в конструкторе подкласса можно вызвать конструктор суперкласса с помощью ключевого слова `super()`. Это позволяет инициализировать свойства суперкласса, а затем продолжить инициализацию свойств подкласса.
```java
    public class Dog extends Animal { 
        private String breed;

        public Dog(String name, int age, String breed) { 
            super(name, age); // Вызов конструктора суперкласса
            this.breed = breed;
        }
    }
```
**2. Перегрузка конструкторов:** в подклассе можно создать несколько конструкторов с различными параметрами. Это позволяет создавать объекты подкласса с различными начальными значениями.
```java
    public class Dog extends Animal { 
        private String breed;

        public Dog(String name, int age) { 
            super(name, age); 
            breed = "Неизвестная";
        }

        public Dog(String name, int age, String breed) { 
            super(name, age); 
            this.breed = breed;
        }
    }
```

[_к оглавлению_](#Оглавление)
#### 6. Что такое перегрузка конструктора?

Перегрузка конструктора - это возможность создания нескольких конструкторов с разными параметрами в одном классе. В результате это позволяет удобно управлять различными способами инициализации объектов этого класса. Когда создается объект, Java определяет, какой конструктор использовать на основе переданных аргументов. В случае перегрузки конструкторов, выбирается тот конструктор, который соответствует переданным параметрам.
```java
public class Person {
    private String name;
    private int age;

    // Конструктор без параметров
    public Person() {
        this.name = "Unknown";
        this.age = 0;
    }

    // Конструктор с одним параметром
    public Person(String name) {
        this.name = name;
        this.age = 0;
    }

    // Конструктор с двумя параметрами
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```
[_к оглавлению_](#Оглавление)
#### 7. Что такое статический метод?

Статический метод в Java - это метод, который принадлежит классу, а не объекту конкретного класса. Он может быть вызван без создания экземпляра класса и обычно используется для выполнения общих операций, которые не зависят от конкретного объекта. Переменные, к которым обращается такой метод, тоже должны быть статическими.

Пример статического метода:
```java
public class MathHelper {
    public static int sum(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        int result = MathHelper.sum(5, 3);
        System.out.println("Sum is: " + result); // Выведет: Sum is: 8
    }
}
```
В данном примере `sum` - это статический метод класса `MathHelper`, который складывает два числа и возвращает результат. Метод `sum` вызывается без создания экземпляра класса `MathHelper`, что позволяет использовать его напрямую.

**Важные свойства:**
- обращается к статическим переменным напрямую;
- не может обращаться к переменным экземпляра и методам экземпляра класса (нет ключевого слова this, т.к. объект не создается);
-  

[_к оглавлению_](#Оглавление)
#### 8. Что такое не статический метод?



[_к оглавлению_](#Оглавление)
#### 9. Для чего используется ключевое слово this?
[_к оглавлению_](#Оглавление)
#### 10. Какой класс является базовым родительским классом для всех классов?
[_к оглавлению_](#Оглавление)
#### 11. Что такое наследование? Приведите примеры из реальной жизни.
[_к оглавлению_](#Оглавление)
#### 12. Опишите процесс создания нового объекта.
[_к оглавлению_](#Оглавление)
#### 13. Как вызвать метод из родительского класса?
[_к оглавлению_](#Оглавление)
#### 14. Что такое переопределение метода?
[_к оглавлению_](#Оглавление)
#### 15. Можно ли переопределить статический метод?
[_к оглавлению_](#Оглавление)
#### 16. Что такое сокрытие метода?
[_к оглавлению_](#Оглавление)
#### 17. Что такое виртуальная функция и используются ли они в Java?
[_к оглавлению_](#Оглавление)
#### 18. Что такое перегрузка метода?
[_к оглавлению_](#Оглавление)
#### 19. Можно ли изменить тип возвращаемых данных при перегрузке метода?
[_к оглавлению_](#Оглавление)
#### 20. Что такое множественное наследование? Как его можно реализовать в Java.
[_к оглавлению_](#Оглавление)
#### 21. Что такое полиморфизм? Приведите примеры из реальной жизни.
[_к оглавлению_](#Оглавление)
#### 22. Что такое инкапсуляция?
[_к оглавлению_](#Оглавление)
#### 23. Как реализована инкапсуляция в Java?
[_к оглавлению_](#Оглавление)
#### 24. Можно ли применить модификаторы доступа к конструкторам?
[_к оглавлению_](#Оглавление)
#### 25. Что такое интерфейс?
[_к оглавлению_](#Оглавление)
#### 26. Перечислите элементы, которые может содержать интерфейс.
[_к оглавлению_](#Оглавление)
#### 27. Можно ли создать объект интерфейса? Если да, то как?
[_к оглавлению_](#Оглавление)
#### 28. Может ли интерфейс содержать какие-либо методы с реализацией? Если да, то какие?
[_к оглавлению_](#Оглавление)
#### 29. Что такое абстракция?
[_к оглавлению_](#Оглавление)
#### 30. Что такое абстрактный класс?
[_к оглавлению_](#Оглавление)
#### 31. Сколько абстрактных методов должен и может содержать абстрактный класс?
[_к оглавлению_](#Оглавление)
#### 32. Может ли абстрактный класс содержать обычные методы?
[_к оглавлению_](#Оглавление)
#### 33. Сколько объектов абстрактного класса можно создать в программе?
[_к оглавлению_](#Оглавление)
#### 34. Что нужно делать, если наследник абстрактного класса не переопределяет все абстрактные методы родителя?
[_к оглавлению_](#Оглавление)
#### 35. Чем отличается интерфейс от абстрактного класса?
[_к оглавлению_](#Оглавление)
#### 36. Что такое вложенные классы? Зачем они нужны?
[_к оглавлению_](#Оглавление)
#### 37. Какие типы вложенных классов существуют в Java?
[_к оглавлению_](#Оглавление)
#### 38. Что такое внутренний класс? Когда он применяется?
[_к оглавлению_](#Оглавление)
#### 39. Что такое статический вложенный класс? Когда он применяется?
[_к оглавлению_](#Оглавление)
#### 40. Сколько объектов статического вложенного класса можно создать в программе?
[_к оглавлению_](#Оглавление)
#### 41. Что такое локальный класс? Когда он применяется?
[_к оглавлению_](#Оглавление)
#### 42. Что такое анонимный класс? Когда он применяется?
[_к оглавлению_](#Оглавление)
#### 43. Сколько объектов анонимного класса можно создать в программе?
[_к оглавлению_](#Оглавление)
#### 44. Что такое исключения? Какие типы исключительных ситуаций бывают?
[_к оглавлению_](#Оглавление)
#### 45. Назовите основные методы класса Object?
[_к оглавлению_](#Оглавление)
#### 46. Что такое шаблоны проектирования?
[_к оглавлению_](#Оглавление)
#### 47. Объясните шаблон - декоратор. Придумайте пример, не относящийся к технике.
[_к оглавлению_](#Оглавление)
#### 48. Объясните шаблон - стратегия. Придумайте пример, не относящийся к технике.
[_к оглавлению_](#Оглавление)
#### 49. Объясните шаблон - синглтон. Придумайте пример, не относящийся к технике.
[_к оглавлению_](#Оглавление)
#### 50. Объясните шаблон - фабричный метод. Придумайте пример, не относящийся к технике.
[_к оглавлению_](#Оглавление)
#### 51. Что такое enum? Когда можно его применять?
[_к оглавлению_](#Оглавление)
#### 52. Что такое record? Когда можно его применять?
[_к оглавлению_](#Оглавление)
#### 53. Зачем нужны StringBuilder, StringBuffer, StringJoiner? Что они делают?
[_к оглавлению_](#Оглавление)
#### 54. Чем отличаются StringBuffer и StringBuilder?
[_к оглавлению_](#Оглавление)
#### 55. Каким образом производится экранирование символов и зачем это нужно?
[_к оглавлению_](#Оглавление)
#### 56. Что такое управляющие последовательности?
[_к оглавлению_](#Оглавление)
#### 57. Зачем нужно форматирование данных? Метод format().
[_к оглавлению_](#Оглавление)
#### 58. Что такое varargs? В каких случаях стоит его применять?
[_к оглавлению_](#Оглавление)
#### 59. В каких случаях может возникнуть неоднозначность при работе с varargs?
[_к оглавлению_](#Оглавление)
#### 60. Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вывод?
[_к оглавлению_](#Оглавление)
