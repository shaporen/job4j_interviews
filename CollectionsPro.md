##### [job4j_interviews](https://github.com/shaporen/job4j_interviews/blob/main/README.md)
#### Оглавление
+ [1. Что такое generics?](#1-Что-такое-generics)
+ [2. Что такое wild cards?](#2-Что-такое-wild-cards)
+ [3. Что такое bounded wild cards?](#3-Что-такое-bounded-wild-cards)
+ [4. Что такое unbounded wild cards?](#4-Что-такое-unbounded-wild-cards)
+ [5. Где хранится информация про generics?](#5-Где-хранится-информация-про-generics)
+ [6. Как можно получить тип generics?](#6-Как-можно-получить-тип-generics)
+ [7. Что такое итератор? В чем разница между itetator и listIterator?](#7-Что-такое-итератор-В-чем-разница-между-itetator-и-listIterator)
+ [8. Что такое fail-fast и fail-safe поведение итератора и в чем между ними разница? Когда возникает ConcurrentModificationException?](#8-Что-такое-fail-fast-и-fail-safe-поведение-итератора-и-в-чем-между-ними-разница-Когда-возникает-ConcurrentModificationException)
+ [9. Что такое "коллекция".](#9-Что-такое-коллекция)
+ [10. Назовите базовые интерфейсы коллекций.](#10-Назовите-базовые-интерфейсы-коллекций)
+ [11. Расскажите реализации интерфейса List.](#11-Расскажите-реализации-интерфейса-List)
+ [12. Расскажите реализации интерфейса Set.](#12-Расскажите-реализации-интерфейса-Set)
+ [13. Расскажите реализации интерфейса Map.](#13-Расскажите-реализации-интерфейса-Map)
+ [14. В чем отличие ArrayList от LinkedList?](#14-В-чем-отличие-ArrayList-от-LinkedList)
+ [15. В чем отличие Set от List?](#15-В-чем-отличие-Set-от-List)
+ [16. Расскажите про методы класса Object hashCode() и equals().](#16-Расскажите-про-методы-класса-Object-hashCode-и-equals)
+ [17. Расскажите, что такое коллизии в Map? Как с ними бороться?](#17-Расскажите-что-такое-коллизии-в-Map-Как-с-ними-бороться)
+ [18. Расскажите, что такое анализ алгоритма?](#18-Расскажите-что-такое-анализ-алгоритма)
+ [19. Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?](#19-Какая-временная-сложность-алгоритмов(O-нотация)-добавления-замены-и-удаления-в-каждой-из-коллекций-С-чем-связаны-отличия)
+ [20. Расскажите реализации данных очередей и стеков.](#20-Расскажите-реализации-данных-очередей-и-стеков)
+ [21. Расскажите про реализации деревьев.](#21-Расскажите-про-реализации-деревьев)
+ [22. Что такое loadFactor?](#22-Что-такое-loadFactor)
+ [23. Перечислите побитовые логические операции, которые Вы знаете. Расскажите, как они работают.](#23-Перечислите-побитовые-логические-операции-которые-Вы-знаете-Расскажите-как-они-работают)
+ [24. Расскажите про операции сдвига. Какие они бывают и что делают?](#24-Расскажите-про-операции-сдвига-Какие-они-бывают-и-что-делают)
+ [25. Как хранится знак числа в Java? Как хранятся отрицательные числа?](#25-Как-хранится-знак-числа-в-Java-Как-хранятся-отрицательные-числа)
+ [26. Расскажите о системах сборки проекта. В чем отличие систем сборки Ant, Maven и Gradle?](#26-Расскажите-о-системах-сборки-проекта-В-чем-отличие-систем-сборки-Ant-Maven-и-Gradle)
+ [27. Как создать maven проект?](#27-Как-создать-maven-проект)
+ [28. Какова структура maven проекта?](#28-Какова-структура-maven-проекта)
+ [29. Расскажите о файле pom.xml. Как он структурирован и за что отвечает содержание каждой части?](#29-Расскажите-о-файле-pomxml-Как-он-структурирован-и-за-что-отвечает-содержание-каждой-части)
+ [30. Что такое координаты зависимости?](#30-Что-такое-координаты-зависимости)
+ [31. Что такое транзитивные зависимости?](#31-Что-такое-транзитивные-зависимости)
+ [32. Что такое область видимости зависимости? Сколько областей видимости предусмотрено и где они применяются?](#32-Что-такое-область-видимости-зависимости-Сколько-областей-видимости-предусмотрено-и-где-они-применяются)
+ [33. Расскажите о жизненном цикле maven. В какой последовательности выполняются фазы цикла и что происходит на каждой фазе сборки?](#33-Расскажите-о-жизненном-цикле-maven-В-какой-последовательности-выполняются-фазы-цикла-и-что-происходит-на-каждой-фазе-сборки)

#### 1. Что такое generics?

Generics в Java - это механизм, позволяющий создавать типы данных, которые могут работать с различными типами данных.

Generics позволяют типам (классам и интерфейсам) быть параметрами при определении классов, интерфейсов и методов. Параметры типа предоставляют возможность повторно использовать один и тот же код с разными входами наподобие формальных параметров в объявлениях методов. Разница в том, что входные данные для формальных параметров являются значениями, а для дженериков - типами данных. Переменная типа может быть любым не примитивным типом.

В Java generics добавили для реализации обобщенных коллекций, безопасных с точки зрения типов. Ошибка компиляции - это лучше, чем исключение ClassCastException в связи с неправильным приведением типов во время выполнения. После компиляции какая-либо информация о дженериках стирается. Это называется "Стирание типов". Также дженерики делают исходный код программы более удобочитаемым.

Преимущества generics:
+ Безопасность типов: Generics предотвращают ошибки времени выполнения, связанные с использованием неверных типов данных. 
+ Улучшенная читаемость: код становится более читаемым и понятным, так как типы данных явно указываются.
+ Повторное использование кода: Generics позволяют создавать обобщенные классы и методы, которые можно использовать для различных типов данных.
+ Уменьшение дублирования кода: с помощью generics можно избежать написания повторяющегося кода для разных типов данных.

Основные концепции generics:
+ Тип-параметр: это placeholder для типа данных, который будет использоваться в классе или методе. Обозначается угловыми скобками (<>), например: `<T>`.
+ Тип-аргумент: фактический тип данных, который передается в качестве аргумента при создании объекта generic-класса или при вызове generic-метода.
+ Ограничения типа: возможность ограничить тип-параметр определенным типом или интерфейсом. 

Примеры использования generics:

Generic-классы:

```java
class Box<T> {
  private T item;

  public Box(T item) {
    this.item = item;
  }

  public T getItem() {
    return item;
  }
}

Box<String> stringBox = new Box<>("Hello");
Box<Integer> intBox = new Box<>(10);
```

Generic-методы:

```java
public static <T> T findFirst(List<T> list) {
  // ...
}

List<String> stringList = new ArrayList<>();
String firstString = findFirst(stringList);
```

Преимущества использования generics:
+ Улучшение безопасности типов.
+ Повышение читаемости кода.
+ Повторное использование кода.
+ Уменьшение дублирования кода.

Важно отметить, что generics - это compile-time mechanism, а не runtime mechanism. Это означает, что типы данных проверяются во время компиляции, а не во время выполнения.

[_к оглавлению_](#Оглавление)
#### 2. Что такое wild cards?

В Java, "wildcards" - это специальные символы, используемые для представления неизвестных типов в дженериках. Они позволяют писать более гибкий и универсальный код, особенно когда вы работаете с коллекциями.

Основные типы wildcards:
* `?` (Unbounded Wildcard): представляет любой тип. Используется, когда конкретный тип не важен.
* `? extends T` (Upper Bounded Wildcard): представляет любой тип, который является подтипом `T` (или `T` сам по себе).
* `? super T` (Lower Bounded Wildcard): представляет любой тип, который является супертипом `T` (или `T` сам по себе).

Пример:

```java
List<String> strings = new ArrayList<>();
List<?> anyList = strings; // Unbounded wildcard, может содержать любые типы
```

В этом примере `anyList` может содержать список любого типа. Однако, вы не можете добавить элементы в `anyList`, потому что компилятор не знает, какой тип элементов в нем хранится.

Использование wildcards:
* Универсальные методы: Wildcards используются для написания методов, которые могут работать с коллекциями различных типов.
* Создание неизменяемых коллекций: Wildcards могут использоваться для создания коллекций, которые можно только читать, но не изменять.
* Улучшение читаемости кода: Wildcards делают код более ясным, показывая, какие типы допустимы для конкретной переменной или метода.

Важно помнить:
* Wildcards не изменяют тип коллекции. Они просто предоставляют более гибкий способ работы с коллекциями различных типов.
* Использование `? extends T` позволяет добавлять элементы типа `T` или его подтипов.
* Использование `? super T` позволяет добавлять элементы типа `T` или его супертипов.

Примеры использования:

 Метод, который принимает коллекцию любого типа:

```java
public static void printElements(Collection<?> collection) {
  for (Object element : collection) {
    System.out.println(element);
  }
}
```

 Метод, который принимает список подтипов String:

```java
public static void printStrings(List<? extends String> stringList) {
  for (String string : stringList) {
    System.out.println(string);
  }
}
```

 Метод, который принимает список супертипов Number:

```java
public static void sumNumbers(List<? super Number> numberList) {
  int sum = 0;
  for (Number number : numberList) {
    sum += number.intValue();
  }
  System.out.println(sum);
}
```

[_к оглавлению_](#Оглавление)
#### 3. Что такое bounded wild cards?

Bounded wildcards — это способ ограничения типа в Generic Type параметрах. Они позволяют работать с подтипами (extends) или надтипами (super) заданного типа, но не с любым типом.

Примеры:

 `<? extends Number>`:  эта wildcard принимает как аргумент любые классы, являющиеся подтипами `Number`, например `Integer`, `Double`, `Float` и т.д.
 `<? super Integer>`: эта wildcard принимает как аргумент любые классы, являющиеся надтипами `Integer`, например `Number`, `Object`, `Comparable` и т.д.

Зачем нужны bounded wildcards:

* Повышение безопасности: bounded wildcards позволяют гарантировать, что операции с Generic-типами будут выполняться только с допустимыми типами.
* Улучшение читаемости кода:  они позволяют четко определить ограничения на типы в Generic-классах и методах, что делает код более понятным.
* Снижение количества ошибок:  bounded wildcards помогают избежать ошибок времени компиляции, связанных с использованием неподходящих типов.

Пример использования:

```java
// Класс для хранения списка чисел
class NumberList<T extends Number> {
    private List<T> numbers;

    public NumberList(List<T> numbers) {
        this.numbers = numbers;
    }

    // Метод для суммирования чисел в списке
    public double sum() {
        double sum = 0;
        for (T number : numbers) {
            sum += number.doubleValue();
        }
        return sum;
    }
}

// Использование bounded wildcard для создания списка чисел
List<Integer> integers = Arrays.asList(1, 2, 3);
NumberList<? extends Number> numberList = new NumberList<>(integers);

// Вызов метода sum()
double sum = numberList.sum();

// Неверно: невозможно добавить число в список
// numberList.add(4); // Ошибка компиляции
```

В этом примере:
* `NumberList` принимает как аргумент тип `T`, который должен быть подтипом `Number`.
* `numberList` — список, который может содержать только числа, поэтому используется `? extends Number`.
* Метод `sum()` работает со всеми типами чисел в списке, поскольку они наследуются от `Number`.
* Добавление нового числа в список `numberList` невозможно, так как `? extends Number` не гарантирует, что список принимает конкретный тип числа.

Важно:
* Wildcards всегда используются в контексте generic-типов.
* `? extends T` — для ограничений на подтипы.
* `? super T` — для ограничений на надтипы.
* `?` — неограниченная wildcard, которая может принимать любой тип.

[_к оглавлению_](#Оглавление)
#### 4. Что такое unbounded wild cards?

В Java, неограниченные подстановочные знаки (`?`) используются для представления любого типа. Они могут применяться в различных контекстах, таких как:

***1. Параметры типов:***

 В качестве типа аргумента для обобщенных методов и классов:
    ```java
    public static <T> void printList(List<?> list) {
        for (Object obj : list) {
            System.out.println(obj);
        }
    }
    ```

В данном случае `printList` принимает список любого типа (`List<?>`).  Это означает, что можно передать список `Integer`, `String`, `Double` или любого другого типа. Однако, поскольку тип неизвестен, вы можете вызывать только методы, доступные для `Object` (например, `toString()`, `equals()`).

***2. В качестве типа возвращаемого значения:***

 В методах, возвращающих коллекцию любого типа:
    ```java
    public static List<?> getAnyList() {
        return new ArrayList<String>();
    }
    ```

В этом случае метод `getAnyList` возвращает список, который может содержать элементы любого типа. Однако, тип возвращаемого списка не может быть точно определен.

***3. В качестве типа переменной:***

Для хранения значений любого типа:
    ```java
    List<?> anyList = new ArrayList<String>();
    ```

В данном случае переменная `anyList` может хранить список любого типа. Однако, как и в случае с параметрами типов, вы можете вызывать только методы, доступные для `Object`.

Ограничения неограниченных подстановочных знаков:

* Ограниченная функциональность: неограниченные подстановочные знаки предоставляют ограниченную функциональность, так как вы не можете добавлять элементы в коллекции `<?>`, кроме `null`, и вы не можете вызывать методы, требующие конкретного типа.
* Риск несовместимости: использование неограниченных подстановочных знаков может привести к несовместимости типов во время компиляции или во время выполнения.

Вместо неограниченных подстановочных знаков, рекомендуется использовать ограниченные подстановочные знаки (`<? extends T>` или `<? super T>`) для повышения безопасности типов и функциональности.

Пример ограниченных подстановочных знаков:

```java
public static <T> void printList(List<? extends T> list) {
    for (T obj : list) {
        System.out.println(obj);
    }
}
```

В этом случае `printList` принимает список, который содержит элементы типа `T` или его подтипов. Это позволяет вызывать методы, доступные для `T`, но не добавлять элементы в список, если вы не уверены, что они являются `T` или его подтипами.

[_к оглавлению_](#Оглавление)
#### 5. Где хранится информация про generics?

Информация о Generics хранится в исходном коде до этапа компиляции. Во время компиляции компилятор Java удаляет информацию о Generics из скомпилированного кода в процессе, который называется стиранием типов (type erasure). Информация о Generics используется компилятором для проверки типов во время компиляции и для генерации предупреждений или ошибок, связанных с типами данных. Однако в скомпилированном байт-коде Java информация о Generics удаляется, и все обобщенные типы преобразуются в их необобщенные версии.

[_к оглавлению_](#Оглавление)
#### 6. Как можно получить тип generics?

В Java нет прямого способа получить тип generic непосредственно, но есть несколько способов получить информацию о нем:

- ***1. Использование `Class#getGenericSuperclass()` и `Class#getGenericInterfaces()`:***

Эти методы возвращают `Type` объект, представляющий обобщенный суперкласс или интерфейс. Вы можете использовать `ParameterizedType` и `TypeVariable` для извлечения информации о типах.

```java
class MyClass<T> {
    public static void main(String[] args) {
        Type superclass = MyClass.class.getGenericSuperclass();
        if (superclass instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) superclass;
            Type[] typeArguments = parameterizedType.getActualTypeArguments();
            System.out.println("Тип параметра: " + typeArguments[0]); // Вывод: T
        }
    }
}
```

- ***2. Использование `Method#getGenericParameterTypes()`:***

Этот метод возвращает массив `Type` объектов, представляющих типы параметров метода. Это полезно для получения информации о типах параметров обобщенных методов.

```java
class MyClass<T> {
    public <E> void myMethod(E e) {
        Type[] parameterTypes = MyClass.class.getMethod("myMethod", Object.class).getGenericParameterTypes();
        System.out.println("Тип параметра: " + parameterTypes[0]); // Вывод: E
    }
}
```

- ***3. Использование рефлексии:***

Вы можете использовать рефлексию для получения информации о типах generic. Например, вы можете получить `Field#getGenericType()` для получения типа generic поля.

```java
class MyClass<T> {
    private T myField;

    public static void main(String[] args) throws NoSuchFieldException {
        Field field = MyClass.class.getDeclaredField("myField");
        Type genericType = field.getGenericType();
        if (genericType instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) genericType;
            Type[] typeArguments = parameterizedType.getActualTypeArguments();
            System.out.println("Тип параметра: " + typeArguments[0]); // Вывод: T
        }
    }
}
```

- ***4. Использование аннотаций:***

Вы можете использовать аннотации для передачи информации о типах generic. Например, вы можете использовать аннотации `@TypeParameter` и `@TypeVariable` для аннотирования типов параметров и переменных типов.

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE_PARAMETER)
public @interface TypeParameter {
    Class<?> type();
}

class MyClass<@TypeParameter(type = String.class) T> {
    public static void main(String[] args) {
        TypeVariable<?>[] typeVariables = MyClass.class.getTypeParameters();
        for (TypeVariable<?> typeVariable : typeVariables) {
            TypeParameter typeParameter = typeVariable.getAnnotation(TypeParameter.class);
            if (typeParameter != null) {
                System.out.println("Тип параметра: " + typeParameter.type()); // Вывод: class java.lang.String
            }
        }
    }
}
```

Важно:
* Получение информации о типах generic не всегда просто, и может потребовать глубокого понимания рефлексии и API типов Java.
* В некоторых случаях вы можете получить информацию о типах generic только во время выполнения, а не во время компиляции.
* Будьте осторожны с использованием рефлексии, так как она может быть медленной и сложной.

[_к оглавлению_](#Оглавление)
#### 7. Что такое итератор? В чем разница между itetator и listIterator?

В Java итератор - это объект, который позволяет вам последовательно перебирать элементы коллекции, такие как список, набор или карта, не зная о её внутренней реализации. 

Основные характеристики итератора:
* Доступ: итератор предоставляет доступ к элементам коллекции, но не дает непосредственного доступа к самой коллекции.
* Позиционирование: у итератора есть внутренний указатель, который указывает на текущий элемент коллекции.
* Перемещение: методы итератора позволяют переходить к следующему элементу коллекции.
* Удаление: некоторые итераторы позволяют удалять элементы из коллекции во время итерации.

Методы итератора:
* `hasNext()`: возвращает `true`, если в коллекции есть следующий элемент, иначе `false`.
* `next()`: возвращает следующий элемент в коллекции и перемещает указатель на следующий элемент.
* `remove()`: удаляет последний элемент, возвращенный методом `next()` (не во всех итераторах).

Пример использования:

```java
import java.util.ArrayList;
import java.util.Iterator;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");

        Iterator<String> iterator = list.iterator();

        while (iterator.hasNext()) {
            String fruit = iterator.next();
            System.out.println(fruit);
            // Удаляем элемент из списка во время итерации
            if (fruit.equals("Banana")) {
                iterator.remove();
            }
        }
    }
}
```

Преимущества использования итераторов:
* Универсальность: итераторы работают с различными коллекциями.
* Абстракция: скрывают внутреннюю реализацию коллекции.
* Безопасность: предотвращают модификацию коллекции во время итерации, если это не предусмотрено.
* Гибкость: позволяют выполнять различные действия с элементами коллекции во время итерации.

[_к оглавлению_](#Оглавление)
#### 8. Что такое fail-fast и fail-safe поведение итератора и в чем между ними разница? Когда возникает ConcurrentModificationException?



[_к оглавлению_](#Оглавление)
#### 9. Что такое "коллекция".
[_к оглавлению_](#Оглавление)
#### 10. Назовите базовые интерфейсы коллекций.
[_к оглавлению_](#Оглавление)
#### 11. Расскажите реализации интерфейса List.
[_к оглавлению_](#Оглавление)
#### 12. Расскажите реализации интерфейса Set.
[_к оглавлению_](#Оглавление)
#### 13. Расскажите реализации интерфейса Map.
[_к оглавлению_](#Оглавление)
#### 14. В чем отличие ArrayList от LinkedList?
[_к оглавлению_](#Оглавление)
#### 15. В чем отличие Set от List?
[_к оглавлению_](#Оглавление)
#### 16. Расскажите про методы класса Object hashCode() и equals().

Оба метода являются частью универсального комплекта правил, определенных в классе Object, который является родительским классом для всех объектов в Java. Методы используются для сравнения объектов в Java.

Метод equals() используется для сравнения содержимого двух объектов. По умолчанию, метод equals() сравнивает ссылки объектов, но его можно переопределить в классе, чтобы сравнивать содержимое объектов. Метод equals() должен быть переопределен вместе с методом hashCode(), чтобы обеспечить правильное поведение объектов при использовании в коллекциях, таких как HashMap или HashSet.

Метод hashCode() используется для генерации хеш-кода объекта. Хеш-код - это числовое значение, которое используется для быстрого доступа к объектам в коллекциях. Объекты с одинаковым содержимым должны иметь одинаковый хеш-код, поэтому метод hashCode() также должен быть переопределен вместе с методом equals().

[_к оглавлению_](#Оглавление)
#### 17. Расскажите, что такое коллизии в Map? Как с ними бороться?
[_к оглавлению_](#Оглавление)
#### 18. Расскажите, что такое анализ алгоритма?
[_к оглавлению_](#Оглавление)
#### 19. Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?
[_к оглавлению_](#Оглавление)
#### 20. Расскажите реализации данных очередей и стеков.
[_к оглавлению_](#Оглавление)
#### 21. Расскажите про реализации деревьев.
[_к оглавлению_](#Оглавление)
#### 22. Что такое loadFactor?
[_к оглавлению_](#Оглавление)
#### 23. Перечислите побитовые логические операции, которые Вы знаете. Расскажите, как они работают.
[_к оглавлению_](#Оглавление)
#### 24. Расскажите про операции сдвига. Какие они бывают и что делают?
[_к оглавлению_](#Оглавление)
#### 25. Как хранится знак числа в Java? Как хранятся отрицательные числа?
[_к оглавлению_](#Оглавление)
#### 26. Расскажите о системах сборки проекта. В чем отличие систем сборки Ant, Maven и Gradle?
[_к оглавлению_](#Оглавление)
#### 27. Как создать maven проект?
[_к оглавлению_](#Оглавление)
#### 28. Какова структура maven проекта?
[_к оглавлению_](#Оглавление)
#### 29. Расскажите о файле pom.xml. Как он структурирован и за что отвечает содержание каждой части?
[_к оглавлению_](#Оглавление)
#### 30. Что такое координаты зависимости?
[_к оглавлению_](#Оглавление)
#### 31. Что такое транзитивные зависимости?
[_к оглавлению_](#Оглавление)
#### 32. Что такое область видимости зависимости? Сколько областей видимости предусмотрено и где они применяются?
[_к оглавлению_](#Оглавление)
#### 33. Расскажите о жизненном цикле maven. В какой последовательности выполняются фазы цикла и что происходит на каждой фазе сборки?
[_к оглавлению_](#Оглавление)
