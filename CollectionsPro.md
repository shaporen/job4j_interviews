##### [job4j_interviews](https://github.com/shaporen/job4j_interviews/blob/main/README.md)
#### Оглавление
+ [1. Что такое generics?](#1-Что-такое-generics)
+ [2. Что такое wild cards?](#2-Что-такое-wild-cards)
+ [3. Что такое bounded wild cards?](#3-Что-такое-bounded-wild-cards)
+ [4. Что такое unbounded wild cards?](#4-Что-такое-unbounded-wild-cards)
+ [5. Где хранится информация про generics?](#5-Где-хранится-информация-про-generics)
+ [6. Как можно получить тип generics?](#6-Как-можно-получить-тип-generics)
+ [7. Что такое итератор? В чем разница между itetator и listIterator?](#7-Что-такое-итератор-В-чем-разница-между-itetator-и-listIterator)
+ [8. Что такое fail-fast и fail-safe поведение итератора и в чем между ними разница? Когда возникает ConcurrentModificationException?](#8-Что-такое-fail-fast-и-fail-safe-поведение-итератора-и-в-чем-между-ними-разница-Когда-возникает-ConcurrentModificationException)
+ [9. Что такое "коллекция".](#9-Что-такое-коллекция)
+ [10. Назовите базовые интерфейсы коллекций.](#10-Назовите-базовые-интерфейсы-коллекций)
+ [11. Расскажите реализации интерфейса List.](#11-Расскажите-реализации-интерфейса-List)
+ [12. Расскажите реализации интерфейса Set.](#12-Расскажите-реализации-интерфейса-Set)
+ [13. Расскажите реализации интерфейса Map.](#13-Расскажите-реализации-интерфейса-Map)
+ [14. В чем отличие ArrayList от LinkedList?](#14-В-чем-отличие-ArrayList-от-LinkedList)
+ [15. В чем отличие Set от List?](#15-В-чем-отличие-Set-от-List)
+ [16. Расскажите про методы класса Object hashCode() и equals().](#16-Расскажите-про-методы-класса-Object-hashCode-и-equals)
+ [17. Расскажите, что такое коллизии в Map? Как с ними бороться?](#17-Расскажите-что-такое-коллизии-в-Map-Как-с-ними-бороться)
+ [18. Расскажите, что такое анализ алгоритма?](#18-Расскажите-что-такое-анализ-алгоритма)
+ [19. Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?](#19-Какая-временная-сложность-алгоритмов(O-нотация)-добавления-замены-и-удаления-в-каждой-из-коллекций-С-чем-связаны-отличия)
+ [20. Расскажите реализации данных очередей и стеков.](#20-Расскажите-реализации-данных-очередей-и-стеков)
+ [21. Расскажите про реализации деревьев.](#21-Расскажите-про-реализации-деревьев)
+ [22. Что такое loadFactor?](#22-Что-такое-loadFactor)
+ [23. Перечислите побитовые логические операции, которые Вы знаете. Расскажите, как они работают.](#23-Перечислите-побитовые-логические-операции-которые-Вы-знаете-Расскажите-как-они-работают)
+ [24. Расскажите про операции сдвига. Какие они бывают и что делают?](#24-Расскажите-про-операции-сдвига-Какие-они-бывают-и-что-делают)
+ [25. Как хранится знак числа в Java? Как хранятся отрицательные числа?](#25-Как-хранится-знак-числа-в-Java-Как-хранятся-отрицательные-числа)
+ [26. Расскажите о системах сборки проекта. В чем отличие систем сборки Ant, Maven и Gradle?](#26-Расскажите-о-системах-сборки-проекта-В-чем-отличие-систем-сборки-Ant-Maven-и-Gradle)
+ [27. Как создать maven проект?](#27-Как-создать-maven-проект)
+ [28. Какова структура maven проекта?](#28-Какова-структура-maven-проекта)
+ [29. Расскажите о файле pom.xml. Как он структурирован и за что отвечает содержание каждой части?](#29-Расскажите-о-файле-pomxml-Как-он-структурирован-и-за-что-отвечает-содержание-каждой-части)
+ [30. Что такое координаты зависимости?](#30-Что-такое-координаты-зависимости)
+ [31. Что такое транзитивные зависимости?](#31-Что-такое-транзитивные-зависимости)
+ [32. Что такое область видимости зависимости? Сколько областей видимости предусмотрено и где они применяются?](#32-Что-такое-область-видимости-зависимости-Сколько-областей-видимости-предусмотрено-и-где-они-применяются)
+ [33. Расскажите о жизненном цикле maven. В какой последовательности выполняются фазы цикла и что происходит на каждой фазе сборки?](#33-Расскажите-о-жизненном-цикле-maven-В-какой-последовательности-выполняются-фазы-цикла-и-что-происходит-на-каждой-фазе-сборки)

#### 1. Что такое generics?

Generics в Java - это механизм, позволяющий создавать типы данных, которые могут работать с различными типами данных.

Generics позволяют типам (классам и интерфейсам) быть параметрами при определении классов, интерфейсов и методов. Параметры типа предоставляют возможность повторно использовать один и тот же код с разными входами наподобие формальных параметров в объявлениях методов. Разница в том, что входные данные для формальных параметров являются значениями, а для дженериков - типами данных. Переменная типа может быть любым не примитивным типом.

В Java generics добавили для реализации обобщенных коллекций, безопасных с точки зрения типов. Ошибка компиляции - это лучше, чем исключение ClassCastException в связи с неправильным приведением типов во время выполнения. После компиляции какая-либо информация о дженериках стирается. Это называется "Стирание типов". Также дженерики делают исходный код программы более удобочитаемым.

Преимущества generics:
+ Безопасность типов: Generics предотвращают ошибки времени выполнения, связанные с использованием неверных типов данных. 
+ Улучшенная читаемость: код становится более читаемым и понятным, так как типы данных явно указываются.
+ Повторное использование кода: Generics позволяют создавать обобщенные классы и методы, которые можно использовать для различных типов данных.
+ Уменьшение дублирования кода: с помощью generics можно избежать написания повторяющегося кода для разных типов данных.

Основные концепции generics:
+ Тип-параметр: это placeholder для типа данных, который будет использоваться в классе или методе. Обозначается угловыми скобками (<>), например: `<T>`.
+ Тип-аргумент: фактический тип данных, который передается в качестве аргумента при создании объекта generic-класса или при вызове generic-метода.
+ Ограничения типа: возможность ограничить тип-параметр определенным типом или интерфейсом. 

Примеры использования generics:

Generic-классы:

```java
class Box<T> {
  private T item;

  public Box(T item) {
    this.item = item;
  }

  public T getItem() {
    return item;
  }
}

Box<String> stringBox = new Box<>("Hello");
Box<Integer> intBox = new Box<>(10);
```

Generic-методы:

```java
public static <T> T findFirst(List<T> list) {
  // ...
}

List<String> stringList = new ArrayList<>();
String firstString = findFirst(stringList);
```

Преимущества использования generics:
+ Улучшение безопасности типов.
+ Повышение читаемости кода.
+ Повторное использование кода.
+ Уменьшение дублирования кода.

Важно отметить, что generics - это compile-time mechanism, а не runtime mechanism. Это означает, что типы данных проверяются во время компиляции, а не во время выполнения.

[_к оглавлению_](#Оглавление)
#### 2. Что такое wild cards?

В Java, "wildcards" - это специальные символы, используемые для представления неизвестных типов в дженериках. Они позволяют писать более гибкий и универсальный код, особенно когда вы работаете с коллекциями.

Основные типы wildcards:
* `?` (Unbounded Wildcard): представляет любой тип. Используется, когда конкретный тип не важен.
* `? extends T` (Upper Bounded Wildcard): представляет любой тип, который является подтипом `T` (или `T` сам по себе).
* `? super T` (Lower Bounded Wildcard): представляет любой тип, который является супертипом `T` (или `T` сам по себе).

Пример:

```java
List<String> strings = new ArrayList<>();
List<?> anyList = strings; // Unbounded wildcard, может содержать любые типы
```

В этом примере `anyList` может содержать список любого типа. Однако, вы не можете добавить элементы в `anyList`, потому что компилятор не знает, какой тип элементов в нем хранится.

Использование wildcards:
* Универсальные методы: Wildcards используются для написания методов, которые могут работать с коллекциями различных типов.
* Создание неизменяемых коллекций: Wildcards могут использоваться для создания коллекций, которые можно только читать, но не изменять.
* Улучшение читаемости кода: Wildcards делают код более ясным, показывая, какие типы допустимы для конкретной переменной или метода.

Важно помнить:
* Wildcards не изменяют тип коллекции. Они просто предоставляют более гибкий способ работы с коллекциями различных типов.
* Использование `? extends T` позволяет добавлять элементы типа `T` или его подтипов.
* Использование `? super T` позволяет добавлять элементы типа `T` или его супертипов.

Примеры использования:

 Метод, который принимает коллекцию любого типа:

```java
public static void printElements(Collection<?> collection) {
  for (Object element : collection) {
    System.out.println(element);
  }
}
```

 Метод, который принимает список подтипов String:

```java
public static void printStrings(List<? extends String> stringList) {
  for (String string : stringList) {
    System.out.println(string);
  }
}
```

 Метод, который принимает список супертипов Number:

```java
public static void sumNumbers(List<? super Number> numberList) {
  int sum = 0;
  for (Number number : numberList) {
    sum += number.intValue();
  }
  System.out.println(sum);
}
```

[_к оглавлению_](#Оглавление)
#### 3. Что такое bounded wild cards?

Bounded wildcards — это способ ограничения типа в Generic Type параметрах. Они позволяют работать с подтипами (extends) или надтипами (super) заданного типа, но не с любым типом.

Примеры:

 `<? extends Number>`:  эта wildcard принимает как аргумент любые классы, являющиеся подтипами `Number`, например `Integer`, `Double`, `Float` и т.д.
 `<? super Integer>`: эта wildcard принимает как аргумент любые классы, являющиеся надтипами `Integer`, например `Number`, `Object`, `Comparable` и т.д.

Зачем нужны bounded wildcards:

* Повышение безопасности: bounded wildcards позволяют гарантировать, что операции с Generic-типами будут выполняться только с допустимыми типами.
* Улучшение читаемости кода:  они позволяют четко определить ограничения на типы в Generic-классах и методах, что делает код более понятным.
* Снижение количества ошибок:  bounded wildcards помогают избежать ошибок времени компиляции, связанных с использованием неподходящих типов.

Пример использования:

```java
// Класс для хранения списка чисел
class NumberList<T extends Number> {
    private List<T> numbers;

    public NumberList(List<T> numbers) {
        this.numbers = numbers;
    }

    // Метод для суммирования чисел в списке
    public double sum() {
        double sum = 0;
        for (T number : numbers) {
            sum += number.doubleValue();
        }
        return sum;
    }
}

// Использование bounded wildcard для создания списка чисел
List<Integer> integers = Arrays.asList(1, 2, 3);
NumberList<? extends Number> numberList = new NumberList<>(integers);

// Вызов метода sum()
double sum = numberList.sum();

// Неверно: невозможно добавить число в список
// numberList.add(4); // Ошибка компиляции
```

В этом примере:
* `NumberList` принимает как аргумент тип `T`, который должен быть подтипом `Number`.
* `numberList` — список, который может содержать только числа, поэтому используется `? extends Number`.
* Метод `sum()` работает со всеми типами чисел в списке, поскольку они наследуются от `Number`.
* Добавление нового числа в список `numberList` невозможно, так как `? extends Number` не гарантирует, что список принимает конкретный тип числа.

Важно:
* Wildcards всегда используются в контексте generic-типов.
* `? extends T` — для ограничений на подтипы.
* `? super T` — для ограничений на надтипы.
* `?` — неограниченная wildcard, которая может принимать любой тип.

[_к оглавлению_](#Оглавление)
#### 4. Что такое unbounded wild cards?

В Java, неограниченные подстановочные знаки (`?`) используются для представления любого типа. Они могут применяться в различных контекстах, таких как:

***1. Параметры типов:***

 В качестве типа аргумента для обобщенных методов и классов:
    ```java
    public static <T> void printList(List<?> list) {
        for (Object obj : list) {
            System.out.println(obj);
        }
    }
    ```

В данном случае `printList` принимает список любого типа (`List<?>`).  Это означает, что можно передать список `Integer`, `String`, `Double` или любого другого типа. Однако, поскольку тип неизвестен, вы можете вызывать только методы, доступные для `Object` (например, `toString()`, `equals()`).

***2. В качестве типа возвращаемого значения:***

 В методах, возвращающих коллекцию любого типа:
    ```java
    public static List<?> getAnyList() {
        return new ArrayList<String>();
    }
    ```

В этом случае метод `getAnyList` возвращает список, который может содержать элементы любого типа. Однако, тип возвращаемого списка не может быть точно определен.

***3. В качестве типа переменной:***

Для хранения значений любого типа:
    ```java
    List<?> anyList = new ArrayList<String>();
    ```

В данном случае переменная `anyList` может хранить список любого типа. Однако, как и в случае с параметрами типов, вы можете вызывать только методы, доступные для `Object`.

Ограничения неограниченных подстановочных знаков:

* Ограниченная функциональность: неограниченные подстановочные знаки предоставляют ограниченную функциональность, так как вы не можете добавлять элементы в коллекции `<?>`, кроме `null`, и вы не можете вызывать методы, требующие конкретного типа.
* Риск несовместимости: использование неограниченных подстановочных знаков может привести к несовместимости типов во время компиляции или во время выполнения.

Вместо неограниченных подстановочных знаков, рекомендуется использовать ограниченные подстановочные знаки (`<? extends T>` или `<? super T>`) для повышения безопасности типов и функциональности.

Пример ограниченных подстановочных знаков:

```java
public static <T> void printList(List<? extends T> list) {
    for (T obj : list) {
        System.out.println(obj);
    }
}
```

В этом случае `printList` принимает список, который содержит элементы типа `T` или его подтипов. Это позволяет вызывать методы, доступные для `T`, но не добавлять элементы в список, если вы не уверены, что они являются `T` или его подтипами.

[_к оглавлению_](#Оглавление)
#### 5. Где хранится информация про generics?

Информация о Generics хранится в исходном коде до этапа компиляции. Во время компиляции компилятор Java удаляет информацию о Generics из скомпилированного кода в процессе, который называется стиранием типов (type erasure). Информация о Generics используется компилятором для проверки типов во время компиляции и для генерации предупреждений или ошибок, связанных с типами данных. Однако в скомпилированном байт-коде Java информация о Generics удаляется, и все обобщенные типы преобразуются в их необобщенные версии.

[_к оглавлению_](#Оглавление)
#### 6. Как можно получить тип generics?

В Java нет прямого способа получить тип generic непосредственно, но есть несколько способов получить информацию о нем:

- ***1. Использование `Class#getGenericSuperclass()` и `Class#getGenericInterfaces()`:***

Эти методы возвращают `Type` объект, представляющий обобщенный суперкласс или интерфейс. Вы можете использовать `ParameterizedType` и `TypeVariable` для извлечения информации о типах.

```java
class MyClass<T> {
    public static void main(String[] args) {
        Type superclass = MyClass.class.getGenericSuperclass();
        if (superclass instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) superclass;
            Type[] typeArguments = parameterizedType.getActualTypeArguments();
            System.out.println("Тип параметра: " + typeArguments[0]); // Вывод: T
        }
    }
}
```

- ***2. Использование `Method#getGenericParameterTypes()`:***

Этот метод возвращает массив `Type` объектов, представляющих типы параметров метода. Это полезно для получения информации о типах параметров обобщенных методов.

```java
class MyClass<T> {
    public <E> void myMethod(E e) {
        Type[] parameterTypes = MyClass.class.getMethod("myMethod", Object.class).getGenericParameterTypes();
        System.out.println("Тип параметра: " + parameterTypes[0]); // Вывод: E
    }
}
```

- ***3. Использование рефлексии:***

Вы можете использовать рефлексию для получения информации о типах generic. Например, вы можете получить `Field#getGenericType()` для получения типа generic поля.

```java
class MyClass<T> {
    private T myField;

    public static void main(String[] args) throws NoSuchFieldException {
        Field field = MyClass.class.getDeclaredField("myField");
        Type genericType = field.getGenericType();
        if (genericType instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) genericType;
            Type[] typeArguments = parameterizedType.getActualTypeArguments();
            System.out.println("Тип параметра: " + typeArguments[0]); // Вывод: T
        }
    }
}
```

- ***4. Использование аннотаций:***

Вы можете использовать аннотации для передачи информации о типах generic. Например, вы можете использовать аннотации `@TypeParameter` и `@TypeVariable` для аннотирования типов параметров и переменных типов.

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE_PARAMETER)
public @interface TypeParameter {
    Class<?> type();
}

class MyClass<@TypeParameter(type = String.class) T> {
    public static void main(String[] args) {
        TypeVariable<?>[] typeVariables = MyClass.class.getTypeParameters();
        for (TypeVariable<?> typeVariable : typeVariables) {
            TypeParameter typeParameter = typeVariable.getAnnotation(TypeParameter.class);
            if (typeParameter != null) {
                System.out.println("Тип параметра: " + typeParameter.type()); // Вывод: class java.lang.String
            }
        }
    }
}
```

Важно:
* Получение информации о типах generic не всегда просто, и может потребовать глубокого понимания рефлексии и API типов Java.
* В некоторых случаях вы можете получить информацию о типах generic только во время выполнения, а не во время компиляции.
* Будьте осторожны с использованием рефлексии, так как она может быть медленной и сложной.

[_к оглавлению_](#Оглавление)
#### 7. Что такое итератор? В чем разница между itetator и listIterator?

В Java итератор - это объект, который позволяет вам последовательно перебирать элементы коллекции, такие как список, набор или карта, не зная о её внутренней реализации. 

Основные характеристики итератора:
* Доступ: итератор предоставляет доступ к элементам коллекции, но не дает непосредственного доступа к самой коллекции.
* Позиционирование: у итератора есть внутренний указатель, который указывает на текущий элемент коллекции.
* Перемещение: методы итератора позволяют переходить к следующему элементу коллекции.
* Удаление: некоторые итераторы позволяют удалять элементы из коллекции во время итерации.

Методы итератора:
* `hasNext()`: возвращает `true`, если в коллекции есть следующий элемент, иначе `false`.
* `next()`: возвращает следующий элемент в коллекции и перемещает указатель на следующий элемент.
* `remove()`: удаляет последний элемент, возвращенный методом `next()` (не во всех итераторах).

Пример использования:

```java
import java.util.ArrayList;
import java.util.Iterator;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");

        Iterator<String> iterator = list.iterator();

        while (iterator.hasNext()) {
            String fruit = iterator.next();
            System.out.println(fruit);
            // Удаляем элемент из списка во время итерации
            if (fruit.equals("Banana")) {
                iterator.remove();
            }
        }
    }
}
```

Преимущества использования итераторов:
* Универсальность: итераторы работают с различными коллекциями.
* Абстракция: скрывают внутреннюю реализацию коллекции.
* Безопасность: предотвращают модификацию коллекции во время итерации, если это не предусмотрено.
* Гибкость: позволяют выполнять различные действия с элементами коллекции во время итерации.

***Интерфейс ListIterator.***

Особенности:
* Расширение интерфейса Iterator, предоставляет дополнительные методы для навигации по списку (реализации интерфейса List) в обоих направлениях.
* Позволяет добавлять, изменять и удалять элементы в списке во время итерации.

Дополнительные методы:
* boolean hasPrevious(): Проверяет наличие предыдущего элемента.
* E previous(): Возвращает предыдущий элемент.
* int nextIndex(): Возвращает индекс следующего элемента.
* int previousIndex(): Возвращает индекс предыдущего элемента.
* void add(E e): Добавляет элемент перед текущим элементом.
* void set(E e): Заменяет текущий элемент на указанный элемент.

***Различия между Iterator и ListIterator:***

Направление итерации:
* Iterator: Позволяет итерировать только в одном направлении (вперед).
* ListIterator: Позволяет итерировать по списку как вперед, так и назад.
  
Методы навигации:
* ListIterator предоставляет дополнительные методы для навигации по списку: hasPrevious(), previous(), nextIndex(), previousIndex().
  
Модификация списка:
* ListIterator позволяет добавлять, изменять и удалять элементы в списке во время итерации с помощью методов add(), set().
  
Поддержка коллекций:
* ListIterator применяется только к коллекциям, реализующим интерфейс List, поддерживающим упорядоченный доступ по индексу.

Iterator используется для простого однонаправленного обхода коллекции и методов hasNext(), next(), remove(), а ListIterator - для более сложных сценариев, где требуется двунаправленный доступ и возможность модификации списка в процессе итерации.


[_к оглавлению_](#Оглавление)
#### 8. Что такое fail-fast и fail-safe поведение итератора и в чем между ними разница? Когда возникает ConcurrentModificationException?

***Fail-fast итераторы*** — это итераторы, которые стремятся обнаружить и бросить исключение `ConcurrentModificationException`, если во время итерации по коллекции кто-то другой ее модифицирует. `ArrayList`

***Fail-safe итераторы*** — это итераторы, которые создают копию исходной коллекции, чтобы избежать проблем с параллельными модификациями. Вместо того, чтобы бросать исключение, они просто работают с копией и не отражают изменения, внесенные в оригинальную коллекцию. `CopyOnWriteArrayList`

Примеры:

Fail-fast:

```java
ArrayList<String> list = new ArrayList<>();
list.add("A");
list.add("B");

Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
  String element = iterator.next();
  if (element.equals("B")) {
    list.remove(element); // Вызовет ConcurrentModificationException
  }
}
```

Fail-safe:

```java
CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
list.add("A");
list.add("B");

Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
  String element = iterator.next();
  if (element.equals("B")) {
    list.remove(element); // Не вызовет ConcurrentModificationException, так как работает с копией
  }
}
```

Важно знать:
* Fail-fast итераторы не гарантируют обнаружение всех модификаций. Если модификации происходят из разных потоков, то исключение может не быть брошено.
* Fail-safe итераторы могут быть медленнее, чем fail-fast итераторы, из-за создания копии.
* Выбор типа итератора зависит от конкретного сценария использования. Если вам нужна высокая скорость и безопасность от некорректного использования, то выбирайте fail-fast. Если вам нужна безопасность потоков, то выбирайте fail-safe.

Дополнительные моменты:
* Fail-fast поведение может быть отключено с помощью `java.util.concurrent.ConcurrentModificationException.suppress` system property.
* Fail-safe итераторы не изменяют исходную коллекцию.

В заключение:

Используйте fail-fast итераторы, если уверены, что коллекция не будет модифицироваться во время итерации. Используйте fail-safe итераторы, если нужно гарантировать безопасность потоков и стабильность итерации.

Вот несколько причин возникновения ConcurrentModificationException:
* Попытка добавить, удалить или изменить элементы коллекции напрямую без использования итератора во время итерации.
* Изменения, сделанные другим потоком, влияющие на структуру коллекции во время итерации в одном потоке.
* При использовании foreach цикла для итерации по коллекции, изменение коллекции внутри цикла может вызвать исключение.

Как избежать ConcurrentModificationException:
* Используйте итератор для изменения коллекции - для безопасного добавления, удаления или изменения элементов в коллекции во время итерации используйте итератор.
* Синхронизируйте доступ к коллекции - при многопоточном доступе к коллекции управляйте доступом с помощью синхронизации.
* Воспользуйтесь CopyOnWrite коллекциями - использование специальных классов, таких как CopyOnWriteArrayList, для безопасного итерирования и модификации коллекции.

[_к оглавлению_](#Оглавление)
#### 9. Что такое "коллекция".

Коллекции - это хранилища, поддерживающие различные способы накопления и упорядочивания объектов с целью обеспечения эффективного доступа к ним.

Они представляют собой реализации абстрактных структур данных, поддерживающих различные способы хранения данных, а также операции добавления, удаления и изменения элементов. Т.е. это набор интерфейсов и реализующих их классов.

[_к оглавлению_](#Оглавление)
#### 10. Назовите базовые интерфейсы коллекций.

* List - список.
* Set - множество
* Queue - очередь
* Map - пара "ключ - значение"

[_к оглавлению_](#Оглавление)
#### 11. Расскажите реализации интерфейса List.

**Реализации List:**
+ ***ArrayList*** - это список, который реализован как массив. Это означает, что элементы в ArrayList хранятся в последовательном порядке и могут быть доступны по индексу. Основные характеристики ArrayList включают динамическое увеличение размера, высокую производительность при доступе к элементам по индексу и возможность изменения элементов. Применяется, когда в процессе работы предполагается частое обращение к элементам по индексу. Следует избегать, если предполагается частое добавление/удаление элементов в середину списка. Позволяет хранить любые значения, в том числе null. Не потокобезопасен.
+ ***LinkedList*** - это двусвязный список (можно использовать как стэк или очередь), в котором каждый элемент содержит ссылки на предыдущий и следующий элементы. Это означает, что вставка и удаление элементов в середине списка выполняются быстрее, чем в ArrayList. Однако доступ к элементам по индексу в LinkedList более медленный. Позволяет хранить любые значения, в том числе null. Не потокобезопасен.
+ ***Vector*** - похож на ArrayList. Синхронизирован. Содержит много устаревших методов, которые не являются частью структуры коллекций. Не рекомендуется использовать, если не требуется потокобезопасность.
+ ***Stack*** - это реализация стека, который представляет собой упорядоченный список элементов, где добавление и удаление элементов происходит в конце списка (LIFO - last in, first out). После добавления интерфейса Queue не рекомендуется к использованию.
+ ***CopyOnWriteArrayList*** - реализация, обеспечивающая безопасный итератор при изменении списка. Итератор работает с копией списка на момент создания итератора.
+ ***ImmutableList*** - реализация неизменяемого списка, доступная в сторонних библиотеках, таких как Guava. Не позволяет изменять содержимое списка после создания.

Все эти коллекции реализуют интерфейс List, что означает, что они поддерживают операции добавления, удаления и доступа к элементам по индексу.

[_к оглавлению_](#Оглавление)
#### 12. Расскажите реализации интерфейса Set.

**Реализации Set:**
+ ***HashSet*** - это наиболее распространенная реализация Set, основанная на хэш-таблице (что позволяет постоянство по времени на поиск, удаление и добавление элементов). Он не гарантирует порядок элементов при их добавлении. Не допускает дубликатов. Хранит только объекты (примитивы заворачивает в обертки). Не потокобезопасен.
+ ***LinkedHashSet*** - это реализация Set, которая поддерживает порядок элементов в том порядке, в котором они были добавлены (именно порядок вставки, а не значения элементов). Как и HashSet, она не допускает дублирования элементов. Постоянное время добавления, поиска и удаления элементов. Не потокобезопасен.
+ ***TreeSet*** - это реализация Set, которая хранит элементы в отсортированном порядке. Он использует красно-черное дерево для хранения элементов и гарантирует, что они будут отсортированы в естественном порядке (например, числа в возрастающем порядке, строки в алфавитном порядке). Не работает с null и non-comparable элементами. По умолчанию сортировка по принципу naturalOrder. Порядок сортировки задается c использованием Comparator.
+ ***EnumSet*** - реализация Set специально предназначенная для хранения элементов enum (перечислений в Java). Оптимизирована для хранения и манипуляции с элементами enum.
+ ***ConcurrentSkipListSet*** - реализация Set на основе сбалансированного дерева SkipList. Поддерживает высокую параллельность и обладает хорошей производительностью в многопоточной среде.
+ ***CopyOnWriteArraySet*** - реализация Set, обеспечивающая безопасное чтение и модификацию элементов в многопоточной среде. Копирует массив при изменениях, обеспечивая потокобезопасность.

[_к оглавлению_](#Оглавление)
#### 13. Расскажите реализации интерфейса Map.

**Реализации Map:**
+ ***HashMap*** - основанный на хэш-таблице класс, который обеспечивает постоянное время выполнения операций добавления, удаления и поиска элементов. Однако порядок элементов в HashMap не определен. При попытке вставить элемент по уже имеющемуся ключу - заменит значение на новое. Допускает значение ключа null. Не потокобезопасен. Содержит только уникальные ключи.
+ ***LinkedHashMap*** - класс, который расширяет HashMap и хранит элементы в порядке их вставки. Поиск элементов в LinkedHashMap происходит чуть медленнее, чем в HashMap, но можно обеспечить итерацию элементов в порядке, в котором они были добавлены. Не потокобезопасен.
+ ***TreeMap*** - класс, основанный на структуре красно-черного дерева, который хранит элементы в отсортированном порядке по ключу. По умолчанию сортировка по принципу naturalOrder. Порядок сортировки задается c использованием Comparator. Поиск элементов в TreeMap выполняется за время log(n).
+ ***ConcurrentHashMap*** - класс, аналогичный HashMap, но с многопоточной поддержкой. Он обеспечивает безопасную работу с коллекцией в многопоточной среде.
+ ***EnumMap*** - реализация Map для хранения элементов типа enum (перечисления в Java). Оптимизирована для работы с элементами enum.
+ ***ConcurrentHashMap*** - реализация Map, обеспечивающая потокобезопасное чтение и модификацию в многопоточной среде. Позволяет параллельный доступ и модификацию без блокировок.
+ ***WeakHashMap*** - реализация Map, где ключи являются "слабыми" ссылками, то есть могут быть удалены сборщиком мусора, если на них нет прямых ссылок.

[_к оглавлению_](#Оглавление)
#### 14. В чем отличие ArrayList от LinkedList?

**1) Структура данных:**
+ ArrayList - реализован на динамическом массиве.
+ LinkedList - двусвязный список.

**2) Вставка и удаление элементов**
+ ArrayList - медленная, так как при этом может потребоваться перемещение всех элементов после вставленного или удаленного элемента.
+ LinkedList - быстрее, так как достаточно изменить ссылки на предыдущий и следующий элементы, не требуя перемещения всех элементов.

**3) Итерация по элементам:**
+ При итерации по элементам ArrayList быстрее, так как доступ к элементам по индексу работает быстро.
+ При итерации по элементам LinkedList может быть медленнее из-за линейной сложности доступа к элементам.

**4) Использование памяти:**
+ ArrayList требует больше памяти, так как он выделяет фиксированный кусок памяти для хранения элементов, который может быть увеличен, если размер структуры данных увеличивается.
+ LinkedList требует меньше памяти, так как каждый элемент хранит ссылки только на предыдущий и следующий элементы.

**5) Применение:**
+ ArrayList - для быстрого доступа по индексу в малоизменяемых списках.
+ LinkedList - для частых вставок и удалений элементов и малом числе поиска элементов.

[_к оглавлению_](#Оглавление)
#### 15. В чем отличие Set от List?

Уникальность элементов:
- List: позволяет хранить дублирующиеся элементы.
- Set: хранит только уникальные элементы, не допуская повторений.

Порядок элементов:
- List: сохраняет порядок вставки элементов, позволяет получить элементы по индексу.
- Set: не гарантирует порядок элементов внутри коллекции (за исключением некоторых реализаций, например, LinkedHashSet).

Сравнение и поиск:
- List: позволяет выполнять поиск элементов по индексу, используя метод get(index).
- Set: предоставляет методы для проверки наличия элемента и его удаления, но не позволяет получить элемент по индексу.

Использование в качестве ключей в коллекциях:
- List: не так часто используется в качестве ключей в Map, так как ключи обычно должны быть уникальными.
- Set: хорошо подходит в качестве ключей в Map из-за гарантированной уникальности элементов.

Подход к использованию:
- List: используется для хранения упорядоченных коллекций, когда нужно иметь доступ к элементам по индексу.
- Set: применяется, когда нужно хранить уникальные элементы или проверять принадлежность элемента к множеству.

[_к оглавлению_](#Оглавление)
#### 16. Расскажите про методы класса Object hashCode() и equals().

Оба метода являются частью универсального комплекта правил, определенных в классе Object, который является родительским классом для всех объектов в Java. Методы используются для сравнения объектов в Java.

Метод equals() используется для сравнения содержимого двух объектов. По умолчанию, метод equals() сравнивает ссылки объектов, но его можно переопределить в классе, чтобы сравнивать содержимое объектов. Метод equals() должен быть переопределен вместе с методом hashCode(), чтобы обеспечить правильное поведение объектов при использовании в коллекциях, таких как HashMap или HashSet.

Метод hashCode() используется для генерации хеш-кода объекта. Хеш-код - это числовое значение, которое используется для быстрого доступа к объектам в коллекциях. Объекты с одинаковым содержимым должны иметь одинаковый хеш-код, поэтому метод hashCode() также должен быть переопределен вместе с методом equals().

[_к оглавлению_](#Оглавление)
#### 17. Расскажите, что такое коллизии в Map? Как с ними бороться?

Коллизия - это ситуация, когда два или более ключа в `HashMap` хэшируются в один и тот же индекс. Это может произойти, потому что алгоритм хэширования не идеален и может создавать одинаковые хэш-коды для разных ключей.

Пример:

```java
Map<String, Integer> map = new HashMap<>();
map.put("apple", 1);
map.put("appl", 2); // Коллизия, т.к. "apple" и "appl" имеют одинаковый хэш-код
```

Как с ними бороться:

1. Использование качественной функции хэширования: 
    - Java предоставляет `HashMap` с хорошей функцией хэширования по умолчанию. 
    - Однако, если вы используете собственные ключи, важно обеспечить качественную реализацию метода `hashCode()`. 
    - Хорошая функция хэширования должна:
        - Быстро выполняться.
        - Предоставлять равномерное распределение хэш-кодов.
        - Минимизировать коллизии.

2. Применение алгоритмов разрешения коллизий:

    - Цепочный метод: 
        - Каждый индекс в `HashMap` хранит список всех ключей, которые хэшируются в этот индекс. 
        - Для поиска значения по ключу необходимо пройти по списку и сравнить ключи. 
        - Этот метод прост в реализации, но может быть медленным при большом количестве коллизий.

    - Открытая адресация:
        - При коллизии алгоритм пытается найти следующий свободный индекс, используя заданную функцию поиска.
        - Этот метод может быть быстрее, но может привести к проблемам, если `HashMap` почти заполнен.

3. Использование `LinkedHashMap`: 
    - `LinkedHashMap` - это подкласс `HashMap`, который также сохраняет порядок вставки элементов.
    - Он полезен, если вы хотите получить доступ к элементам в порядке их вставки.

4. Использование `TreeMap`:
    - `TreeMap` - это подкласс `Map`, который хранит ключи в отсортированном порядке.
    - Он использует древовидную структуру данных для хранения ключей и значений. 
    - `TreeMap` не страдает от коллизий, но может быть медленнее при добавлении или удалении элементов.

Важно отметить, что коллизии неизбежны, но их можно минимизировать.

Рекомендации:

- Используйте стандартную функцию хэширования Java, если возможно.
- Если вы создаете свои ключи, реализуйте метод `hashCode()` таким образом, чтобы он генерировал равномерное распределение хэш-кодов.
- Используйте `LinkedHashMap` или `TreeMap`, если вам нужно сохранять порядок элементов или использовать структуру данных, устойчивую к коллизиям.

[_к оглавлению_](#Оглавление)
#### 18. Расскажите, что такое анализ алгоритма?

Анализ алгоритма – это процесс изучения эффективности алгоритма, чтобы понять, как он работает с точки зрения ресурсов.  Он отвечает на вопросы:
* Сколько времени алгоритм занимает для выполнения?  Это называется временной сложностью.
* Сколько памяти алгоритм использует? Это называется пространственной сложностью.

Понимание временной и пространственной сложности алгоритма помогает:
* Сравнивать разные алгоритмы для решения одной задачи и выбирать наиболее эффективный.
* Оптимизировать существующий алгоритм, чтобы он работал быстрее или с меньшими затратами памяти.
* Предсказывать, как алгоритм будет работать с большими наборами данных.

***Как анализируют алгоритмы?***

Аналитики используют асимптотическую нотацию, чтобы описать временную и пространственную сложность алгоритма. 

Основные нотации:
* O(1) - постоянное время:  время выполнения не зависит от размера входных данных.
* O(n) - линейное время: время выполнения линейно зависит от размера входных данных.
* O(log n) - логарифмическое время: время выполнения растет гораздо медленнее, чем размер входных данных.
* O(n log n) - логарифмически-линейное время: время выполнения растет быстрее, чем логарифмическое, но медленнее, чем линейное.
* O(n^2) - квадратичное время: время выполнения растет пропорционально квадрату размера входных данных.
* O(2^n) - экспоненциальное время: время выполнения растет очень быстро с увеличением размера входных данных.

Примеры:
* Поиск элемента в массиве: O(n) - алгоритм должен проверить каждый элемент, чтобы найти нужный.
* Сортировка массива методом пузырька: O(n^2) - алгоритм проходит по массиву несколько раз, сравнивая элементы.
   Двоичный поиск в отсортированном массиве: O(log n) - алгоритм делит массив на половину на каждом шаге.

Важно отметить:
* Анализ алгоритма не всегда точный, но он дает хорошее представление о том, как алгоритм будет работать.
* Реальные алгоритмы часто имеют более сложную временную и пространственную сложность, чем те, которые мы описываем с помощью асимптотической нотации.

[_к оглавлению_](#Оглавление)
#### 19. Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?

![img](https://github.com/shaporen/job4j_interviews/blob/main/resources/O%20notation.png)

Объяснение отличий:
* ArrayList: В худшем случае, если нужно вставить/удалить элемент в начале списка, нужно сдвинуть все последующие элементы, что дает сложность O(n).
* LinkedList: Операции вставки/удаления O(1), так как элементы связаны ссылками, и доступ к ним осуществляется через эти ссылки.
* HashSet/HashMap: Используют хэш-функции для определения позиции элемента в таблице. В большинстве случаев операции выполняются за O(1).  В худшем случае, когда все элементы имеют одинаковые хэш-коды, сложность возрастает до O(n). 
* TreeSet/TreeMap:  Используют бинарное дерево поиска, что обеспечивает логарифмическую сложность для поиска, вставки и удаления элементов.

Важно:
* Сложность операций зависит от реализации коллекций.
* В некоторых случаях, например, при добавлении элемента в конец ArrayList, сложность будет O(1), даже если он реализован как динамический массив.
* Временная сложность O(n) - это "худший сценарий", а O(1) - "средний сценарий".
* Выбор правильной коллекции зависит от требований вашего приложения.

Примеры:
* ArrayList:  Хороший выбор для хранения списка элементов, где доступ к элементам осуществляется по индексу.
* LinkedList:  Хороший выбор для хранения списка элементов, где часто происходят операции вставки и удаления в середине списка.
* HashSet/HashMap:  Хороший выбор для хранения элементов, где доступ к элементам осуществляется по ключу.
* TreeSet/TreeMap:  Хороший выбор для хранения элементов, которые нужно отсортировать по ключу.

[_к оглавлению_](#Оглавление)
#### 20. Расскажите реализации данных очередей и стеков.

**Очередь (Queue) в Java** – это абстрактный тип данных, который реализует принцип FIFO (First In, First Out - первый вошел, первый вышел). Это означает, что элементы добавляются в конец очереди, а извлекаются из начала. Представьте, как люди стоят в очереди в магазине – первый человек, кто пришел, первым и будет обслуживаться кассиром.

Основные реализации Queue:

***PriorityQueue:***

Основные свойства:
+ Основана на куче (heap).
+ Порядок элементов определяется заданным компаратором (если компаратор не задан - NaturalOrder).
+ Обеспечивает быструю вставку и удаление элементов с минимальным значением.

Преимущества:
+ Эффективность при необходимости быстрого доступа к минимальному элементу.
+ Подходит для задач, требующих сортировки по приоритету.

Интерфейс `java.util.Queue` предоставляет основные операции с очередями:

+ `add(E element)`: добавляет элемент в конец очереди.
+ `E element()`: возвращает, но не удаляет, элемент из начала очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `boolean offer(E obj)`: добавляет элемент `obj` в конец очереди. Если элемент удачно добавлен, возвращает `true`, иначе - `false`.
+ `E peek()`: возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение `null`.
+ `E poll()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение `null`.
+ `E remove()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.

**Интерфейс Deque** - расширяет вышеописанный интерфейс Queue и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, либо как стек, действующий по принципу LIFO (Last In, First Out - последний вошел, первый вышел).

**Основные реализации Deque:**

***ArrayDeque:*** - использует массив для хранения элементов.

Основные свойства:
+ Быстрая работа с добавлением и удалением элементов с обоих концов.
+ Неэффективна при добавлении и удалении элементов из середины.
+ Не подходит для хранения больших объемов данных, так как при достижении предела размера массива требуется перераспределение памяти.

Применение: оптимально для небольших коллекций, где требуется быстрый доступ к элементам с обоих концов.

***LinkedList*** - использует двусвязный список для хранения элементов.

Основные свойства:
+ Эффективна при добавлении и удалении элементов из любой позиции.
+ Доступ к элементам по индексу может быть медленным.
+ Требует больше памяти, чем `ArrayDeque`.

Применение: оптимально для коллекций с частыми операциями добавления и удаления элементов в произвольных местах.

***ConcurrentLinkedDeque*** - использует двусвязный список для хранения элементов. Обеспечивает потокобезопасность.

Основные свойства:
+ Эффективна при добавлении и удалении элементов из любой позиции.
+ Доступ к элементам по индексу может быть медленным.
+ Требует больше памяти, чем `ArrayDeque`.
+ Гарантирует потокобезопасность, что делает ее подходящей для многопоточной среды.

Применение: оптимально для коллекций, которые используются в многопоточной среде и требуют потокобезопасной работы с элементами.

Выбор оптимальной реализации `Deque` зависит от конкретной задачи и требований к производительности.

+ Для небольших коллекций с частыми операциями добавления и удаления с обоих концов `ArrayDeque` будет наиболее эффективной.
+ Для коллекций с частыми операциями добавления и удаления из любой позиции, а также для больших объемов данных `LinkedList` будет более подходящим выбором.
+ Для многопоточной среды `ConcurrentLinkedDeque` предоставляет потокобезопасную работу с коллекцией.

Интерфейс Deque определяет следующие методы:

+ `void addFirst(E obj)`: добавляет элемент в начало очереди.
+ `void addLast(E obj)`: добавляет элемент `obj` в конец очереди.
+ `E getFirst()`: возвращает без удаления элемент из головы очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `E getLast()`: возвращает без удаления последний элемент очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `boolean offerFirst(E obj)`: добавляет элемент `obj` в самое начало очереди. Если элемент удачно добавлен, возвращает `true`, иначе - `false`.
+ `boolean offerLast(E obj)`: добавляет элемент `obj` в конец очереди. Если элемент удачно добавлен, возвращает `true`, иначе - `false`.
+ `E peekFirst()`: возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение `null`.
+ `E peekLast()`: возвращает без удаления последний элемент очереди. Если очередь пуста, возвращает значение `null`.
+ `E pollFirst()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение `null`.
+ `E pollLast()`: возвращает с удалением последний элемент очереди. Если очередь пуста, возвращает значение `null`.
+ `E pop()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `void push(E element)`: добавляет элемент в самое начало очереди.
+ `E removeFirst()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `E removeLast()`: возвращает с удалением элемент из конца очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `boolean removeFirstOccurrence(Object obj)`: удаляет первый встреченный элемент `obj` из очереди. Если удаление произшло, то возвращает `true`, иначе возвращает `false`.
+ `boolean removeLastOccurrence(Object obj)`: удаляет последний встреченный элемент `obj` из очереди. Если удаление произшло, то возвращает `true`, иначе возвращает `false`.

Таким образом, наличие методов pop и push позволяет классам, реализующим этот элемент, действовать в качестве стека. В тоже время имеющийся функционал также позволяет создавать двунаправленные очереди, что делает классы, применяющие данный интерфейс, довольно гибкими.

Stack - это линейная структура данных, которая работает по принципу "последним пришёл - первым ушёл" (LIFO - Last In First Out).  В Java она реализована как класс `java.util.Stack`, наследующий класс `java.util.Vector`.

Основные характеристики Stack:
* LIFO: Элементы добавляются и удаляются из конца стека (вершины).
* Не индексируемый: Доступ к элементам возможен только через методы стека.
* Динамический размер: Стек автоматически увеличивает свой размер по мере добавления элементов.

Методы Stack:

1. `push(E item)`: Добавляет элемент `item` на вершину стека.
2. `pop()`: Удаляет и возвращает элемент с вершины стека. Если стек пуст, выдается исключение `EmptyStackException`.
3. `peek()`: Возвращает элемент с вершины стека без удаления. Если стек пуст, выдается исключение `EmptyStackException`.
4. `empty()`: Возвращает `true`, если стек пуст, иначе `false`.
5. `search(Object o)`: Возвращает позицию элемента `o` в стеке, считая от вершины (0 - вершина). Если элемент не найден, возвращает -1.
6. `size()`: Возвращает количество элементов в стеке.
7. `toArray()`:  Преобразует стек в массив.
8. `isEmpty()`:  Проверяет, пуст ли стек.

[_к оглавлению_](#Оглавление)
#### 21. Расскажите про реализации деревьев.

В Java существуют две основные коллекции, основанные на деревьях:

***1. `TreeMap`:***

Реализация: самобалансирующееся двоичное дерево поиска (по умолчанию - красно-черное дерево).
 
Ключи: должны реализовывать интерфейс `Comparable` или предоставлять компаратор (`Comparator`).
 
Порядок: элементы упорядочены по ключам.
 
Преимущества:
* Гарантированное время поиска, вставки и удаления: O(log n).
* Сортировка по ключам: итерация по элементам происходит в отсортированном порядке ключей.
* Быстрый поиск по ключу: используется двоичный поиск.

Недостатки:
* Требует реализации `Comparable` или `Comparator` для ключей: Добавляет сложность в разработку.
* Немного более сложная реализация: По сравнению с `HashMap`.
* Дополнительные расходы на балансировку дерева: Увеличивает время выполнения операций.

***2. `TreeSet`:***

Реализация: использует `TreeMap` как основу.
Элементы: должны реализовывать интерфейс `Comparable` или предоставлять компаратор (`Comparator`).
Порядок: элементы упорядочены по натуральному порядку или по компаратору.

Преимущества:
* Гарантированное время поиска, вставки и удаления: O(log n).
* Сортировка элементов: итерация по элементам происходит в отсортированном порядке.
* Уникальность элементов: не допускает дубликатов.

Недостатки:
* Требует реализации `Comparable` или `Comparator` для элементов: Добавляет сложность в разработку.
* Немного более сложная реализация: По сравнению с `HashSet`.
* Дополнительные расходы на балансировку дерева: Увеличивает время выполнения операций.

Сравнение с другими коллекциями:
* `HashMap` и `HashSet`: быстрее для операций поиска, вставки и удаления, если порядок не важен. Используют хэш-таблицу для хранения данных.
* `ArrayList` и `LinkedList`: линейные структуры данных, не предоставляют гарантий сортировки. Время поиска, вставки и удаления может быть медленным для больших наборов данных.

Когда использовать коллекции, основанные на деревьях:
* Когда требуется упорядоченное хранение данных.
* Когда важна гарантия быстрого поиска, вставки и удаления.
* Когда требуется уникальность элементов (в случае `TreeSet`).

Примеры использования:
* `TreeMap`: Хранение пар "ключ-значение" в отсортированном порядке ключей, например, для хранения слов и их частоты в тексте.
* `TreeSet`: Хранение уникальных элементов в отсортированном порядке, например, для хранения списка городов в порядке алфавита.

Важно помнить:
* Коллекции, основанные на деревьях, требуют дополнительной памяти для хранения структуры дерева.
* Они могут быть менее эффективными, чем хэш-таблицы, для задач, не требующих сортировки.

[_к оглавлению_](#Оглавление)
#### 22. Что такое loadFactor?

В Java, `loadFactor` - это важный параметр для коллекций, использующих хэш-таблицы, таких как `HashMap`, `HashSet`, `LinkedHashMap`, `LinkedHashSet` и `ConcurrentHashMap`. Он определяет, насколько полной должна быть хэш-таблица, прежде чем она будет переразмерена.

Пояснение:
* Хэш-таблица: это структура данных, где элементы хранятся в массиве, а индекс элемента определяется хэш-функцией. 
* Переразмерение: когда хэш-таблица становится слишком полной, операции добавления новых элементов замедляются. Чтобы избежать этого, коллекция переразмерена, создавая новую, более вместительную хэш-таблицу, и переносит все элементы из старой таблицы в новую.

Как работает loadFactor:

1. `loadFactor` представляет собой число между 0 и 1. 
2. Он умножается на текущий размер хэш-таблицы, чтобы определить порог, при котором будет проведено переразмерение. 
3. Например, если `loadFactor` равен 0.75, а текущий размер таблицы 10, переразмерение будет выполнено, когда в таблице будет 7.5 элементов (0.75 от 10). Поскольку число элементов должно быть целым, переразмерение будет выполнено, когда в таблице будет 8 элементов.

Значение loadFactor:
* Высокий loadFactor: Ведет к меньшему количеству переразмерений, но может привести к замедлению операций, если таблица будет перегружена.
* Низкий loadFactor: Чаще происходит переразмерение, что требует больше ресурсов, но операции могут быть быстрее.

Пример:

```java
HashMap<String, Integer> map = new HashMap<>(10, 0.5); 
```

В этом примере мы создаем `HashMap` с начальным размером 10 и `loadFactor` 0.5. Переразмерение произойдет, когда в таблице будет 5 элементов (0.5  10).

Рекомендуемый loadFactor: обычно рекомендуемый `loadFactor` - 0.75, так как он обеспечивает хороший баланс между производительностью и использованием памяти. Однако вы можете настроить его в зависимости от конкретных потребностей вашего приложения.

Важно отметить:
* `loadFactor` не определяет размер хэш-таблицы. Он определяет, когда произойдет переразмерение, чтобы поддерживать оптимальную производительность.
* Изменение `loadFactor` после создания коллекции не повлияет на уже существующую таблицу.

[_к оглавлению_](#Оглавление)
#### 23. Перечислите побитовые логические операции, которые Вы знаете. Расскажите, как они работают.

***Побитовое "ИЛИ" ( | ) или OR***

Возвращает 1, если хотя бы один из соответствующих битов операндов равен 1. В противном случае возвращает 0.

![img](https://github.com/shaporen/job4j_interviews/blob/main/resources/pobitOR.png)

***Побитовое "И" (&) или AND***

Возвращает 1, если оба соответствующих бита операндов равны 1. В противном случае возвращает 0.

![img](https://github.com/shaporen/job4j_interviews/blob/main/resources/pobitAND.png)

***Побитовое "Исключающее ИЛИ" (^) или XOR***

Возвращает 1, если только один из соответствующих битов операндов равен 1. В противном случае возвращает 0.

![img](https://github.com/shaporen/job4j_interviews/blob/main/resources/pobitXOR.png)

***Унарная операция "НЕ" (~) или NOT***

Инвертирует каждый бит операнда. 1 становится 0, а 0 становится 1.

![img](https://github.com/shaporen/job4j_interviews/blob/main/resources/pobitNOT.png)

***Таблица истинности побитовых операций:***

![img](https://github.com/shaporen/job4j_interviews/blob/main/resources/pobitTable.png)

Операторы представляют собой применение битовых масок к аргументу в соответствии с логическими функциями. Например, оператор `&` применяется для поиска элемента в HashMap по формуле `h & (length -1)`, где `h` - хэшкод элемента, а `length` - длина массива.

Битовая маска - это двоичное число, нужное для получения определенных цифр другого двоичного числа. Целевое число сравнивается с маской с помощью побитовых логических операций, в результате чего получается бит/биты, то есть результирующее число.

[_к оглавлению_](#Оглавление)
#### 24. Расскажите про операции сдвига. Какие они бывают и что делают?

Операции сдвига в Java - это битовые операции, которые перемещают биты числа влево или вправо, эффективно умножая или деля на степени двойки.

Виды операций сдвига:
* Беззнаковый сдвиг влево (`<<`): 

Сдвигает двоичное представление первого операнда влево на количество бит, заданное во втором операнде, знак числа не сохраняется. Младшие(крайние правые) биты при этом заполняются нулями. Сдвиг на 1 бит влево соответствует умножению на 2.

Примеры:

```
27 (11011) << 1 = 54 (110110)`
-5 (1111 1111 1111 1111 1111 1111 1111 1011) << 1 = -10 (1111 1111 1111 1111 1111 1111 1111 0110)
```

Если число выходит за границы диапазона типа int, крайний бит (знак числа) теряется:

```
2 147 483 647 (0111 1111 1111 1111 1111 1111 1111 1111) << 1 = -2 (1111 1111 1111 1111 1111 1111 1111 1110)
```

* Знаковый сдвиг вправо (`>>`):

Cдвигает двоичное представление первого операнда вправо на количество бит, заданное во втором операнде, знак числа сохраняется. Старшие(крайние левые биты) заполняются ведущими нулями (при сдвиге положительного числа) или единицами (при сдвиге отрицательного числа). Сдвиг на 1 бит вправо соответствует делению на 2:
```
24 (11000) >> 1 = 12 (1100)
-4 (1111 1111 1111 1111 1111 1111 1111 1100) >> 1 = -2 (1111 1111 1111 1111 1111 1111 1111 1110)
```
* Беззнаковый сдвиг вправо (`>>>`):

Сдвигает двоичное представление первого операнда вправо на количество бит, заданное во втором операнде, знак числа не сохраняется. Для положительных чисел работает как деление:
```
24 (11000) >>> 1 = 12 (1100)
-24 (1111 1111 1111 1111 1111 1111 1110 1000) >>> 1 = 2147483636 (0111 1111 1111 1111 1111 1111 1111 0100)
```
Можно увидеть, что знаковый бит был заменён нулём.

* Беззнаковый сдвиг влево (`>>>`): не существует, потому что такой сдвиг не оказывает влияния на старший значащий бит(MSB) - крайний левый бит числа, изменяются только крайние правые биты. Кроме того, в процессорах семейства 8086 арифметический и логический сдвиг выполняют одну и ту же операцию.

Первым операндом оператора сдвига является число, которое нужно обработать, а вторым - количество бит, на которое следует выполнить сдвиг. Результатом операции сдвига является двоичное представление числа, сдвинутое в заданном направлении. Знаковые сдвиги также называют арифметическими, а беззнаковые - логическими.

***Особенности работы операторов сдвига***

Операторы сдвига всегда возвращают тип int, даже если аргумент типа, например, byte. поэтому следующий код вернёт ошибку - `Incompatible types. Found: int, required: byte`:
```
byte n = 27;
  n = n << 1;
```
Устранить ошибку можно путём приведения к типу byte:
```
n = (byte) (n << 1);
```
Нельзя сдвинуть на количество бит, большее, чем разрядность операнда. При этом происходит неявное сокращение правого (кол-во бит) операнда.

Пример:

Если сдвинуть данное число на 32 бита, по идее, результат должен состоять из одних нулей, но на самом деле это не так:
```
-1 (1111 1111 1111 1111 1111 1111 1111 1111) >> 32 = -1 (1111 1111 1111 1111 1111 1111 1111 1111)
-1 (1111 1111 1111 1111 1111 1111 1111 1111) >>> 32 = -1 (1111 1111 1111 1111 1111 1111 1111 1111)
```

Примеры применения битовых операций:
* Ускорение операций умножения и деления чисел на два. Примеры можно увидеть в стандартной библиотеке jdk. Важно понимать, что сдвиги намного хуже читаются в коде, нежели обычные арифметические операции, поэтому применять их нужно согласованно на уровне команды/проекта, иначе другие программисты могут внезапно столкнуться со сложностями чтения такого кода.
* Битовые поля(флаги). Пример: пусть есть права на доступ - чтение, запись, выполнение. Их удобнее хранить не в трёх разных переменных, а в одной, устанавливая соответствующие биты.
* Алгоритмы шифрования и сжатия (например, Шифр Вернама построен на XOR).
* Работа с графикой.
* Работа с сетью.

[_к оглавлению_](#Оглавление)
#### 25. Как хранится знак числа в Java? Как хранятся отрицательные числа?

Все примитивные (целочисленные) типы данных в Java (кроме char) представлены со знаком, то есть число может быть положительным или отрицательным. Знак числа определяет старший двоичный разряд (самый левый). 0 - знак плюс. 1 - знак минус. Старший двоичный разряд называется дополнительным кодом (или вторым дополнением (two's complement)), так как хранит только знак числа. Например, в типе int старший двоичный разряд уходит под хранение знака, а под само значение уходят остальные 31 бит.

[_к оглавлению_](#Оглавление)
#### 26. Расскажите о системах сборки проекта. В чем отличие систем сборки Ant, Maven и Gradle?

***1. Apache Maven:***
- Тип: система автоматической сборки и управления зависимостями.
- XML-основанность: основан на XML-конфигурации (pom.xml), где описывается конфигурация проекта, зависимости, цели сборки и т. д.
- Конвенции над конфигурациями: Правила сборки определяются с помощью конвенций, что делает Maven легко конфигурируемым и совместимым с шаблонами.
- Функционал: основной функционал - управление зависимостями, компиляция, тестирование, упаковка, развертывание проекта.
- Плагины: Использует плагины для расширения функциональности и настройки сборочных процессов.

***2. Gradle:***
- Тип: Система автоматической сборки и управления зависимостями.
- DSL: Основан на DSL (Domain Specific Language), который позволяет более гибкую и наглядную конфигурацию сборочных скриптов.
- Гибкость: Gradle позволяет более гибкие настройки, объединяя их в логические блоки. Динамическая загрузка зависимостей.
- Инкрементальная сборка: Частичное построение, эффективное использование кэша.
- Интеграция: Хорошо интегрируется с Java, Groovy, Kotlin и другими языками.

***3. Apache Ant:***
- Тип: Инструмент автоматизации сборки.
- XML-основанность: Основан на XML-конфигурации, аналогично Maven, но менее строго управляет структурой проекта.
- Гибкость: Более гибкая и настраиваемая система, позволяющая разработчикам создавать собственные сборочные скрипты.
- Простота: Проще в использовании для более простых проектов.

Основные различия:
- Управление зависимостями  - Maven и Gradle имеют мощные средства управления зависимостями и артефактами, в то время как Ant требует более ручной работы с зависимостями.
- Конфигурация - Maven и Ant основаны на XML, в то время как Gradle использование DSL на основе Groovy или Kotlin.
- Гибкость и производительность - Gradle обычно более гибкий и производителен благодаря своей инкрементальной сборке, в то время как Maven чаще следует структурированным конвенциям и правилам.

[_к оглавлению_](#Оглавление)
#### 27. Как создать maven проект?

**1. Установка Maven:**
* Если Maven не установлен, скачайте его с официального сайта [https://maven.apache.org/](https://maven.apache.org/).
* Распакуйте архив в удобное место.
* Проверка через командную строку `cd c:\Tools\apache-maven-3.6.3\bin` и проверка версии `mvn --version`.
* Создание переменных для версии `JDK` и для `Maven`.
* Добавьте путь к папке `bin` в переменную окружения `PATH` (вместе со ссылкой на JDK, настройка окружения).

**2. Проверка настроек:**
* `echo %JAVA_HOME%`
* `echo %M2_HOME%`
* `echo %PATH%`
* `java --version`
* `javac --version`
* `mvn --version`
* Для корректной работы версии Java в ответах команд должна быть одна и та же

**3. Инициализация проекта:**
* Откройте командную строку (терминал) и перейдите в директорию, где вы хотите создать проект, например `cd c:\projects\`.
* Запустите команду `mvn archetype:generate` для запуска генератора архетипов.
* Введите следующие данные:
  - `groupId`: идентификатор группы проекта (например, `com.example`).
  - `artifactId`: идентификатор проекта (например, `my-project`).
  - `version`: версия проекта (например, `1.0.0`).
  - `package`: пакет для основного класса проекта (например, `com.example.myproject`).
  - Выберите архетип, который соответствует вашим потребностям. Например, `maven-archetype-quickstart` или `maven-archetype-simple` для простого проекта Java.
  - общий пример `mvn archetype:generate -DgroupId=ru.job4j -DartifactId=job4j_design -DarchetypeArtifactId=maven-archetype-simple -DarchetypeVersion=1.4 -DinteractiveMode=false`
* Подтвердите создание проекта.
* Редактирование файла pom.xml (версия JDK, JUnit и т.д.)
* Проверка с помощью команды `mvn install`

**4. Просмотр созданных файлов:**
* Maven создаст новую директорию с именем `artifactId`.
* Внутри вы найдете следующие файлы и папки:
     - `pom.xml`: файл конфигурации Maven, описывающий проект и его зависимости.
     - `src/main/java`: директория для исходного кода Java.
     - `src/test/java`: директория для тестового кода Java.

**5. Настройка проекта (pom.xml):**
* Откройте файл `pom.xml` в текстовом редакторе.
* Вы можете добавить зависимости, плагины и другие конфигурации в соответствии с вашими потребностями.
* Например, чтобы добавить зависимость от библиотеки JUnit для тестирования:
     ```xml
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
       <version>4.13.1</version>
       <scope>test</scope>
     </dependency>
     ```
**6. Создание классов:**
* Создайте новые Java-классы в директории `src/main/java` в соответствии с вашим проектом.

**7. Сборка проекта:**
* Откройте командную строку (терминал) и перейдите в директорию проекта.
* Запустите команду `mvn clean package` для компиляции, тестирования и упаковки проекта в JAR-файл.

**8. Запуск проекта:**
* В зависимости от типа проекта, вы можете запустить его различными способами.
* Например, для простого Java-приложения:
     - Откройте командную строку (терминал) и перейдите в директорию `target`.
     - Запустите команду `java -cp my-project-1.0.0.jar com.example.myproject.App` (замените `my-project-1.0.0.jar` на имя вашего JAR-файла и `com.example.myproject.App` на имя класса с методом `main`).

[_к оглавлению_](#Оглавление)
#### 28. Какова структура maven проекта?

Структура проекта Maven довольно гибкая и зависит от типа проекта, но стандартная структура выглядит так:

**Корневой каталог проекта:**
* pom.xml:  главный файл проекта. Определяет зависимости, плагины, настройки сборки и т.д.
* src/main/java:  исходный код Java (классы, интерфейсы, enum).
* src/main/resources:  ресурсные файлы (например, файлы конфигурации, изображения, свойства).
* src/test/java:  тестовые классы Java.
* src/test/resources:  ресурсные файлы для тестов.
* target: каталог, где Maven собирает артефакт проекта (например, JAR файл).

**Дополнительные каталоги:**
* src/main/webapp: каталог для web-приложений (для проектов типа "war").  Содержит файлы веб-интерфейса (JSP, HTML, CSS, JavaScript).
* src/main/assembly: каталог для конфигурации сборки (для создания более сложных артефактов, таких как ZIP-архивы).
* src/site: каталог для документации проекта (генерируется Maven).

**Примеры:**

_Проект Java:_ 
- `src/main/java`
- `src/test/java`

_Проект Web:_ 
  - `src/main/java`
  - `src/main/webapp`
  - `src/test/java`

_Проект с документацией:_
  - `src/site`
  - `src/main/java`

**Основные преимущества структуры Maven:**
* Стандартизация: обеспечивает согласованную структуру проекта, что облегчает совместную работу.
* Управление зависимостями: Maven автоматически скачивает и управляет зависимостями проекта.
* Автоматизация сборки: Maven предоставляет средства для автоматизации процесса сборки, тестирования, развертывания проекта.
* Плагины: Maven поддерживает множество плагинов, которые расширяют его функциональность.

Настройка структуры: структуру проекта можно настроить в файле `pom.xml`.  Например, можно добавить дополнительные каталоги или изменить стандартные имена каталогов.

[_к оглавлению_](#Оглавление)
#### 29. Расскажите о файле pom.xml. Как он структурирован и за что отвечает содержание каждой части?

Информация для программного проекта, поддерживаемого Maven, содержится в XML-файле с именем pom.xml (от Project Object Model). При исполнении Мавен проверяет прежде всего, содержит ли этот файл все необходимые данные и все ли данные синтаксически правильно записаны.

**1. Корневой элемент**

Корневой элемент `<project>`, в котором прописана схема облегчающая редактирование и проверку, и версия POM.
```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    ...
</project>
```

**2. Заголовок**

Внутри тега `project` содержится основная и обязательная информация о проекте:
```
<groupId>com.examclouds</groupId>
<artifactId>courses</artifactId>
<version>1.0-SNAPSHOT</version>
```
В Maven каждый проект идентифицируется парой `groupId`, `artifactId`.

Во избежание конфликта имён, `groupId` - наименование организации или подразделения и обычно действуют такие же правила, как и при именовании пакетов в Java - записывают доменное имя организации или сайта проекта.

`artifactId` - название проекта.

Внутри тега `version` хранится версия проекта.

Тройкой `groupId`, `artifactId`, `version` (далее - GAV) можно однозначно идентифицировать `jar` файл приложения или библиотеки. Если состояние кода для проекта не зафиксировано, то в конце к имени версии добавляется "-SNAPSHOT" что обозначает, что версия в разработке и результирующий jar файл может меняться.

**3. Тег `packaging`**

Тег `<packaging>` определяет какого типа файл будет создаваться как результат сборки. Возможные варианты `pom`, `jar`, `war`, `ear`.

Тег является необязательным. Если его нет, используется значение по умолчанию - `jar`.

**4. Описание проекта**

Также добавляется информация, которая не используется самим Maven, но нужна для программиста, чтобы понять, о чём этот проект:
```
<name>powermock-core</name> название проекта для человека
<description>PowerMock core functionality.</description> Описание проекта
<url>http://www.powermock.org</url> сайт проекта
```

**5. Зависимости**

Зависимости - следующая очень важная часть `pom.xml` - тут хранится список всех библиотек (зависимостей) которые используются в проекте. Каждая библиотека идентифицируется так же как и сам проект - тройкой `groupId`, `artifactId`, `version` (GAV). Объявление зависимостей заключено в теге `<dependencies>...</dependencies>`. 

Кроме GAV при описании зависимости может присутствовать тег `<scope>`. Он задаёт, для чего библиотека используется. В данном примере говорится, что библиотека с GAV `junit.jupiter:junit-jupiter-engine:5.10.0` нужна только для выполнения тестов.
```
<dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-engine</artifactId>
      <version>5.10.0</version>
      <scope>test</scope>
</dependency>
```

**6. Тег `<build>`**

Тег <build>  не обязательный, так как существуют значения по умолчанию. Этот раздел содержит информацию по самой сборке:
* где находятся исходные файлы,
* где ресурсы,
* какие плагины используются.
```
<sourceDirectory>src</sourceDirectory>
    <resources>
        <resource>
            <directory>resources</directory>
        </resource>
    </resources>
<plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-checkstyle-plugin</artifactId>
        <version>3.1.2</version>
        <configuration>
          <configLocation>checkstyle.xml</configLocation>
          <encoding>UTF-8</encoding>
          <consoleOutput>true</consoleOutput>
          <failsOnError>true</failsOnError>
          <includeTestSourceDirectory>true</includeTestSourceDirectory>
        </configuration>
        <dependencies>
          <dependency>
            <groupId>com.puppycrawl.tools</groupId>
            <artifactId>checkstyle</artifactId>
            <version>10.3.1</version>
          </dependency>
        </dependencies>
        <executions>
          <execution>
            <id>validate</id>
            <phase>validate</phase>
            <goals>
              <goal>check</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
```
* `<sourceDirectory>` - определяет, откуда Maven будет брать файлы исходного кода. По умолчанию это `src/main/java`, но вы можете определить, где это вам удобно. Директория может быть только одна (без использования специальных плагинов).
* `<recources>` и вложенные в неё теги <recource> определяют, одну или несколько директорий, где хранятся файлы ресурсов. Ресурсы в отличие от файлов исходного кода при сборке просто копируются. Директория по умолчанию `src/main/resources`.
* `<outputDirectory>` - определяет, в какую директорию компилятор будет сохранять результаты компиляции - `*.class` файлы. Значение по умолчанию - `target/classes`.
* `<finalName>` - имя результирующего `jar (war, ear ...)` файла с соответствующим типу расширением, который создаётся на фазе package. Значение по умолчанию — `artifactId-version`.

Maven плагины позволяют задать дополнительные действия, которые будут выполняться при сборке. Например, в приведённом примере добавлен плагин `checkstyle`, который автоматически делает проверку кода на наличие "плохого" кода и потенциальных ошибок.

[_к оглавлению_](#Оглавление)
#### 30. Что такое координаты зависимости?

Координаты зависимости в Maven представляют собой набор значений, которые однозначно идентифицируют библиотеку или артефакт, от которого зависит проект. Координаты зависимости включают `groupId`, `artifactId` и `version`. Давайте рассмотрим каждый из них:

**`groupId`** (идентификатор группы):
- Идентифицирует группу или организацию, которая создала библиотеку.
- Обычно представляет собой обратный домен организации (например, com.example).

**`artifactId`** (идентификатор артефакта):
- Уникально идентифицирует сам артефакт или библиотеку внутри groupId.
- Часто используется для указания имени самой библиотеки (например, my-library).

**`version`** (версия):
- Определяет конкретную версию библиотеки, от которой зависит проект.
- Может быть конкретной версией (например, 1.0.0) или использовать диапазон версий (например, [1.0.0,2.0.0)).

Например, если вы хотите добавить зависимость на библиотеку Apache Commons Lang версии 3.9, то координаты зависимости будут выглядеть примерно так:

![img](https://github.com/shaporen/job4j_interviews/blob/main/resources/CoordDependency.png)

Эти координаты помогают Maven однозначно идентифицировать и подтягивать нужные библиотеки для проекта, обеспечивая управление зависимостями и правильную сборку проекта.

[_к оглавлению_](#Оглавление)
#### 31. Что такое транзитивные зависимости?

В Maven транзитивные зависимости - это зависимости, которые ваш проект не указывает напрямую, но которые необходимы для работы зависимостей, которые вы указали. Представьте себе это как цепочку: 
* Ваш проект: зависит от библиотеки A.
* Библиотека A: зависит от библиотеки B.
* Библиотека B: зависит от библиотеки C.

В этом случае, B и C являются транзитивными зависимостями для вашего проекта, потому что они не были указаны явно, но необходимы для работы библиотеки A.

Почему транзитивные зависимости важны?
* Упрощение зависимостей: Вам не нужно явно указывать все необходимые библиотеки, Maven сам их найдет и скачает. 
* Автоматическое разрешение конфликтов: Maven автоматически анализирует все зависимости и выбирает правильную версию каждой библиотеки, чтобы избежать конфликтов между зависимостями.
* Улучшение производительности: Maven кеширует скачанные зависимости, что позволяет избежать повторной загрузки в будущих сборках.

Как работают транзитивные зависимости?

Maven использует граф зависимостей для отслеживания всех зависимостей проекта. Этот граф представляет собой дерево, где корень - ваш проект, а узлы - зависимости. Когда вы указываете зависимость в вашем pom.xml, Maven анализирует эту зависимость и все ее зависимости, добавляя их в граф зависимостей.

Пример: представьте, что у вас есть проект, который использует библиотеку Spring Boot. Spring Boot зависит от библиотеки Spring Core, которая, в свою очередь, зависит от библиотеки Commons Logging.

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
  <version>2.7.10</version>
</dependency>
```

В этом случае, Spring Core и Commons Logging - это транзитивные зависимости для вашего проекта.

Как управлять транзитивными зависимостями:

* Исключение зависимостей: вы можете исключить транзитивную зависимость, если она не нужна вашему проекту.
* Замена зависимостей: вы можете заменить транзитивную зависимость другой версией или другой библиотекой.
* Проверка зависимостей: вы можете использовать плагины Maven для анализа графа зависимостей и проверки наличия конфликтов.

**Заключение:**

Транзитивные зависимости - это важная часть системы управления зависимостями Maven, которая позволяет вам создавать проекты с минимальным количеством ручного конфигурирования. Понимание того, как работают транзитивные зависимости, поможет вам эффективно управлять зависимостями вашего проекта и избегать потенциальных проблем.

[_к оглавлению_](#Оглавление)
#### 32. Что такое область видимости зависимости? Сколько областей видимости предусмотрено и где они применяются?

Область видимости зависимости в Maven определяет, как зависимость будет использоваться в проекте. Она влияет на доступность зависимостей для других модулей проекта, а также на то, как они будут доступны во время выполнения. 

**В Maven существует четыре основные области видимости (scope):**

* **compile:** 

 Использование: зависимость необходима во время компиляции и выполнения.
 Доступность: доступна для всех модулей проекта, включая тесты.
 Пример: библиотека, содержащая классы, используемые в коде проекта.

* **provided:**

 Использование: зависимость предоставляется средой выполнения. 
 Доступность: доступна во время компиляции, но не во время выполнения.
 Пример: сервлет-контейнер, предоставляющий необходимые классы для веб-приложения.

* **runtime:** 

 Использование: зависимость необходима только во время выполнения.
 Доступность: не доступна во время компиляции, но доступна во время выполнения.
 Пример: драйвер базы данных, используемый только при запуске приложения.

* **test:**

 Использование: зависимость необходима только для тестирования.
 Доступность: доступна только в тестовом модуле.
 Пример: фреймворк для юнит-тестирования, например, JUnit.

 **Также существуют следующие области видимости зависимости (scope):**

* **system** — на данный момент помечено как deprecated. Обычно используется для того, чтобы сообщить Maven о зависимостях, которые предоставляются JDK или VM. Область действия зависимости system аналогична provided за исключением того, что содержащий зависимость артефакт указывается явно в виде относительного или абсолютного пути к файлу, определенному в теге systemPath. Например `<systemPath>${java.home}/../lib/tools.jar</systemPath>`. Maven не будет пытаться предоставить этот артефакт или класть его в пакет и т.д.

* **import** — область действия import поддерживается только для зависимостей, у которых типом packaging является pom. Используется в проектах со сложной структурой. Указывает зависимость, которая должна быть заменена на эффективный список зависимостей в разделе dependencyManagement указанного POM.

**Дополнительные замечания:**

* Наследование области видимости: зависимость, объявленная с областью видимости `compile`, наследуется всеми зависимостями с областью видимости `runtime` и `test`.
* Транзитивные зависимости: Maven автоматически скачивает и включает транзитивные зависимости, которые необходимы для выполнения зависимостей проекта. Область видимости транзитивной зависимости определяется областью видимости ее родительской зависимости.
* Исключения зависимостей: можно исключить определенные зависимости из транзитивного графа зависимостей, используя элемент `<exclusion>`.

Пример:

```xml
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-core</artifactId>
  <version>5.3.20</version>
  <scope>compile</scope>
</dependency>

<dependency>
  <groupId>junit</groupId>
  <artifactId>junit</artifactId>
  <version>4.13.2</version>
  <scope>test</scope>
</dependency>
```

В этом примере `spring-core` будет доступен для компиляции и выполнения, а `junit` будет доступен только для тестирования.

Выбор области видимости: правильный выбор области видимости зависимостей важен для оптимизации размера приложения и минимизации конфликтов зависимостей. 

Рекомендации:
* Используйте `compile` для зависимостей, необходимых для компиляции и выполнения.
* Используйте `provided` для зависимостей, предоставляемых средой выполнения.
* Используйте `runtime` для зависимостей, необходимых только во время выполнения.
* Используйте `test` для зависимостей, необходимых только для тестирования.

[_к оглавлению_](#Оглавление)
#### 33. Расскажите о жизненном цикле maven. В какой последовательности выполняются фазы цикла и что происходит на каждой фазе сборки?

Жизненный цикл сборки в Maven представляет собой последовательность стадий (фаз), в которых происходит сборка, тестирование, упаковка и развертывание проекта. Каждая фаза цикла является последовательным шагом сборки проекта.

Стандартный жизненный цикл Maven включает следующие фазы:

**1. clean:**
   - Очистка директории `target`

**2. validate:**
   - Проверка корректности проекта.
   - Проверка, что все необходимые параметры и ресурсы доступны.

**3. compile:**
   - Компиляция Java исходных файлов проекта.
   - Преобразование исходного кода в байт-код Java.

**4. test:**
   - Запуск модульных тестов проекта.
   - Проверка корректности работы функциональности.

**5. package:**
   - Упаковка скомпилированных файлов в JAR, WAR или другой формат артефакта.
   - Создание исполняемого файла или библиотеки.

**6. verify:**
   - Проверка качества созданного артефакта.
   - Проведение дополнительных проверок после упаковки.

**7. install:**
   - Установка созданного артефакта в локальный репозиторий Maven.
   - Доступ к артефакту из других проектов на локальной машине.

**8. deploy:**
   - Размещение созданного артефакта в удаленный репозиторий.
   - Доступ к артефакту из других проектов.

Из чего состоит каждая фаза:
- clean - очистка директории `target`
- validate - проверка корректности проекта, наличие необходимых ресурсов.
- compile - компиляция Java исходных файлов в байт-код Java.
- test - запуск модульных тестов для проверки корректности работы.
- package - упаковка скомпилированных файлов в артефакт (JAR, WAR).
- verify - проверка качества созданного артефакта, проведение дополнительных проверок.
- install - установка артефакта в локальный репозиторий машины.
- deploy - размещение артефакта в удаленный репозиторий для общего доступа.

Жизненный цикл Maven обеспечивает автоматизацию процесса сборки проекта, позволяя разработчикам эффективно управлять этапами разработки и обеспечивать качественный конечный результат.

Более подробно, жизненный цико Maven состоит из следующих фаз:

1. clean: Очистка директории `target`
2. validate: Проверяет, доступны ли все необходимые ресурсы и конфигурации для сборки проекта.
3. initialize:  Инициализирует проект, создавая директории и файлы, необходимые для сборки.
4. generate-sources:  Создает исходный код, который не был написан вручную, например, код для генерации документации.
5. process-sources: Обрабатывает исходный код, например, выполняя компиляцию и форматирование.
6. generate-resources:  Создает ресурсы, такие как файлы конфигурации или шаблоны, которые будут использоваться в проекте.
7. process-resources:  Обрабатывает ресурсы, например, копирует их в директорию сборки.
8. compile: Компилирует исходный код Java в байт-код.
9. process-classes:  Обрабатывает скомпилированный код, например, добавляя в него аннотации.
10. generate-test-sources:  Создает исходный код для тестов, например, используя генератор тестов.
11. process-test-sources:  Обрабатывает исходный код тестов.
12. generate-test-resources:  Создает ресурсы для тестов.
13. process-test-resources:  Обрабатывает ресурсы для тестов.
14. test-compile:  Компилирует исходный код для тестов.
15. test:  Запускает тесты.
16. prepare-package:  Подготавливает проект к упаковке.
17. package: Упаковывает проект в архив, например, JAR, WAR или EAR.
18. pre-integration-test: Выполняет действия перед интеграционным тестированием.
19. integration-test:  Выполняет интеграционное тестирование.
20. post-integration-test:  Выполняет действия после интеграционного тестирования.
21. verify:  Проверяет, соответствует ли проект требованиям качества.
22. install: Устанавливает проект в локальный репозиторий Maven.
23. deploy: Развертывает проект на сервер репозитория.

По умолчанию Maven выполняет все фазы жизненного цикла. 

Пример: если вы выполните команду `mvn install`, Maven выполнит все 22 фазы жизненного цикла.

Вы можете использовать команды Maven для выполнения отдельных фаз жизненного цикла. Например:
 `mvn compile`: Компилирует исходный код Java.
 `mvn test`: Выполняет тесты.
 `mvn package`: Упаковывает проект в архив.

Порядок выполнения фаз: фазы жизненного цикла выполняются в строгом порядке. Например, фаза `test` выполняется только после фазы `compile`, так как для запуска тестов необходимо сначала скомпилировать исходный код.

Пример использования: представьте себе проект, в котором необходимо скомпилировать исходный код Java, выполнить тесты и упаковать проект в JAR-файл. Вы можете выполнить эту задачу с помощью следующей команды:

```
mvn package
```
Эта команда запустит все фазы жизненного цикла до фазы `package`, включая компиляцию и тестирование. В результате будет создан JAR-файл проекта.

[_к оглавлению_](#Оглавление)
