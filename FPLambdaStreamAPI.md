##### [job4j_interviews](https://github.com/shaporen/job4j_interviews/blob/main/README.md)
#### Оглавление
+ [1. Что такое lambda-выражение?](#1-Что-такое-lambda-выражение)
+ [2. Что такое функциональные интерфейсы?](#2-Что-такое-функциональные-интерфейсы)
+ [3. Перечислите функциональные интерфейсы из пакета java.util.function.](#3-Перечислите-функциональные-интерфейсы-из-пакета-javautilfunction)
+ [4. Что такое функции высшего порядка?](#4-Что-такое-функции-высшего-порядка)
+ [5. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?](#5-Какие-функциональные-интерфейсы-из-пакета-javautilfunction-поддерживают-функции-высшего-порядка)
+ [6. Что такое ссылки на методы?](#6-Что-такое-ссылки-на-методы)
+ [7. Что такое ссылки на конструкторы?](#7-Что-такое-ссылки-на-конструкторы)
+ [8. Расскажите о зоне видимости переменных в lambda-выражениях?](#8-Расскажите-о-зоне-видимости-переменных-в-lambda-выражениях)
+ [9. Как быть в ситуации, если внутри lambda-выражения операторы могут выкинуть исключение?](#9-Как-быть-в-ситуации-если-внутри-lambda-выражения-операторы-могут-выкинуть-исключение)
+ [10. Что такое Stream API?](#10-Что-такое-Stream-API)
+ [11. Расскажите, какие шаблоны проектирования используются внутри Stream API? (Builder, Strategy, Decorator, Factory Method, Pipeline).](#11-Расскажите-какие-шаблоны-проектирования-используются-внутри-Stream-API-Builder-Strategy-Decorator-Factory-Method-Pipeline)
+ [12. Объясните, где они используются в Stream API.](#12-Объясните-где-они-используются-в-Stream-API)
+ [13. Что такое конвейерные (промежуточные) и терминальные операции?](#13-Что-такое-конвейерные-промежуточные-и-терминальные-операции)
+ [14. Перечислите конвейерные (промежуточные) методы Stream API.](#14-Перечислите-конвейерные-промежуточные-методы-Stream-API)
+ [15. Перечислите терминальные методы Stream API.](#15-Перечислите-терминальные-методы-Stream-API)
+ [16. Что такое отложенное выполнение lamdba?](#16-Что-такое-отложенное-выполнение-lamdba)
+ [17. Что делает метод filter()?](#17-Что-делает-метод-filter)
+ [18. Что делает метод map()?](#18-Что-делает-метод-map)
+ [19. Что делает метод flatMap()?](#19-Что-делает-метод-flatMap)
+ [20. Что делает метод collect()?](#20-Что-делает-метод-collect)
+ [21. Что делает метод findFirst()?](#21-Что-делает-метод-findFirst)
+ [22. Что делает метод reduce()?](#22-Что-делает-метод-reduce)
+ [23. Что делают методы min() и max()?](#23-Что-делают-методы-min-и-max)
+ [24. Что делают методы count(), sum(), average()?](#24-Что-делают-методы-count-sum-average)
+ [25. Что делают методы forEach() и peek()?](#25-Что-делают-методы-forEach-и-peek)
+ [26. Что делают методы skip() и limit()?](#26-Что-делают-методы-skip-и-limit)
+ [27. Что делают методы allMatch(), noneMatch() и anyMatch()?](#27-Что-делают-методы-allMatch-noneMatch-и-anyMatch)
+ [28. Что делают методы mapToInt(), flatMapToInt(), mapToObj()?](#28-Что-делают-методы-mapToInt-flatMapToInt-mapToObj)
+ [29. Что такое числовой поток?](#29-Что-такое-числовой-поток)
+ [30. Чем отличается Stream(Integer) от IntStream(int)?](#30-Чем-отличается-StreamInteger-от-IntStreamint)
+ [31. Что делает метод boxed()?](#31-Что-делает-метод-boxed)
+ [32. Возможно ли прервать выполнение потока по аналогии с break?](#32-Возможно-ли-прервать-выполнение-потока-по-аналогии-с-break)
+ [33. Возможно ли пропустить элемент потока по аналогии с continue?](#33-Возможно-ли-пропустить-элемент-потока-по-аналогии-с-continue)
+ [34. Что такое Optional?](#34-Что-такое-Optional)
+ [35. Перечислите методы Optional.](#35-Перечислите-методы-Optional)
+ [36. Расскажите про фабричные методы List.of(), Set.of(), Map.of()?](#36-Расскажите-про-фабричные-методы-Listof-Setof-Mapof)
+ [37. Для чего используется var?](#37-Для-чего-используется-var)
+ [38. В каких случаях можно использовать var?](#38-В-каких-случаях-можно-использовать-var)

#### 1. Что такое lambda-выражение?

Lambda-выражение — это анонимная функция в Java, которая может быть использована для краткого и лаконичного представления функционального интерфейса. 

Ключевые особенности:
+ Анонимность: lambda-выражения не имеют имени и не объявляются как отдельные методы.
+ Функциональный интерфейс: lambda-выражения должны соответствовать одному функциональному интерфейсу (интерфейсу с одним абстрактным методом).
+ Компактность: они предоставляют краткий и удобный способ выражения функциональности без необходимости создания отдельных классов или методов.
+ Более читаемый код: lambda-выражения могут сделать код более читабельным, особенно в контексте событийных обработчиков, коллекций и потоков.

Синтаксис:

```java
(параметры) -> { тело выражения }
```

Пример:

```java
// Интерфейс с одним абстрактным методом
interface MathOperation {
  int operation(int a, int b);
}

// Lambda-выражение, реализующее интерфейс MathOperation
MathOperation addition = (a, b) -> a + b;

// Использование lambda-выражения
int result = addition.operation(5, 3); // result = 8
```

Преимущества:
+ Сокращение кода: lambda-выражения делают код более кратким и лаконичным.
+ Улучшенная читабельность: Они могут сделать код более читаемым, особенно в контексте функционального программирования.
+ Гибкость: lambda-выражения могут использоваться в разных контекстах, например, в потоках, событиях и лямбда-выражениях.
+ Функциональное программирование: lambda-выражения позволяют использовать парадигму функционального программирования в Java.

Использование:
+ Обработки событий: в GUI-приложениях и других сценариях обработки событий.
+ Коллекции: для фильтрации, сортировки, преобразования элементов в коллекциях.
+ Потоки: для параллельной обработки данных.
+ Функциональное программирование: для создания функциональных объектов и применения функциональных операций.

[_к оглавлению_](#Оглавление)
#### 2. Что такое функциональные интерфейсы?

Функциональный интерфейс в Java - это интерфейс, который содержит один абстрактный метод.  

Ключевые особенности:
+ Один абстрактный метод: интерфейс может содержать дополнительные методы по умолчанию и статические методы, но должен иметь ровно один абстрактный метод, который должен быть реализован при использовании интерфейса.
+ Аннотация `@FunctionalInterface`:  эта аннотация не является обязательной, но рекомендуется использовать ее, чтобы явно показать, что интерфейс предназначен для использования в функциональном стиле. Компилятор проверяет, что интерфейс действительно соответствует определению функционального интерфейса, и выдает ошибку, если это не так.

Зачем использовать функциональные интерфейсы?
+ Лямбда-выражения:  функциональные интерфейсы позволяют использовать лямбда-выражения, которые являются более кратким и лаконичным способом  определения анонимных функций.
+ Методы ссылок:  функциональные интерфейсы могут использоваться для создания ссылок на методы, что делает код более читаемым и компактным.
+ Функциональное программирование:  функциональные интерфейсы являются ключевой частью функционального программирования в Java, позволяя писать код, который является более чистым, более легким для тестирования и более надежным.

[_к оглавлению_](#Оглавление)
#### 3. Перечислите функциональные интерфейсы из пакета java.util.function.

1. Predicate<T>:

+ Описание: представляет функцию, которая принимает аргумент типа `T` и возвращает `boolean` значение (истина или ложь). 
+ Метод: `boolean test(T t)`
+ Пример: `Predicate<Integer> isEven = x -> x % 2 == 0;`

2. Function<T, R>:

+ Описание: представляет функцию, которая принимает аргумент типа `T` и возвращает результат типа `R`. 
+ Метод: `R apply(T t)`
+ Пример: `Function<String, Integer> stringToInt = Integer::parseInt;`

3. Consumer<T>:

+ Описание: представляет функцию, которая принимает аргумент типа `T` и не возвращает значение. 
+ Метод: `void accept(T t)`
+ Пример: `Consumer<String> printString = System.out::println;`

4. Supplier<T>:

+ Описание: представляет функцию, которая не принимает аргументов и возвращает значение типа `T`.
+ Метод: `T get()`
+ Пример: `Supplier<String> generateRandomString = () -> "randomString";`

5. BiFunction<T, U, R>:

+ Описание: представляет функцию, которая принимает два аргумента типов `T` и `U` и возвращает результат типа `R`. 
+ Метод: `R apply(T t, U u)`
+ Пример: `BiFunction<Integer, Integer, Integer> sum = (x, y) -> x + y;`

6. BiConsumer<T, U>:

+ Описание: представляет функцию, которая принимает два аргумента типов `T` и `U` и не возвращает значение.
+ Метод: `void accept(T t, U u)`
+ Пример: `BiConsumer<String, String> concatStrings = (str1, str2) -> System.out.println(str1 + str2);`

7. BiPredicate<T, U>:

+ Описание: представляет функцию, которая принимает два аргумента типов `T` и `U` и возвращает `boolean` значение.
+ Метод: `boolean test(T t, U u)`
+ Пример: `BiPredicate<String, String> areStringsEqual = (str1, str2) -> str1.equals(str2);`

8. UnaryOperator<T>:

+ Описание:  представляет функцию, которая принимает аргумент типа `T` и возвращает результат того же типа `T`. 
+ Метод: `T apply(T t)`
+ Пример: `UnaryOperator<Integer> square = x -> x  x;`

9. BinaryOperator<T>:

+ Описание: представляет функцию, которая принимает два аргумента типа `T` и возвращает результат того же типа `T`. 
+ Метод: `T apply(T t1, T t2)`
+ Пример: `BinaryOperator<Integer> max = (x, y) -> Math.max(x, y);`

10. Comparator<T>:

+ Описание: представляет функцию, которая сравнивает два аргумента типа `T` и возвращает результат сравнения в виде `int`. 
+ Метод: `int compare(T o1, T o2)`
+ Пример: `Comparator<String> stringComparator = (str1, str2) -> str1.compareToIgnoreCase(str2);`

[_к оглавлению_](#Оглавление)
#### 4. Что такое функции высшего порядка?

Функции высшего порядка (Higher-order functions) – это функции, которые могут принимать другие функции в качестве аргументов или возвращать функции в качестве результата. В Java эта концепция появилась с версии 8 и стала возможной благодаря появлению лямбда-выражений и функциональных интерфейсов.

Основные характеристики:
+ Принимают функции в качестве аргументов: Функция может принимать другую функцию как параметр, позволяя ей выполнять операции с другими функциями.
+ Возвращают функции в качестве результата: Функция может вернуть другую функцию как результат, предоставляя возможность создания новых функций на основе входных данных.

Примеры:

1. Прием функции в качестве аргумента:
```java
import java.util.function.Function;

public class HigherOrderFunctions {

    public static void main(String[] args) {
        // Функция, которая принимает функцию и применяет ее к числу
        Function<Integer, Integer> applyFunction = apply(x -> x  2);
        System.out.println(applyFunction.apply(5)); // Вывод: 10
    }

    // Функция высшего порядка, которая принимает функцию и применяет ее к аргументу
    public static <T> Function<T, T> apply(Function<T, T> function) {
        return function;
    }
}
```
В этом примере функция `apply` принимает функцию `x -> x  2` в качестве аргумента и возвращает ее. Затем эта функция применяется к числу 5.

2. Возврат функции в качестве результата:
```java
import java.util.function.Function;

public class HigherOrderFunctions {

    public static void main(String[] args) {
        // Функция, которая возвращает функцию, умножающую на заданное число
        Function<Integer, Function<Integer, Integer>> multiplier = multiplier(3);
        Function<Integer, Integer> triple = multiplier.apply(5);
        System.out.println(triple.apply(2)); // Вывод: 6
    }

    // Функция высшего порядка, которая возвращает функцию умножения
    public static Function<Integer, Function<Integer, Integer>> multiplier(int factor) {
        return x -> y -> x  y  factor;
    }
}
```
В этом примере функция `multiplier` возвращает другую функцию, которая умножает входное число на `factor`. Эта функция затем применяется к числу 2, умножая его на 3 и 5.

Преимущества использования функций высшего порядка:
+ Повышение читаемости кода: Четко разделяет логику и повышает модульность кода.
+ Улучшение повторного использования кода: Позволяет создавать более универсальные функции, которые можно использовать в различных контекстах.
+ Сокращение количества строк кода: Зачастую позволяет выразить логику в более лаконичном виде.

Важно отметить, что функции высшего порядка в Java не являются полноценными функциями в языках функционального программирования, таких как Haskell или Scala. Однако, они предоставляют мощные инструменты для повышения гибкости и выразительности кода в Java.

[_к оглавлению_](#Оглавление)
#### 5. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?

В пакете `java.util.function` все функциональные интерфейсы поддерживают функции высшего порядка.

Как функциональные интерфейсы поддерживают функции высшего порядка?

Принимая функции в качестве аргументов:
+ Методы `andThen()`, `compose()`, `apply()` в `Function<T, R>` принимают другие функции в качестве аргументов.
+ Методы `and()`, `negate()` в `Predicate<T>` принимают другие предикаты в качестве аргументов.
+ Методы `andThen()`, `compose()` в `Consumer<T>` принимают другие действия в качестве аргументов.
+ Методы `andThen()`, `compose()` в `UnaryOperator<T>` и `BinaryOperator<T>` принимают другие операторы в качестве аргументов.
+ Методы `thenComparing()`, `reversed()` в `Comparator<T>` принимают другие компараторы в качестве аргументов.

Возвращая функции в качестве результата:
+ Методы `andThen()`, `compose()` в `Function<T, R>` возвращают новые функции.
+ Методы `and()`, `negate()` в `Predicate<T>` возвращают новые предикаты.
+ Методы `andThen()`, `compose()` в `Consumer<T>` возвращают новые действия.
+ Методы `andThen()`, `compose()` в `UnaryOperator<T>` и `BinaryOperator<T>` возвращают новые операторы.
+ Методы `thenComparing()`, `reversed()` в `Comparator<T>` возвращают новые компараторы.

Примеры:

```java
// Пример использования andThen() в Function
Function<String, Integer> toInteger = Integer::parseInt;
Function<Integer, String> toString = Object::toString;
Function<String, String> convertToString = toInteger.andThen(toString);
String result = convertToString.apply("123"); // result == "123"

// Пример использования and() в Predicate
Predicate<Integer> isEven = i -> i % 2 == 0;
Predicate<Integer> isPositive = i -> i > 0;
Predicate<Integer> isEvenAndPositive = isEven.and(isPositive);
boolean result = isEvenAndPositive.test(4); // result == true
```

[_к оглавлению_](#Оглавление)
#### 6. Что такое ссылки на методы?

Ссылки на методы (method references) в Java — это  компактный синтаксис для представления ссылки на метод. Они позволяют передавать методы как аргументы в другие методы или хранить их в переменных,  позволяя динамически выбирать и вызывать нужный метод во время выполнения.

Как работают ссылки на методы:

1. Синтаксис: Ссылки на методы записываются с помощью знака двоеточия `::`, который разделяет имя класса и имя метода.
* `ClassName::methodName` - ссылка на статический метод.
* `instanceName::methodName` - ссылка на метод экземпляра.
* `ClassName::new` - ссылка на конструктор.

2. Типы ссылок: 
* Статические методы: ссылка на статический метод указывает на метод, принадлежащий классу, а не конкретному объекту.
* Методы экземпляра:  ссылка на метод экземпляра указывает на метод, который должен быть вызван для конкретного объекта.
* Конструкторы: ссылка на конструктор указывает на процесс создания нового объекта.

3. Использование: ссылки на методы используются в контексте функциональных интерфейсов. Функциональный интерфейс — это интерфейс с одним абстрактным методом. 

Примеры:

1. Ссылка на статический метод:
```java
import java.util.Arrays;
import java.util.List;
import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // Ссылка на статический метод Integer::parseInt
        Function<String, Integer> parseFunction = Integer::parseInt;

        // Применение функции к списку
        List<Integer> parsedNumbers = numbers.stream()
                .map(String::valueOf) // Преобразование в String
                .map(parseFunction) // Применение ссылки на метод
                .toList();

        System.out.println(parsedNumbers); // Вывод: [1, 2, 3, 4, 5]
    }
}
```
2. Ссылка на метод экземпляра:
```java
import java.util.function.Consumer;

class Dog {
    public void bark() {
        System.out.println("Гав-гав!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();

        // Ссылка на метод экземпляра Dog::bark
        Consumer<Dog> barkAction = Dog::bark;

        // Вызов метода bark через ссылку
        barkAction.accept(myDog);
    }
}
```
3. Ссылка на конструктор:
```java
import java.util.function.Supplier;

class Dog {
    public Dog(String name) {
        System.out.println("Собака " + name + " создана!");
    }
}

public class Main {
    public static void main(String[] args) {
        // Ссылка на конструктор Dog::new
        Supplier<Dog> dogSupplier = Dog::new;

        // Создание объекта с помощью ссылки на конструктор
        Dog myDog = dogSupplier.get(); // Вызов конструктора Dog(String name)
    }
}
```

Преимущества ссылок на методы:
* Улучшение читаемости: ссылки на методы делают код более лаконичным и понятным, так как явно указывают на действие, которое нужно выполнить.
* Увеличение гибкости: ссылки на методы позволяют динамически выбирать методы для выполнения в зависимости от условий.
* Совместимость с лямбда-выражениями: ссылки на методы могут использоваться вместе с лямбда-выражениями, обеспечивая гибкость в работе с функциональными интерфейсами.

[_к оглавлению_](#Оглавление)
#### 7. Что такое ссылки на конструкторы?

[см. п. 6](#6-Что-такое-ссылки-на-методы)

[_к оглавлению_](#Оглавление)
#### 8. Расскажите о зоне видимости переменных в lambda-выражениях?

Лямбда-выражения в Java имеют свои нюансы, касающиеся области видимости переменных. 

Основные правила:

1. Доступ к переменным из внешнего контекста: Лямбда-выражения могут читать переменные, объявленные в окружающем их контексте (методе, классе, блоке кода). 

2. Изменение значений: Однако лямбда-выражения могут изменять значения только эффективно-финальных переменных (effectively final). Это означает, что переменная должна быть либо явно объявлена как `final`, либо фактически не переназначена в лямбда-выражении.

Примеры:
```java
// Правильный пример: использование финальной переменной
int x = 5;
Runnable r1 = () -> System.out.println(x); // x - финальная, доступна

// Неправильный пример: попытка переназначения переменной 
int y = 5;
Runnable r2 = () -> {
    y = 10; // Ошибка компиляции: y не финальная
    System.out.println(y);
};
```

Объяснение:
* Финальность и неизменяемость:  Финальные переменные в Java не могут быть переназначены после инициализации. Это означает, что их значение остается неизменным на протяжении всего времени жизни программы.
* Контекст лямбды:  Лямбда-выражения "захватывают" (capture) переменные из своего контекста. Когда лямбда-выражение выполняется, она использует  те же значения переменных, которые были доступны во время ее создания.

Почему это важно?
* Безопасность потоков:  Это правило гарантирует потоковую безопасность, так как лямбда-выражения не могут случайно изменить значения переменных, используемых в других потоках.
* Читаемость и предсказуемость: Это правило делает код более читаемым и предсказуемым, так как гарантирует, что переменные, используемые в лямбда-выражении, не будут изменены извне.

Пример с использованием локальной переменной в лямбде:
```java
public class Main {
    public static void main(String[] args) {
        int counter = 0;

        Runnable r = () -> {
            System.out.println("Counter: " + counter); 
            counter++; // Ошибка компиляции: counter не финальная
        };

        r.run();
    }
}
```

Решения:
* Использовать `final`:  Объявить переменную как `final`, чтобы ее значение было неизменяемым.
* Создать новую переменную:  Создать новую переменную внутри лямбда-выражения, чтобы использовать ее для хранения изменяемого значения.

Важно:
* Лямбда-выражения не могут создавать новые переменные в своем контексте, они могут только использовать переменные из окружающего контекста.
* Лямбда-выражения не могут  изменять переменные, объявленные в `for`-цикле, если они не финальные или не фактически финальные.

[_к оглавлению_](#Оглавление)
#### 9. Как быть в ситуации, если внутри lambda-выражения операторы могут выкинуть исключение?

В лямбда-выражениях в Java обработка исключений имеет свои особенности. Вот несколько подходов к решению ситуации, когда операторы внутри лямбда-выражения могут выкинуть исключение:

1. Использование `throws`:

* Описание: самый простой подход — объявить, что лямбда-выражение может выбросить исключение, используя ключевое слово `throws` в сигнатуре метода, который принимает лямбду.
* Пример:
```java
import java.util.function.Consumer;

public class Main {
    public static void main(String[] args) {
        Consumer<Integer> myConsumer = (x) -> {
            if (x == 0) {
                throw new ArithmeticException("Деление на ноль!");
            }
        };

        try {
            myConsumer.accept(0); // Выброс исключения
        } catch (ArithmeticException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }
}
```

* Недостатки:  этот подход не подходит, если лямбда-выражение передается методу, который не объявляет `throws` для этого исключения.

2. Обработка исключений внутри лямбды:

* Описание: можно обработать исключение непосредственно внутри лямбда-выражения с помощью блока `try-catch`.
* Пример:
```java
import java.util.function.Consumer;

public class Main {
    public static void main(String[] args) {
        Consumer<Integer> myConsumer = (x) -> {
            try {
                if (x == 0) {
                    throw new ArithmeticException("Деление на ноль!");
                }
            } catch (ArithmeticException e) {
                System.out.println("Ошибка: " + e.getMessage());
            }
        };

        myConsumer.accept(0); 
    }
}
```java

* Недостатки:  может сделать код менее читаемым, особенно если обработка исключений сложная.

3. Использование `Optional`:
* Описание:  если лямбда-выражение может вернуть значение, которое может быть `null`,  можно использовать `Optional` для явной обработки ситуации `null`.
* Пример:
```java
import java.util.Optional;
import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        Function<String, Optional<Integer>> parseFunction = (str) -> {
            try {
                return Optional.of(Integer.parseInt(str));
            } catch (NumberFormatException e) {
                return Optional.empty();
            }
        };

        Optional<Integer> result = parseFunction.apply("123"); // Возвращает Optional<Integer>
        if (result.isPresent()) {
            System.out.println("Результат: " + result.get());
        } else {
            System.out.println("Не удалось преобразовать в число.");
        }
    }
}
```

4. Использование `CheckedException`:

* Описание: если лямбда-выражение может выбросить проверенное исключение (CheckedException), то можно обернуть его в `RuntimeException` с помощью метода `RuntimeException.wrap`.
* Пример:
```java
import java.io.IOException;
import java.util.function.Supplier;

public class Main {
    public static void main(String[] args) {
        Supplier<String> supplier = () -> {
            throw new IOException("Ошибка ввода-вывода.");
        };

        try {
            String result = supplier.get(); 
        } catch (RuntimeException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }
}
```

Дополнительные советы:

* Общий подход: в идеале, обработка исключений должна быть централизованной и  проводиться на уровне более высокого уровня абстракции, а не внутри лямбда-выражений.
* Проверка на `null`:   при использовании `Optional`  следует не забывать проверять на `null`  результаты  после  вызова `get()`, чтобы избежать `NullPointerException`.
* Выбор метода:  выбор  подхода зависит от конкретной ситуации и контекста, где используется лямбда-выражение.

[_к оглавлению_](#Оглавление)
#### 10. Что такое Stream API?

Stream API - это интерфейс, который позволяет работать с коллекциями в режиме потока данных. Это мощный инструмент для работы с последовательностями данных (коллекциями, массивами и т.д.)  с помощью функционального программирования.  Он позволяет  проводить  операции  над  данными  в  лаконичном  и  читабельном  виде,  не  затрагивая  исходные  данные.

***Ключевые концепции Stream API:***

1. Поток (Stream):  Представляет последовательность элементов, над которыми можно выполнять операции. Потоки неизменяемы: они не изменяют исходные данные.
2. Операции:  Stream API предлагает  два типа  операций:
  * Промежуточные операции (Intermediate operations): Возвращают новый поток, преобразуя исходный, но не выполняют никаких действий с данными.
  * Терминальные операции (Terminal operations): Выполняют действия с данными и возвращают результат или ничего не возвращают.
3. Лямбда-выражения:  Stream API широко использует лямбда-выражения для задания  логики  обработки  данных  в  операциях.

***Преимущества Stream API:***
* Читаемость:  Код с использованием Stream API становится более  читаемым  и  лаконичным,  так  как  описывает  логику  обработки  данных  на  высоком  уровне.
* Функциональность:  Stream API  предоставляет  широкий  спектр  операций  для  фильтрации,  сортировки,  маппинга,  группировки,  слияния  и  других  задач  над  данными.
* Параллелизм:  Потоки  могут  быть  обработаны  параллельно,  что  увеличивает  скорость  вычислений.
* Неизменяемость:  Потоки  неизменяемы,  что  гарантирует  потоковую  безопасность  и  делает  код  более  предсказуемым.

Пример использования Stream API:
```java
import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // Фильтрация: оставьте только четные числа
        List<Integer> evenNumbers = numbers.stream()
                .filter(n -> n % 2 == 0)
                .toList(); // Создание нового списка с результатом

        // Преобразование: умножьте каждый элемент на 2
        List<Integer> doubledNumbers = numbers.stream()
                .map(n -> n * 2)
                .toList();

        // Сортировка: отсортируйте по возрастанию
        List<Integer> sortedNumbers = numbers.stream()
                .sorted()
                .toList();

        // Суммирование: посчитайте сумму всех элементов
        int sum = numbers.stream()
                .reduce(0, Integer::sum); // Использование reduce для суммирования

        System.out.println("Четные числа: " + evenNumbers);
        System.out.println("Удвоенные числа: " + doubledNumbers);
        System.out.println("Отсортированные числа: " + sortedNumbers);
        System.out.println("Сумма: " + sum);
    }
}
```

***Основные операции Stream API:***
* `filter()`:  отбирает элементы, удовлетворяющие условию.
* `map()`:  преобразует  каждый  элемент  потока  в  новый  элемент.
* `sorted()`:  сортирует  элементы  потока.
* `reduce()`:  сводит  поток  к  одному  значению.
* `collect()`:  сбирает  результат  операций  в  новую  коллекцию.
* `forEach()`:  выполняет  действие  для  каждого  элемента  потока.
* `findFirst()`:  возвращает  первый  элемент  потока.

[_к оглавлению_](#Оглавление)
#### 11. Расскажите, какие шаблоны проектирования используются внутри Stream API? (Builder, Strategy, Decorator, Factory Method, Pipeline).



[_к оглавлению_](#Оглавление)
#### 12. Объясните, где они используются в Stream API.



[_к оглавлению_](#Оглавление)
#### 13. Что такое конвейерные (промежуточные) и терминальные операции?

Stream API в Java позволяет выполнять операции над последовательностями данных (например, коллекциями) с помощью потока. Для этого используются два типа операций: промежуточные (конвейерные) и терминальные.

Конвейерные (промежуточные) операции:

+ Не модифицируют исходный поток данных. Они создают новый поток, применяя преобразование к элементам исходного потока.
+ Являются "ленивыми". Они не выполняются сразу, а только при вызове терминальной операции.
+ Возвращают новый объект Stream.

Терминальные операции:

+ Выполняют окончательное действие над потоком данных.
+ Возвращают результат операции, который не является объектом Stream.
+ Вызывают выполнение всех предыдущих промежуточных операций.

Важно:

+ Промежуточные операции можно цепочкой соединять, создавая конвейер преобразований данных. Промежуточных операций может быть много в потоке.
+ Терминальная операция должна быть последней в цепочке операций (может быть единственной в потоке).
+ Конвейерные (промежуточные) операции выполняются лениво, то есть обработка элементов происходит только при вызове терминальной операции.

[_к оглавлению_](#Оглавление)
#### 14. Перечислите конвейерные (промежуточные) методы Stream API.

1. Преобразование:

+ map(Function mapper): преобразует каждый элемент потока, применяя заданную функцию.
+ flatMap(Function mapper): преобразует каждый элемент потока в поток элементов, а затем объединяет все получившиеся потоки в один.
+ distinct(): удаляет дубликаты из потока.
+ sorted(): сортирует элементы потока по возрастанию.
+ sorted(Comparator comparator): сортирует элементы потока с помощью заданного компаратора.
+ peek(Consumer action): выполняет заданное действие для каждого элемента потока.

2. Фильтрация:

+ filter(Predicate predicate): оставляет в потоке только элементы, удовлетворяющие заданному предикату.
+ limit(long maxSize): оставляет в потоке не более заданного количества элементов.
+ skip(long n): пропускает первые n элементов потока.

[_к оглавлению_](#Оглавление)
#### 15. Перечислите терминальные методы Stream API.



[_к оглавлению_](#Оглавление)
#### 16. Что такое отложенное выполнение lamdba?



[_к оглавлению_](#Оглавление)
#### 17. Что делает метод filter()?



[_к оглавлению_](#Оглавление)
#### 18. Что делает метод map()?



[_к оглавлению_](#Оглавление)
#### 19. Что делает метод flatMap()?



[_к оглавлению_](#Оглавление)
#### 20. Что делает метод collect()?



[_к оглавлению_](#Оглавление)
#### 21. Что делает метод findFirst()?



[_к оглавлению_](#Оглавление)
#### 22. Что делает метод reduce()?



[_к оглавлению_](#Оглавление)
#### 23. Что делают методы min() и max()?



[_к оглавлению_](#Оглавление)
#### 24. Что делают методы count(), sum(), average()?



[_к оглавлению_](#Оглавление)
#### 25. Что делают методы forEach() и peek()?



[_к оглавлению_](#Оглавление)
#### 26. Что делают методы skip() и limit()?



[_к оглавлению_](#Оглавление)
#### 27. Что делают методы allMatch(), noneMatch() и anyMatch()?



[_к оглавлению_](#Оглавление)
#### 28. Что делают методы mapToInt(), flatMapToInt(), mapToObj()?



[_к оглавлению_](#Оглавление)
#### 29. Что такое числовой поток?



[_к оглавлению_](#Оглавление)
#### 30. Чем отличается Stream(Integer) от IntStream(int)?



[_к оглавлению_](#Оглавление)
#### 31. Что делает метод boxed()?



[_к оглавлению_](#Оглавление)
#### 32. Возможно ли прервать выполнение потока по аналогии с break?



[_к оглавлению_](#Оглавление)
#### 33. Возможно ли пропустить элемент потока по аналогии с continue?



[_к оглавлению_](#Оглавление)
#### 34. Что такое Optional?



[_к оглавлению_](#Оглавление)
#### 35. Перечислите методы Optional.



[_к оглавлению_](#Оглавление)
#### 36. Расскажите про фабричные методы List.of(), Set.of(), Map.of()?

В Java 9 были добавлены фабричные методы для создания неизменяемых коллекций: `List.of()`, `Set.of()`, `Map.of()`. 

Преимущества фабричных методов:

+ Неизменяемость: cозданные коллекции неизменяемы, то есть их содержимое нельзя изменить после создания. Это обеспечивает безопасность данных и предотвращает непредвиденные изменения.
+ Простота использования: код становится более лаконичным и читаемым, так как нет необходимости создавать отдельные объекты коллекций и заполнять их элементами.
+ Эффективность: фабричные методы оптимизированы для создания неизменяемых коллекций, что делает их более эффективными, чем создание стандартных коллекций.

Примеры использования:

List.of()

```java
List<String> names = List.of("John", "Jane", "Peter");
```

Set.of()

```java
Set<Integer> numbers = Set.of(1, 2, 3, 4, 5);
```

Map.of()

```java
Map<String, Integer> ages = Map.of("John", 30, "Jane", 25, "Peter", 28);
```

Важные моменты:
+ Фабричные методы не работают с примитивными типами данных. Используйте автоупаковку или `Arrays.asList()` для создания списка из примитивов.
+ Для создания пустой коллекции используйте `Collections.emptyList()`, `Collections.emptySet()` и `Collections.emptyMap()`.
+ Фабричные методы могут быть использованы только для создания неизменяемых коллекций. 

Недостатки:
+ Невозможность изменить созданную коллекцию может быть ограничением в некоторых сценариях.

[_к оглавлению_](#Оглавление)
#### 37. Для чего используется var?



[_к оглавлению_](#Оглавление)
#### 38. В каких случаях можно использовать var?



[_к оглавлению_](#Оглавление)
