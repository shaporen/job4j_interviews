##### [job4j_interviews](https://github.com/shaporen/job4j_interviews/blob/main/README.md)
#### Оглавление
+ [1. Что такое lambda-выражение?](#1-Что-такое-lambda-выражение)
+ [2. Что такое функциональные интерфейсы?](#2-Что-такое-функциональные-интерфейсы)
+ [3. Перечислите функциональные интерфейсы из пакета java.util.function.](#3-Перечислите-функциональные-интерфейсы-из-пакета-javautilfunction)
+ [4. Что такое функции высшего порядка?](#4-Что-такое-функции-высшего-порядка)
+ [5. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?](#5-Какие-функциональные-интерфейсы-из-пакета-javautilfunction-поддерживают-функции-высшего-порядка)
+ [6. Что такое ссылки на методы?](#6-Что-такое-ссылки-на-методы)
+ [7. Что такое ссылки на конструкторы?](#7-Что-такое-ссылки-на-конструкторы)
+ [8. Расскажите о зоне видимости переменных в lambda-выражениях?](#8-Расскажите-о-зоне-видимости-переменных-в-lambda-выражениях)
+ [9. Как быть в ситуации, если внутри lambda-выражения операторы могут выкинуть исключение?](#9-Как-быть-в-ситуации-если-внутри-lambda-выражения-операторы-могут-выкинуть-исключение)
+ [10. Что такое Stream API?](#10-Что-такое-Stream-API)
+ [11. Расскажите, какие шаблоны проектирования используются внутри Stream API? (Builder, Strategy, Decorator, Factory Method, Pipeline).](#11-Расскажите-какие-шаблоны-проектирования-используются-внутри-Stream-API-Builder-Strategy-Decorator-Factory-Method-Pipeline)
+ [12. Объясните, где они используются в Stream API.](#12-Объясните-где-они-используются-в-Stream-API)
+ [13. Что такое конвейерные (промежуточные) и терминальные операции?](#13-Что-такое-конвейерные-промежуточные-и-терминальные-операции)
+ [14. Перечислите конвейерные (промежуточные) методы Stream API.](#14-Перечислите-конвейерные-промежуточные-методы-Stream-API)
+ [15. Перечислите терминальные методы Stream API.](#15-Перечислите-терминальные-методы-Stream-API)
+ [16. Что такое отложенное выполнение lamdba?](#16-Что-такое-отложенное-выполнение-lamdba)
+ [17. Что делает метод filter()?](#17-Что-делает-метод-filter)
+ [18. Что делает метод map()?](#18-Что-делает-метод-map)
+ [19. Что делает метод flatMap()?](#19-Что-делает-метод-flatMap)
+ [20. Что делает метод collect()?](#20-Что-делает-метод-collect)
+ [21. Что делает метод findFirst()?](#21-Что-делает-метод-findFirst)
+ [22. Что делает метод reduce()?](#22-Что-делает-метод-reduce)
+ [23. Что делают методы min() и max()?](#23-Что-делают-методы-min-и-max)
+ [24. Что делают методы count(), sum(), average()?](#24-Что-делают-методы-count-sum-average)
+ [25. Что делают методы forEach() и peek()?](#25-Что-делают-методы-forEach-и-peek)
+ [26. Что делают методы skip() и limit()?](#26-Что-делают-методы-skip-и-limit)
+ [27. Что делают методы allMatch(), noneMatch() и anyMatch()?](#27-Что-делают-методы-allMatch-noneMatch-и-anyMatch)
+ [28. Что делают методы mapToInt(), flatMapToInt(), mapToObj()?](#28-Что-делают-методы-mapToInt-flatMapToInt-mapToObj)
+ [29. Что такое числовой поток?](#29-Что-такое-числовой-поток)
+ [30. Чем отличается Stream(Integer) от IntStream(int)?](#30-Чем-отличается-StreamInteger-от-IntStreamint)
+ [31. Что делает метод boxed()?](#31-Что-делает-метод-boxed)
+ [32. Возможно ли прервать выполнение потока по аналогии с break?](#32-Возможно-ли-прервать-выполнение-потока-по-аналогии-с-break)
+ [33. Возможно ли пропустить элемент потока по аналогии с continue?](#33-Возможно-ли-пропустить-элемент-потока-по-аналогии-с-continue)
+ [34. Что такое Optional?](#34-Что-такое-Optional)
+ [35. Перечислите методы Optional.](#35-Перечислите-методы-Optional)
+ [36. Расскажите про фабричные методы List.of(), Set.of(), Map.of()?](#36-Расскажите-про-фабричные-методы-Listof-Setof-Mapof)
+ [37. Для чего используется var?](#37-Для-чего-используется-var)
+ [38. В каких случаях можно использовать var?](#38-В-каких-случаях-можно-использовать-var)

#### 1. Что такое lambda-выражение?

Lambda-выражение — это анонимная функция в Java, которая может быть использована для краткого и лаконичного представления функционального интерфейса. 

Ключевые особенности:
+ Анонимность: lambda-выражения не имеют имени и не объявляются как отдельные методы.
+ Функциональный интерфейс: lambda-выражения должны соответствовать одному функциональному интерфейсу (интерфейсу с одним абстрактным методом).
+ Компактность: они предоставляют краткий и удобный способ выражения функциональности без необходимости создания отдельных классов или методов.
+ Более читаемый код: lambda-выражения могут сделать код более читабельным, особенно в контексте событийных обработчиков, коллекций и потоков.

Синтаксис:

```java
(параметры) -> { тело выражения }
```

Пример:

```java
// Интерфейс с одним абстрактным методом
interface MathOperation {
  int operation(int a, int b);
}

// Lambda-выражение, реализующее интерфейс MathOperation
MathOperation addition = (a, b) -> a + b;

// Использование lambda-выражения
int result = addition.operation(5, 3); // result = 8
```

Преимущества:
+ Сокращение кода: lambda-выражения делают код более кратким и лаконичным.
+ Улучшенная читабельность: Они могут сделать код более читаемым, особенно в контексте функционального программирования.
+ Гибкость: lambda-выражения могут использоваться в разных контекстах, например, в потоках, событиях и лямбда-выражениях.
+ Функциональное программирование: lambda-выражения позволяют использовать парадигму функционального программирования в Java.

Использование:
+ Обработки событий: в GUI-приложениях и других сценариях обработки событий.
+ Коллекции: для фильтрации, сортировки, преобразования элементов в коллекциях.
+ Потоки: для параллельной обработки данных.
+ Функциональное программирование: для создания функциональных объектов и применения функциональных операций.

[_к оглавлению_](#Оглавление)
#### 2. Что такое функциональные интерфейсы?

Функциональный интерфейс в Java - это интерфейс, который содержит один абстрактный метод.  

Ключевые особенности:
+ Один абстрактный метод: интерфейс может содержать дополнительные методы по умолчанию и статические методы, но должен иметь ровно один абстрактный метод, который должен быть реализован при использовании интерфейса.
+ Аннотация `@FunctionalInterface`:  эта аннотация не является обязательной, но рекомендуется использовать ее, чтобы явно показать, что интерфейс предназначен для использования в функциональном стиле. Компилятор проверяет, что интерфейс действительно соответствует определению функционального интерфейса, и выдает ошибку, если это не так.

Зачем использовать функциональные интерфейсы?
+ Лямбда-выражения:  функциональные интерфейсы позволяют использовать лямбда-выражения, которые являются более кратким и лаконичным способом  определения анонимных функций.
+ Методы ссылок:  функциональные интерфейсы могут использоваться для создания ссылок на методы, что делает код более читаемым и компактным.
+ Функциональное программирование:  функциональные интерфейсы являются ключевой частью функционального программирования в Java, позволяя писать код, который является более чистым, более легким для тестирования и более надежным.

[_к оглавлению_](#Оглавление)
#### 3. Перечислите функциональные интерфейсы из пакета java.util.function.

1. Predicate<T>:

+ Описание: представляет функцию, которая принимает аргумент типа `T` и возвращает `boolean` значение (истина или ложь). 
+ Метод: `boolean test(T t)`
+ Пример: `Predicate<Integer> isEven = x -> x % 2 == 0;`

2. Function<T, R>:

+ Описание: представляет функцию, которая принимает аргумент типа `T` и возвращает результат типа `R`. 
+ Метод: `R apply(T t)`
+ Пример: `Function<String, Integer> stringToInt = Integer::parseInt;`

3. Consumer<T>:

+ Описание: представляет функцию, которая принимает аргумент типа `T` и не возвращает значение. 
+ Метод: `void accept(T t)`
+ Пример: `Consumer<String> printString = System.out::println;`

4. Supplier<T>:

+ Описание: представляет функцию, которая не принимает аргументов и возвращает значение типа `T`.
+ Метод: `T get()`
+ Пример: `Supplier<String> generateRandomString = () -> "randomString";`

5. BiFunction<T, U, R>:

+ Описание: представляет функцию, которая принимает два аргумента типов `T` и `U` и возвращает результат типа `R`. 
+ Метод: `R apply(T t, U u)`
+ Пример: `BiFunction<Integer, Integer, Integer> sum = (x, y) -> x + y;`

6. BiConsumer<T, U>:

+ Описание: представляет функцию, которая принимает два аргумента типов `T` и `U` и не возвращает значение.
+ Метод: `void accept(T t, U u)`
+ Пример: `BiConsumer<String, String> concatStrings = (str1, str2) -> System.out.println(str1 + str2);`

7. BiPredicate<T, U>:

+ Описание: представляет функцию, которая принимает два аргумента типов `T` и `U` и возвращает `boolean` значение.
+ Метод: `boolean test(T t, U u)`
+ Пример: `BiPredicate<String, String> areStringsEqual = (str1, str2) -> str1.equals(str2);`

8. UnaryOperator<T>:

+ Описание:  представляет функцию, которая принимает аргумент типа `T` и возвращает результат того же типа `T`. 
+ Метод: `T apply(T t)`
+ Пример: `UnaryOperator<Integer> square = x -> x  x;`

9. BinaryOperator<T>:

+ Описание: представляет функцию, которая принимает два аргумента типа `T` и возвращает результат того же типа `T`. 
+ Метод: `T apply(T t1, T t2)`
+ Пример: `BinaryOperator<Integer> max = (x, y) -> Math.max(x, y);`

10. Comparator<T>:

+ Описание: представляет функцию, которая сравнивает два аргумента типа `T` и возвращает результат сравнения в виде `int`. 
+ Метод: `int compare(T o1, T o2)`
+ Пример: `Comparator<String> stringComparator = (str1, str2) -> str1.compareToIgnoreCase(str2);`

[_к оглавлению_](#Оглавление)
#### 4. Что такое функции высшего порядка?

Функции высшего порядка (Higher-order functions) – это функции, которые могут принимать другие функции в качестве аргументов или возвращать функции в качестве результата. В Java эта концепция появилась с версии 8 и стала возможной благодаря появлению лямбда-выражений и функциональных интерфейсов.

Основные характеристики:
+ Принимают функции в качестве аргументов: Функция может принимать другую функцию как параметр, позволяя ей выполнять операции с другими функциями.
+ Возвращают функции в качестве результата: Функция может вернуть другую функцию как результат, предоставляя возможность создания новых функций на основе входных данных.

Примеры:

1. Прием функции в качестве аргумента:
```java
import java.util.function.Function;

public class HigherOrderFunctions {

    public static void main(String[] args) {
        // Функция, которая принимает функцию и применяет ее к числу
        Function<Integer, Integer> applyFunction = apply(x -> x  2);
        System.out.println(applyFunction.apply(5)); // Вывод: 10
    }

    // Функция высшего порядка, которая принимает функцию и применяет ее к аргументу
    public static <T> Function<T, T> apply(Function<T, T> function) {
        return function;
    }
}
```
В этом примере функция `apply` принимает функцию `x -> x  2` в качестве аргумента и возвращает ее. Затем эта функция применяется к числу 5.

2. Возврат функции в качестве результата:
```java
import java.util.function.Function;

public class HigherOrderFunctions {

    public static void main(String[] args) {
        // Функция, которая возвращает функцию, умножающую на заданное число
        Function<Integer, Function<Integer, Integer>> multiplier = multiplier(3);
        Function<Integer, Integer> triple = multiplier.apply(5);
        System.out.println(triple.apply(2)); // Вывод: 6
    }

    // Функция высшего порядка, которая возвращает функцию умножения
    public static Function<Integer, Function<Integer, Integer>> multiplier(int factor) {
        return x -> y -> x  y  factor;
    }
}
```
В этом примере функция `multiplier` возвращает другую функцию, которая умножает входное число на `factor`. Эта функция затем применяется к числу 2, умножая его на 3 и 5.

Преимущества использования функций высшего порядка:
+ Повышение читаемости кода: Четко разделяет логику и повышает модульность кода.
+ Улучшение повторного использования кода: Позволяет создавать более универсальные функции, которые можно использовать в различных контекстах.
+ Сокращение количества строк кода: Зачастую позволяет выразить логику в более лаконичном виде.

Важно отметить, что функции высшего порядка в Java не являются полноценными функциями в языках функционального программирования, таких как Haskell или Scala. Однако, они предоставляют мощные инструменты для повышения гибкости и выразительности кода в Java.

[_к оглавлению_](#Оглавление)
#### 5. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?

В пакете `java.util.function` все функциональные интерфейсы поддерживают функции высшего порядка.

Как функциональные интерфейсы поддерживают функции высшего порядка?

Принимая функции в качестве аргументов:
+ Методы `andThen()`, `compose()`, `apply()` в `Function<T, R>` принимают другие функции в качестве аргументов.
+ Методы `and()`, `negate()` в `Predicate<T>` принимают другие предикаты в качестве аргументов.
+ Методы `andThen()`, `compose()` в `Consumer<T>` принимают другие действия в качестве аргументов.
+ Методы `andThen()`, `compose()` в `UnaryOperator<T>` и `BinaryOperator<T>` принимают другие операторы в качестве аргументов.
+ Методы `thenComparing()`, `reversed()` в `Comparator<T>` принимают другие компараторы в качестве аргументов.

Возвращая функции в качестве результата:
+ Методы `andThen()`, `compose()` в `Function<T, R>` возвращают новые функции.
+ Методы `and()`, `negate()` в `Predicate<T>` возвращают новые предикаты.
+ Методы `andThen()`, `compose()` в `Consumer<T>` возвращают новые действия.
+ Методы `andThen()`, `compose()` в `UnaryOperator<T>` и `BinaryOperator<T>` возвращают новые операторы.
+ Методы `thenComparing()`, `reversed()` в `Comparator<T>` возвращают новые компараторы.

Примеры:

```java
// Пример использования andThen() в Function
Function<String, Integer> toInteger = Integer::parseInt;
Function<Integer, String> toString = Object::toString;
Function<String, String> convertToString = toInteger.andThen(toString);
String result = convertToString.apply("123"); // result == "123"

// Пример использования and() в Predicate
Predicate<Integer> isEven = i -> i % 2 == 0;
Predicate<Integer> isPositive = i -> i > 0;
Predicate<Integer> isEvenAndPositive = isEven.and(isPositive);
boolean result = isEvenAndPositive.test(4); // result == true
```

[_к оглавлению_](#Оглавление)
#### 6. Что такое ссылки на методы?

Ссылки на методы (method references) в Java — это  компактный синтаксис для представления ссылки на метод. Они позволяют передавать методы как аргументы в другие методы или хранить их в переменных,  позволяя динамически выбирать и вызывать нужный метод во время выполнения.

Как работают ссылки на методы:

1. Синтаксис: Ссылки на методы записываются с помощью знака двоеточия `::`, который разделяет имя класса и имя метода.
* `ClassName::methodName` - ссылка на статический метод.
* `instanceName::methodName` - ссылка на метод экземпляра.
* `ClassName::new` - ссылка на конструктор.

2. Типы ссылок: 
* Статические методы: ссылка на статический метод указывает на метод, принадлежащий классу, а не конкретному объекту.
* Методы экземпляра:  ссылка на метод экземпляра указывает на метод, который должен быть вызван для конкретного объекта.
* Конструкторы: ссылка на конструктор указывает на процесс создания нового объекта.

3. Использование: ссылки на методы используются в контексте функциональных интерфейсов. Функциональный интерфейс — это интерфейс с одним абстрактным методом. 

Примеры:

1. Ссылка на статический метод:
```java
import java.util.Arrays;
import java.util.List;
import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // Ссылка на статический метод Integer::parseInt
        Function<String, Integer> parseFunction = Integer::parseInt;

        // Применение функции к списку
        List<Integer> parsedNumbers = numbers.stream()
                .map(String::valueOf) // Преобразование в String
                .map(parseFunction) // Применение ссылки на метод
                .toList();

        System.out.println(parsedNumbers); // Вывод: [1, 2, 3, 4, 5]
    }
}
```
2. Ссылка на метод экземпляра:
```java
import java.util.function.Consumer;

class Dog {
    public void bark() {
        System.out.println("Гав-гав!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();

        // Ссылка на метод экземпляра Dog::bark
        Consumer<Dog> barkAction = Dog::bark;

        // Вызов метода bark через ссылку
        barkAction.accept(myDog);
    }
}
```
3. Ссылка на конструктор:
```java
import java.util.function.Supplier;

class Dog {
    public Dog(String name) {
        System.out.println("Собака " + name + " создана!");
    }
}

public class Main {
    public static void main(String[] args) {
        // Ссылка на конструктор Dog::new
        Supplier<Dog> dogSupplier = Dog::new;

        // Создание объекта с помощью ссылки на конструктор
        Dog myDog = dogSupplier.get(); // Вызов конструктора Dog(String name)
    }
}
```

Преимущества ссылок на методы:
* Улучшение читаемости: ссылки на методы делают код более лаконичным и понятным, так как явно указывают на действие, которое нужно выполнить.
* Увеличение гибкости: ссылки на методы позволяют динамически выбирать методы для выполнения в зависимости от условий.
* Совместимость с лямбда-выражениями: ссылки на методы могут использоваться вместе с лямбда-выражениями, обеспечивая гибкость в работе с функциональными интерфейсами.

[_к оглавлению_](#Оглавление)
#### 7. Что такое ссылки на конструкторы?

[см. п. 6](#6-Что-такое-ссылки-на-методы)

[_к оглавлению_](#Оглавление)
#### 8. Расскажите о зоне видимости переменных в lambda-выражениях?

Лямбда-выражения в Java имеют свои нюансы, касающиеся области видимости переменных. 

Основные правила:

1. Доступ к переменным из внешнего контекста: Лямбда-выражения могут читать переменные, объявленные в окружающем их контексте (методе, классе, блоке кода). 

2. Изменение значений: Однако лямбда-выражения могут изменять значения только эффективно-финальных переменных (effectively final). Это означает, что переменная должна быть либо явно объявлена как `final`, либо фактически не переназначена в лямбда-выражении.

Примеры:
```java
// Правильный пример: использование финальной переменной
int x = 5;
Runnable r1 = () -> System.out.println(x); // x - финальная, доступна

// Неправильный пример: попытка переназначения переменной 
int y = 5;
Runnable r2 = () -> {
    y = 10; // Ошибка компиляции: y не финальная
    System.out.println(y);
};
```

Объяснение:
* Финальность и неизменяемость:  Финальные переменные в Java не могут быть переназначены после инициализации. Это означает, что их значение остается неизменным на протяжении всего времени жизни программы.
* Контекст лямбды:  Лямбда-выражения "захватывают" (capture) переменные из своего контекста. Когда лямбда-выражение выполняется, она использует  те же значения переменных, которые были доступны во время ее создания.

Почему это важно?
* Безопасность потоков:  Это правило гарантирует потоковую безопасность, так как лямбда-выражения не могут случайно изменить значения переменных, используемых в других потоках.
* Читаемость и предсказуемость: Это правило делает код более читаемым и предсказуемым, так как гарантирует, что переменные, используемые в лямбда-выражении, не будут изменены извне.

Пример с использованием локальной переменной в лямбде:
```java
public class Main {
    public static void main(String[] args) {
        int counter = 0;

        Runnable r = () -> {
            System.out.println("Counter: " + counter); 
            counter++; // Ошибка компиляции: counter не финальная
        };

        r.run();
    }
}
```

Решения:
* Использовать `final`:  Объявить переменную как `final`, чтобы ее значение было неизменяемым.
* Создать новую переменную:  Создать новую переменную внутри лямбда-выражения, чтобы использовать ее для хранения изменяемого значения.

Важно:
* Лямбда-выражения не могут создавать новые переменные в своем контексте, они могут только использовать переменные из окружающего контекста.
* Лямбда-выражения не могут  изменять переменные, объявленные в `for`-цикле, если они не финальные или не фактически финальные.

[_к оглавлению_](#Оглавление)
#### 9. Как быть в ситуации, если внутри lambda-выражения операторы могут выкинуть исключение?

В лямбда-выражениях в Java обработка исключений имеет свои особенности. Вот несколько подходов к решению ситуации, когда операторы внутри лямбда-выражения могут выкинуть исключение:

1. Использование `throws`:

* Описание: самый простой подход — объявить, что лямбда-выражение может выбросить исключение, используя ключевое слово `throws` в сигнатуре метода, который принимает лямбду.
* Пример:
```java
import java.util.function.Consumer;

public class Main {
    public static void main(String[] args) {
        Consumer<Integer> myConsumer = (x) -> {
            if (x == 0) {
                throw new ArithmeticException("Деление на ноль!");
            }
        };

        try {
            myConsumer.accept(0); // Выброс исключения
        } catch (ArithmeticException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }
}
```

* Недостатки:  этот подход не подходит, если лямбда-выражение передается методу, который не объявляет `throws` для этого исключения.

2. Обработка исключений внутри лямбды:

* Описание: можно обработать исключение непосредственно внутри лямбда-выражения с помощью блока `try-catch`.
* Пример:
```java
import java.util.function.Consumer;

public class Main {
    public static void main(String[] args) {
        Consumer<Integer> myConsumer = (x) -> {
            try {
                if (x == 0) {
                    throw new ArithmeticException("Деление на ноль!");
                }
            } catch (ArithmeticException e) {
                System.out.println("Ошибка: " + e.getMessage());
            }
        };

        myConsumer.accept(0); 
    }
}
```java

* Недостатки:  может сделать код менее читаемым, особенно если обработка исключений сложная.

3. Использование `Optional`:
* Описание:  если лямбда-выражение может вернуть значение, которое может быть `null`,  можно использовать `Optional` для явной обработки ситуации `null`.
* Пример:
```java
import java.util.Optional;
import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        Function<String, Optional<Integer>> parseFunction = (str) -> {
            try {
                return Optional.of(Integer.parseInt(str));
            } catch (NumberFormatException e) {
                return Optional.empty();
            }
        };

        Optional<Integer> result = parseFunction.apply("123"); // Возвращает Optional<Integer>
        if (result.isPresent()) {
            System.out.println("Результат: " + result.get());
        } else {
            System.out.println("Не удалось преобразовать в число.");
        }
    }
}
```

4. Использование `CheckedException`:

* Описание: если лямбда-выражение может выбросить проверенное исключение (CheckedException), то можно обернуть его в `RuntimeException` с помощью метода `RuntimeException.wrap`.
* Пример:
```java
import java.io.IOException;
import java.util.function.Supplier;

public class Main {
    public static void main(String[] args) {
        Supplier<String> supplier = () -> {
            throw new IOException("Ошибка ввода-вывода.");
        };

        try {
            String result = supplier.get(); 
        } catch (RuntimeException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }
}
```

Дополнительные советы:

* Общий подход: в идеале, обработка исключений должна быть централизованной и  проводиться на уровне более высокого уровня абстракции, а не внутри лямбда-выражений.
* Проверка на `null`:   при использовании `Optional`  следует не забывать проверять на `null`  результаты  после  вызова `get()`, чтобы избежать `NullPointerException`.
* Выбор метода:  выбор  подхода зависит от конкретной ситуации и контекста, где используется лямбда-выражение.

[_к оглавлению_](#Оглавление)
#### 10. Что такое Stream API?

Stream API - это интерфейс, который позволяет работать с коллекциями в режиме потока данных. Это мощный инструмент для работы с последовательностями данных (коллекциями, массивами и т.д.)  с помощью функционального программирования.  Он позволяет  проводить  операции  над  данными  в  лаконичном  и  читабельном  виде,  не  затрагивая  исходные  данные.

***Ключевые концепции Stream API:***

1. Поток (Stream):  Представляет последовательность элементов, над которыми можно выполнять операции. Потоки неизменяемы: они не изменяют исходные данные.
2. Операции:  Stream API предлагает  два типа  операций:
  * Промежуточные операции (Intermediate operations): Возвращают новый поток, преобразуя исходный, но не выполняют никаких действий с данными.
  * Терминальные операции (Terminal operations): Выполняют действия с данными и возвращают результат или ничего не возвращают.
3. Лямбда-выражения:  Stream API широко использует лямбда-выражения для задания  логики  обработки  данных  в  операциях.

***Преимущества Stream API:***
* Читаемость:  Код с использованием Stream API становится более  читаемым  и  лаконичным,  так  как  описывает  логику  обработки  данных  на  высоком  уровне.
* Функциональность:  Stream API  предоставляет  широкий  спектр  операций  для  фильтрации,  сортировки,  маппинга,  группировки,  слияния  и  других  задач  над  данными.
* Параллелизм:  Потоки  могут  быть  обработаны  параллельно,  что  увеличивает  скорость  вычислений.
* Неизменяемость:  Потоки  неизменяемы,  что  гарантирует  потоковую  безопасность  и  делает  код  более  предсказуемым.

Пример использования Stream API:
```java
import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // Фильтрация: оставьте только четные числа
        List<Integer> evenNumbers = numbers.stream()
                .filter(n -> n % 2 == 0)
                .toList(); // Создание нового списка с результатом

        // Преобразование: умножьте каждый элемент на 2
        List<Integer> doubledNumbers = numbers.stream()
                .map(n -> n * 2)
                .toList();

        // Сортировка: отсортируйте по возрастанию
        List<Integer> sortedNumbers = numbers.stream()
                .sorted()
                .toList();

        // Суммирование: посчитайте сумму всех элементов
        int sum = numbers.stream()
                .reduce(0, Integer::sum); // Использование reduce для суммирования

        System.out.println("Четные числа: " + evenNumbers);
        System.out.println("Удвоенные числа: " + doubledNumbers);
        System.out.println("Отсортированные числа: " + sortedNumbers);
        System.out.println("Сумма: " + sum);
    }
}
```

***Основные операции Stream API:***
* `filter()`:  отбирает элементы, удовлетворяющие условию.
* `map()`:  преобразует  каждый  элемент  потока  в  новый  элемент.
* `sorted()`:  сортирует  элементы  потока.
* `reduce()`:  сводит  поток  к  одному  значению.
* `collect()`:  сбирает  результат  операций  в  новую  коллекцию.
* `forEach()`:  выполняет  действие  для  каждого  элемента  потока.
* `findFirst()`:  возвращает  первый  элемент  потока.

[_к оглавлению_](#Оглавление)
#### 11. Расскажите, какие шаблоны проектирования используются внутри Stream API? (Builder, Strategy, Decorator, Factory Method, Pipeline).



[_к оглавлению_](#Оглавление)
#### 12. Объясните, где они используются в Stream API.



[_к оглавлению_](#Оглавление)
#### 13. Что такое конвейерные (промежуточные) и терминальные операции?

Stream API в Java позволяет выполнять операции над последовательностями данных (например, коллекциями) с помощью потока. Для этого используются два типа операций: промежуточные (конвейерные) и терминальные.

Конвейерные (промежуточные) операции:

+ Не модифицируют исходный поток данных. Они создают новый поток, применяя преобразование к элементам исходного потока.
+ Являются "ленивыми". Они не выполняются сразу, а только при вызове терминальной операции.
+ Возвращают новый объект Stream.

Терминальные операции:

+ Выполняют окончательное действие над потоком данных.
+ Возвращают результат операции, который не является объектом Stream.
+ Вызывают выполнение всех предыдущих промежуточных операций.

Важно:

+ Промежуточные операции можно цепочкой соединять, создавая конвейер преобразований данных. Промежуточных операций может быть много в потоке.
+ Конвейерные методы Stream API не изменяют исходный поток. Они возвращают новый поток, содержащий преобразованные или отфильтрованные элементы.
+ Конвейерные (промежуточные) операции выполняются лениво, то есть обработка элементов происходит только при вызове терминальной операции.
+ Терминальная операция должна быть последней в цепочке операций (может быть единственной в потоке).

[_к оглавлению_](#Оглавление)
#### 14. Перечислите конвейерные (промежуточные) методы Stream API.

1. Преобразование:

+ map(Function mapper): преобразует каждый элемент потока, применяя заданную функцию.
+ flatMap(Function mapper): преобразует каждый элемент потока в поток элементов, а затем объединяет все получившиеся потоки в один.
+ distinct(): удаляет дубликаты из потока.
+ sorted(): сортирует элементы потока по возрастанию.
+ sorted(Comparator comparator): сортирует элементы потока с помощью заданного компаратора.
+ peek(Consumer action): выполняет заданное действие для каждого элемента потока.
+ mapToObj() - трансформирует числовой поток в объектный.

2. Фильтрация:

+ filter(Predicate predicate): оставляет в потоке только элементы, удовлетворяющие заданному предикату.
+ limit(long maxSize): оставляет в потоке не более заданного количества элементов.
+ skip(long n): пропускает первые n элементов потока.

[_к оглавлению_](#Оглавление)
#### 15. Перечислите терминальные методы Stream API.

+ forEach(Consumer action): выполняет заданное действие для каждого элемента потока.
+ toArray(): преобразует поток в массив.
+ anyMatch(Predicate predicate): проверяет, удовлетворяет ли хотя бы один элемент потока заданному предикату.
+ allMatch(Predicate predicate): проверяет, удовлетворяют ли все элементы потока заданному предикату.
+ noneMatch(Predicate predicate): проверяет, не удовлетворяет ли ни один элемент потока заданному предикату.
+ findFirst(): возвращает первый элемент потока.
+ findAny(): возвращает Optional с любым элементом потока, удовлетворяющим условию.
+ reduce(BinaryOperator accumulator): сводит элементы потока к одному значению с помощью заданного аккумулятора.
+ reduce(T identity, BinaryOperator accumulator): сводит элементы потока к одному значению с помощью заданного аккумулятора, используя начальное значение.
+ collect(): собирает все элементы потока в структуру данных.
+ count(): возвращает количество элементов в потоке.
+ min(Comparator comparator): находит минимальный элемент потока по заданному компаратору.
+ max(Comparator comparator): находит максимальный элемент потока по заданному компаратору.
+ sum(): сумма всех элементов потока (только если элементы числовые).
+ average(): среднее арифметическое всех элементов потока (только если элементы числовые).

[_к оглавлению_](#Оглавление)
#### 16. Что такое отложенное выполнение lamdba?

Отложенное выполнение лямбда-выражений в Java — это концепция, означающая, что код внутри лямбда-выражения не выполняется сразу после объявления лямбды. Вместо этого, выполнение откладывается до того момента, когда лямбда будет вызвана.

Вот несколько ключевых моментов:

+ Лямбда-выражения — это объекты: В Java лямбды реализуются как функциональные интерфейсы, то есть они являются объектами, которые хранят в себе код.
+ Вызов лямбды: Вызов лямбды осуществляется через вызов метода, который она реализует (в функциональном интерфейсе).
+ Отложенное выполнение: Только когда вызывается метод, код лямбды действительно выполняется.

Пример:

```java
import java.util.function.Function;

public class Main {

    public static void main(String[] args) {
        Function<Integer, Integer> square = x -> x  x; // Лямбда-выражение

        // Отложенное выполнение: код лямбды не выполняется здесь
        System.out.println(square); // Выведет ссылку на объект лямбды

        // Вызов лямбды и выполнение кода
        int result = square.apply(5); // Вычисляет квадрат 5 
        System.out.println(result); // Выведет 25
    }
}
```

Преимущества отложенного выполнения:

+ Легкость использования: Вы можете объявить лямбду, не заботясь о ее немедленном выполнении.
+ Гибкость: Вы можете передавать лямбду как аргумент функции, а затем вызывать ее в нужное время.
+ Эффективность: Лямбда-выражение не будет выполняться, если ее не вызывают, что позволяет оптимизировать код.

Важно отметить:

+ Отложенное выполнение лямбды зависит от конкретного контекста. Например, если лямбда используется в потоке, она может быть выполнена сразу.
+ В некоторых случаях может потребоваться явно вызывать лямбду, чтобы выполнить ее код.

[_к оглавлению_](#Оглавление)
#### 17. Что делает метод filter()?

Метод `filter()` в Stream API Java используется для фильтрации элементов в потоке. Он принимает предикат (функцию, которая возвращает `true` или `false`) и создает новый поток, содержащий только те элементы исходного потока, для которых предикат возвращает `true`.

Как работает метод filter():

1. Принимает предикат: Метод `filter()` принимает лямбда-выражение или ссылку на метод, которая представляет собой предикат. Этот предикат должен принимать один элемент из потока и возвращать `boolean` значение.
2. Проверка каждого элемента: Для каждого элемента исходного потока метод `filter()` выполняет предикат. 
3. Создание нового потока: Если предикат возвращает `true` для элемента, этот элемент добавляется в новый поток. Если предикат возвращает `false`, элемент пропускается.
4. Возвращение нового потока: Метод `filter()` возвращает новый поток, содержащий только те элементы, которые удовлетворяют предикату.

Пример:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Фильтрация чисел, которые больше 5
List<Integer> filteredNumbers = numbers.stream()
                                       .filter(n -> n > 5)
                                       .collect(Collectors.toList());

// Результат: [6, 7, 8, 9, 10]
```

Важно отметить:
+ Метод `filter()` не изменяет исходный поток. Он создает новый поток с отфильтрованными элементами.
+ Метод `filter()` может использоваться для фильтрации элементов по различным критериям, например, по значению, типу, наличию определенного атрибута и т.д.

[_к оглавлению_](#Оглавление)
#### 18. Что делает метод map()?

Метод `map()` в Stream API Java — это промежуточный оператор, который применяет функцию к каждому элементу потока и возвращает новый поток с измененными элементами.

Что он делает:

 Принимает функцию (функциональный интерфейс) в качестве аргумента. Эта функция будет применяться к каждому элементу потока.
 Преобразует каждый элемент потока. Функция, переданная в `map()`, определяет, как будет преобразована каждый элемент.
 Возвращает новый поток. Новый поток содержит элементы, полученные после применения функции к каждому элементу исходного потока.

Пример:

```java
List<Integer> numbers = Arrays.asList(1, 4, 9, 16, 25);

// Преобразовать каждый элемент в квадратный корень
Stream<Double> squareRoots = numbers.stream()
        .map(Math::sqrt);

// Вывести элементы нового потока
squareRoots.forEach(System.out::println);

// Результат: [1.0, 2.0, 3.0, 4.0, 5.0]
```

В этом примере `map(Math::sqrt)` применяет функцию `Math.sqrt()` к каждому элементу в потоке `numbers`, получая новый поток `squareRoots` с квадратными корнями элементов.

Важные моменты:
+ `map()` не изменяет исходный поток. Он создает новый поток с преобразованными элементами.
+ `map()` может применяться к элементам любого типа.
+ `map()` работает с лямбда-выражениями, функциональными интерфейсами и методами.

Используется для:
+ Изменения типа данных элементов. Например, преобразование строк в целые числа.
+ Применения сложных вычислений. Например, вычисление логарифма каждого элемента.
+ Создание новых объектов на основе существующих элементов. Например, создание объекта `User` из строки с данными пользователя.

[_к оглавлению_](#Оглавление)
#### 19. Что делает метод flatMap()?

Метод `flatMap()` в Stream API Java позволяет вам  "разгладить" (flatten) поток элементов, применяя к каждому элементу функцию, которая возвращает другой поток. В результате вы получаете новый поток, объединяющий все элементы из всех полученных потоков.

Пример:

Допустим, у вас есть поток строк, и вы хотите получить поток всех слов из этих строк:

```java
List<String> strings = Arrays.asList("Hello world", "Java is fun");
Stream<String> wordsStream = strings.stream()
                                   .flatMap(s -> Stream.of(s.split("\\s+")));

wordsStream.forEach(System.out::println);
```

Объяснение:

1. `strings.stream()`:  Создается поток строк из исходного списка.
2. `.flatMap(s -> Stream.of(s.split("\\s+")))`:  К каждому элементу (строке) применяется функция `flatMap`.
     `s.split("\\s+")`:  Разделяет строку на слова по пробелам.
     `Stream.of(...)`:  Создает новый поток из полученных слов.
     `flatMap()`:  Объединяет все полученные потоки в один.

Результат:

```
Hello
world
Java
is
fun
```

В чем разница между `flatMap()` и `map()`?
+ `map()` применяет функцию к каждому элементу потока и возвращает новый поток с результатами этой функции. 
+ `flatMap()` применяет функцию, которая возвращает другой поток, и "разглаживает" (flatten) все полученные потоки в один.

Ключевые моменты:
+ `flatMap()` позволяет работать с потоками вложенных элементов.
+ он объединяет потоки, созданные функцией, в один единый поток.
+ он используется для преобразования и объединения коллекций вложенных элементов.

[_к оглавлению_](#Оглавление)
#### 20. Что делает метод collect()?

Метод `collect()` в Stream API Java — это терминальная операция, которая позволяет вам собрать элементы потока в структуру данных (коллекцию, массив, строку и т.д.) или получить результирующее значение. 

Метод `collect()` использует Collector, который определяет, как собираются элементы потока. Collector — это интерфейс, реализующий различные методы для накопления и вычисления результата.

Основные этапы сбора:
1. Создание накопителя: Collector создает объект, который будет накапливать элементы потока.
2. Добавление элементов:  Каждый элемент потока добавляется к накопителю.
3. Финализация: После обработки всех элементов потока, Collector применяет логику для создания результирующего значения из накопителя.

Пример:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Собирает элементы потока в новый список
List<Integer> collectedNumbers = numbers.stream()
                                       .collect(Collectors.toList());

// Собирает элементы потока в строку с разделителем
String joinedNumbers = numbers.stream()
                             .map(String::valueOf)
                             .collect(Collectors.joining(", "));

// Вычисляет сумму элементов потока
Integer sum = numbers.stream()
                    .collect(Collectors.summingInt(Integer::intValue));
```

Типы коллекторов:
+ `Collectors.toList()`:  Создает новый список из элементов потока.
+ `Collectors.toSet()`: Создает новое множество из элементов потока.
+ `Collectors.toMap()`: Создает новую карту из элементов потока.
+ `Collectors.joining()`:  Объединяет элементы потока в строку с заданным разделителем.
+ `Collectors.summarizingInt()`:  Вычисляет статистику (количество, сумму, минимум, максимум и среднее значение) для числовых элементов потока.
+ Другие:  Java предоставляет множество предопределенных коллекторов, а также позволяет вам создавать свои собственные коллекторы.

Преимущества использования `collect()`:
+ Удобство:  предоставляет простой и лаконичный способ сбора данных.
+ Гибкость:  позволяет собирать данные в различных форматах.
+ Эффективность:  использует оптимизированные алгоритмы для сбора данных.

Важно помнить:
+ Метод `collect()` является терминальной операцией, поэтому он завершает поток.
+ Метод `collect()` всегда возвращает объект, соответствующий типу Collector.

[_к оглавлению_](#Оглавление)
#### 21. Что делает метод findFirst()?

Метод `findFirst()` в Stream API Java предназначен для поиска первого элемента в потоке, который соответствует определенному условию (если таковой имеется).

Как он работает:
1. Проходит по потоку данных.
2. Проверяет каждый элемент на соответствие заданному условию (если оно есть). 
3. Возвращает первый элемент, который удовлетворяет условию.
4. Если ни один элемент не соответствует условию, возвращает пустой `Optional`.

Пример:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

Optional<Integer> firstEvenNumber = numbers.stream()
    .filter(number -> number % 2 == 0) // Условие: число должно быть четным
    .findFirst();

if (firstEvenNumber.isPresent()) {
    System.out.println("Первое четное число: " + firstEvenNumber.get()); // Вывод: Первое четное число: 2
} else {
    System.out.println("Четных чисел в списке нет.");
}
```

Важно отметить:
+ `findFirst()` - это терминальная операция, то есть после ее выполнения поток данных больше не может быть использован.
+ Метод `findFirst()` возвращает объект `Optional`. Это позволяет проверить, был ли найден элемент, и избежать `NullPointerException`.

Альтернативы:
+ `findAny()`:  Возвращает любой элемент, удовлетворяющий условию, без гарантии, что это будет первый элемент.
+ `limit(1).findFirst()`:  Позволяет получить первый элемент, но неэффективно для больших потоков данных.

[_к оглавлению_](#Оглавление)
#### 22. Что делает метод reduce()?

Метод `reduce()` в Stream API Java используется для складывания элементов потока в единое результирующее значение. Он работает по принципу рекурсивного накопления:
1. Начальное значение: вы задаете начальное значение, которое будет использоваться как точка отсчета.
2. Функция комбинирования: вы предоставляете функцию, которая принимает текущее накопленное значение и следующий элемент потока, и возвращает новое накопленное значение.
3. Итерация: метод `reduce()` последовательно применяет функцию комбинирования к каждому элементу потока, обновляя накопленное значение.
4. Результат: в конце вы получаете итоговое накопленное значение, которое представляет собой "складывание" всех элементов потока.

Пример:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Сумма всех чисел в потоке
Integer sum = numbers.stream()
                    .reduce(0, (acc, n) -> acc + n);

// Вывод: 15
System.out.println(sum);
```

В этом примере:
+ Начальное значение: `0` (сумма начинается с нуля).
+ Функция комбинирования: `(acc, n) -> acc + n` (к текущему значению `acc` прибавляется следующий элемент `n`).

Метод `reduce()` позволяет выполнять различные операции над элементами потока, такие как:
+ Сумма: сумма всех элементов в потоке.
+ Произведение: произведение всех элементов в потоке.
+ Максимум/Минимум: поиск максимального/минимального значения в потоке.
+ Объединение строк: соединение всех строк в потоке в одну строку.
+ Слияние коллекций: создание новой коллекции, объединяющей элементы из нескольких потоков.

Важно: vетод `reduce()` может возвращать `Optional` значение, если поток пуст. Поэтому необходимо проверить, присутствует ли результат, используя `isPresent()`, перед получением значения с помощью `get()`.

Дополнительные варианты использования:
+ Идентичность: если функция комбинирования просто возвращает второй аргумент (`(acc, n) -> n`), метод `reduce()` эквивалентен методу `findFirst()`.
+ Опциональный начальный элемент: можно использовать перегруженную версию метода `reduce()`, которая не принимает начальное значение. В этом случае результат будет `Optional`, содержащий первый элемент потока или `empty()`, если поток пуст.

[_к оглавлению_](#Оглавление)
#### 23. Что делают методы min() и max()?

Методы `min()` и `max()` в Stream API Java используются для поиска минимального и максимального элементов в потоке данных, соответственно.

`min()`
+ Возвращает: Оptional объект, содержащий минимальный элемент потока.
+ Принимает: Comparator объект, определяющий порядок сравнения элементов. Если Comparator не указан, используется естественный порядок элементов.
+ Используется: для поиска минимального элемента по заданному критерию.

max()
+ Возвращает: Optional объект, содержащий максимальный элемент потока.
+ Принимает: Comparator объект, определяющий порядок сравнения элементов. Если Comparator не указан, используется естественный порядок элементов.
+ Используется: для поиска максимального элемента по заданному критерию.

Пример:

```java
List<Integer> numbers = Arrays.asList(1, 5, 3, 7, 2);

// Найти минимальное значение
Optional<Integer> min = numbers.stream().min(Integer::compareTo);
if (min.isPresent()) {
  System.out.println("Минимальное значение: " + min.get());
}

// Найти максимальное значение по модулю
Optional<Integer> max = numbers.stream().max(Comparator.comparingInt(Math::abs));
if (max.isPresent()) {
  System.out.println("Максимальное значение по модулю: " + max.get());
}
```

Важно отметить:
+ `min()` и `max()` возвращают Optional объект. Это позволяет обрабатывать случаи, когда поток данных пуст.
+ Методы `min()` и `max()` работают с потоками, которые должны быть упорядочены.
+ Если поток данных пуст, методы `min()` и `max()` возвращают пустой Optional объект.

[_к оглавлению_](#Оглавление)
#### 24. Что делают методы count(), sum(), average()?

Методы `count()`, `sum()`, `average()` в Stream API Java предназначены для агрегирования данных из потока. Они позволяют получить краткое описание данных в потоке, не перебирая его полностью.

`count()`: возвращает количество элементов в потоке.

`sum()`: возвращает сумму всех элементов в потоке (применимо к числовым элементам).

`average()`: возвращает среднее арифметическое всех элементов в потоке (применимо к числовым элементам).

Пример:

```java
import java.util.Arrays;
import java.util.List;

public class StreamExample {

    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // Подсчет элементов в потоке
        long count = numbers.stream().count();
        System.out.println("Количество элементов: " + count); // Вывод: Количество элементов: 5

        // Суммирование элементов в потоке
        int sum = numbers.stream().mapToInt(Integer::intValue).sum();
        System.out.println("Сумма элементов: " + sum); // Вывод: Сумма элементов: 15

        // Среднее арифметическое элементов в потоке
        double average = numbers.stream().mapToInt(Integer::intValue).average().getAsDouble();
        System.out.println("Среднее арифметическое: " + average); // Вывод: Среднее арифметическое: 3.0
    }
}
```

Важно:
+ `count()`, `sum()`, `average()` возвращают объекты, которые нужно преобразовать в нужный тип данных (например, `long` для `count()`, `int` для `sum()`).
+ `sum()` и `average()` применяются к числовым типам данных.
+ `average()` возвращает `OptionalDouble`, поэтому нужно использовать `getAsDouble()` для получения значения.

[_к оглавлению_](#Оглавление)
#### 25. Что делают методы forEach() и peek()?

***Метод `forEach()`***

Функция:  метод `forEach()` позволяет выполнять определенное действие для каждого элемента в потоке данных.

Синтаксис:
```java
stream.forEach(action);
```
+ Аргумент:  `action` представляет собой лямбда-выражение, принимающее элемент потока и выполняющее определенное действие над ним.
+ Возврат: метод `forEach()` не возвращает значение.
  
Пример: 
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
    .forEach(number -> System.out.println(number));
```
Этот код выведет на экран числа от 1 до 5.

***Метод `peek()`***

Функция:  метод `peek()` позволяет посмотреть на элементы потока данных и выполнить какое-то действие с ними, не изменяя сам поток.

Синтаксис:
```java
stream.peek(action);
```
+ Аргумент:  `action` представляет собой лямбда-выражение, принимающее элемент потока и выполняющее определенное действие над ним.
+ Возврат:  `peek()` возвращает новый поток данных, состоящий из тех же элементов, что и исходный поток, но с применением действия `action`.

Пример: 
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
    .peek(number -> System.out.println("Обработка элемента: " + number))
    .filter(number -> number % 2 == 0)
    .forEach(number -> System.out.println("Фильтрованный элемент: " + number));
```
Этот код выведет на экран:
```
Обработка элемента: 1
Обработка элемента: 2
Фильтрованный элемент: 2
Обработка элемента: 3
Обработка элемента: 4
Фильтрованный элемент: 4
Обработка элемента: 5
```
Как видно, `peek()`  выполняет действие над каждым элементом, но не изменяет сам поток. 

В чем разница между `forEach()` и `peek()`?
+ `forEach()` не возвращает потока данных, `peek()` возвращает поток данных.
+ `forEach()` может выполнять действие только над текущим элементом. `peek()` может использовать элемент в дальнейшем, так как возвращает поток данных.

Ключевые моменты:
+ `forEach()` используется для вывода значений или выполнения действий над элементами потока.
+ `peek()` используется для отладки или просмотра значений потока без изменения его состояния.

[_к оглавлению_](#Оглавление)
#### 26. Что делают методы skip() и limit()?

В Java Stream API методы `skip()` и `limit()` используются для манипуляции потоком данных, позволяя вам выбирать и отбрасывать элементы из потока.

**Метод `skip(n)`:**

* Функция: отбрасывает первые `n` элементов из потока.
* Возвращает: новый поток, содержащий все элементы исходного потока, кроме первых `n`.
* 
 Пример: 
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> skippedNumbers = numbers.stream()
                                    .skip(2)  // Отбрасывает первые 2 элемента
                                    .collect(Collectors.toList()); // [3, 4, 5]
```

**Метод `limit(n)`:**

* Функция: ограничивает количество элементов в потоке до `n`.
* Возвращает: новый поток, содержащий не более `n` элементов из исходного потока.

 Пример: 
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> limitedNumbers = numbers.stream()
                                    .limit(3) // Оставляет только первые 3 элемента
                                    .collect(Collectors.toList()); // [1, 2, 3]
```

Важно: 

* Методы `skip()` и `limit()` являются промежуточными операциями. Это означает, что они не возвращают результат, а создают новый поток, который может быть далее преобразован другими операциями. 
* Результат операции `skip()` или `limit()` будет виден только после применения конечной операции, такой как `collect()`, `forEach()`, `reduce()`, и т.д.

Пример использования:

```java
List<String> words = Arrays.asList("one", "two", "three", "four", "five");
List<String> filteredWords = words.stream()
                                  .skip(1)    // Отбрасывает первый элемент
                                  .limit(3)   // Ограничивает количество элементов до 3
                                  .collect(Collectors.toList()); // ["two", "three", "four"]
```

В этом примере мы отбрасываем первый элемент, затем ограничиваем поток тремя элементами, получая в итоге список ["two", "three", "four"].

[_к оглавлению_](#Оглавление)
#### 27. Что делают методы allMatch(), noneMatch() и anyMatch()?



[_к оглавлению_](#Оглавление)
#### 28. Что делают методы mapToInt(), flatMapToInt(), mapToObj()?

Эти методы относятся к семейству "преобразовательных" методов Stream API в Java, которые позволяют изменять элементы потока данных. 

1. `mapToInt()`
+ Функция: преобразует поток элементов в поток `IntStream`. 
+ Описание: принимает в качестве аргумента функцию типа `ToIntFunction`, которая преобразует каждый элемент потока в целое число. 

Пример:
```java
List<String> numbers = Arrays.asList("1", "2", "3");
IntStream intStream = numbers.stream().mapToInt(Integer::parseInt);
int sum = intStream.sum();
System.out.println(sum); // Выведет: 6
```
В этом примере `mapToInt()` преобразует список строк в поток целых чисел, используя функцию `Integer::parseInt`. Затем мы используем `sum()` для получения суммы элементов потока.

2. `flatMapToInt()`

+ Функция: Преобразует поток элементов в поток `IntStream`, где каждый элемент может быть преобразован в поток целых чисел.
+ Описание:  Принимает в качестве аргумента функцию типа `Function`, которая преобразует каждый элемент потока в `IntStream`. Результаты преобразования конкатенируются в один `IntStream`.

Пример:
```java
List<List<Integer>> numbers = Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3, 4));
IntStream intStream = numbers.stream().flatMapToInt(List::stream);
int sum = intStream.sum();
System.out.println(sum); // Выведет: 10
```
В этом примере `flatMapToInt()` преобразует список списков целых чисел в один `IntStream`, объединяя все вложенные списки.

3. `mapToObj()`

+ Функция: Преобразует поток элементов в поток объектов заданного типа.
+ Описание: Принимает в качестве аргумента функцию типа `Function`, которая преобразует каждый элемент потока в объект.

Пример:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3);
Stream<String> stringStream = numbers.stream().mapToObj(String::valueOf);
stringStream.forEach(System.out::println); // Выведет: 1 2 3
```
В этом примере `mapToObj()` преобразует список целых чисел в поток строк, используя функцию `String::valueOf`.

Ключевые отличия:

+ `mapToInt()` преобразует элементы потока в целые числа, в то время как `mapToObj()` преобразует их в объекты.
+ `flatMapToInt()` "разглаживает" вложенные потоки целых чисел, объединяя их в один `IntStream`, в то время как `mapToInt()` преобразует каждый элемент потока в отдельное целое число.

Эти методы могут быть полезны для различных задач, таких как:
+ Преобразование данных из одного формата в другой (например, из строки в целое число).
+ Объединение элементов из разных коллекций в один поток.
+ Изменение структуры данных для более удобной обработки.

Важно понимать, что эти методы не изменяют исходный поток данных. Они создают новый поток с преобразованными элементами.

[_к оглавлению_](#Оглавление)
#### 29. Что такое числовой поток?

В Java числовой поток (Numeric Stream) - это специальный вид потока, оптимизированный для работы с примитивными типами данных (int, long, double и т.д.). Он предоставляет удобный способ обработки больших объемов числовых данных. 

Ключевые особенности числовых потоков:
+ Специализированные операции: числовые потоки предлагают специализированные операции, оптимизированные для работы с числовыми данными, такие как `sum()`, `average()`, `min()`, `max()` и т.д.
+ Эффективность: благодаря оптимизации, числовые потоки работают быстрее, чем стандартные потоки для примитивных типов.
+ Удобство использования: числовые потоки предоставляют более лаконичный и удобный синтаксис для работы с числовыми данными.

Пример:

```java
int[] numbers = {1, 2, 3, 4, 5};

// Создание числового потока из массива чисел
IntStream intStream = Arrays.stream(numbers);

// Подсчет суммы чисел
int sum = intStream.sum();

// Вывод результата
System.out.println("Сумма чисел: " + sum); 
```

Преимущества числовых потоков:
+ Улучшенная производительность: оптимизация для работы с примитивными типами данных обеспечивает более высокую скорость обработки.
+ Упрощенный код: более лаконичный и читаемый код по сравнению с использованием стандартных потоков для примитивных типов.
+ Более удобные операции: доступ к специализированным операциям, оптимизированным для работы с числовыми данными.

Недостатки числовых потоков:
+ Ограниченная функциональность: числовые потоки не предлагают всю функциональность, доступную в стандартных потоках.
+ Необходимость преобразования: если вы работаете с объектами, а не с примитивными типами, вам потребуется преобразовать данные в числовой поток.

[_к оглавлению_](#Оглавление)
#### 30. Чем отличается Stream(Integer) от IntStream(int)?

В Java, `Stream<Integer>` и `IntStream`  - это два разных типа потоков, которые, хотя и работают с целыми числами, имеют несколько ключевых отличий.

`Stream<Integer>`:

+ Общий тип потока: это стандартный поток Java, который работает с объектами типа `Integer`. 
+ Упакованные типы: работает с объектами, а не примитивными типами.
+ Более широкие возможности:  может использоваться для любых объектов, не только для целых чисел.
+ Бо́льшие накладные расходы: работа с объектами может быть более ресурсоемкой, чем с примитивами.

`IntStream`:

+ Специализированный тип потока: предназначен специально для работы с примитивными целыми числами (типа `int`). 
+ Примитивные типы: работает с примитивными типами, что делает его более эффективным для операций с числами.
+ Оптимизирован для работы с числами:  предоставляет специализированные методы для работы с целыми числами (например, `sum()`, `average()`).
+ Меньшие накладные расходы:  работа с примитивными типами обычно быстрее, чем с объектами.

В чем разница:

+ Тип данных: `Stream<Integer>` работает с объектами `Integer`, а `IntStream` работает с примитивными типами `int`.
+ Эффективность: `IntStream` более эффективен для операций с целыми числами, поскольку он не требует работы с объектами.
+ Функциональность: `IntStream` предоставляет специализированные методы для работы с числами, которых нет у `Stream<Integer>`.

Когда использовать:

+ `IntStream` - лучше использовать, если вы работаете с большими объемами целых чисел и требуется максимальная производительность.
+ `Stream<Integer>` - лучше использовать, если вам нужна более общая функциональность потока, которая может работать с любыми объектами, или если вы работаете с небольшим количеством данных, где разница в производительности не критична.

Пример:

```java
// Stream<Integer>
Stream<Integer> integerStream = Stream.of(1, 2, 3, 4, 5);

// IntStream
IntStream intStream = IntStream.range(1, 6);

// Вывод:
integerStream.forEach(System.out::println); // Вывод: 1, 2, 3, 4, 5
intStream.forEach(System.out::println); // Вывод: 1, 2, 3, 4, 5

System.out.println(intStream.sum()); // Вывод: 15
```

[_к оглавлению_](#Оглавление)
#### 31. Что делает метод boxed()?

Метод `boxed()` в Stream API Java используется для преобразования потока примитивных типов данных в поток объектов-оберток соответствующего типа. 

Пример:

```java
Stream<Integer> intStream = Stream.of(1, 2, 3, 4, 5);
Stream<Integer> boxedStream = intStream.boxed();
```

В этом примере `intStream` является потоком примитивных целых чисел (`int`). Метод `boxed()` преобразует его в `boxedStream`, который является потоком объектов `Integer`.

Как работает boxed():

Метод `boxed()` создает новый поток, где каждый элемент исходного потока преобразуется в соответствующий объект-обертку. Например, примитивное целое число `1` преобразуется в объект `Integer` с значением `1`.

Почему boxed() важен:
+ Использование методов потока: Многие методы потока (например, `collect()`, `reduce()`) работают только с объектами, а не с примитивными типами. Метод `boxed()` позволяет использовать эти методы с потоками примитивных типов.
+ Совместимость с коллекциями: Потоки примитивных типов не могут быть напрямую преобразованы в коллекции, такие как `List` или `Set`. `boxed()` позволяет создавать коллекции из потоков примитивных типов.

Важно отметить:
+ Метод `boxed()` работает только с потоками примитивных типов (например, `int`, `long`, `double`). 
+ После применения `boxed()` исходный поток остается неизменным.
+ Метод `boxed()` не изменяет порядок элементов в потоке. 

[_к оглавлению_](#Оглавление)
#### 32. Возможно ли прервать выполнение потока по аналогии с break?

Нет, в Stream API Java нет аналога `break` для прерывания потока. 

Как же управлять потоком?

Вместо `break` в Stream API используются следующие методы:

+ `limit(n)`: Ограничивает количество элементов в потоке.
+ `skip(n)`: Пропускает первые `n` элементов в потоке.
+ `takeWhile(predicate)`: Возвращает элементы до тех пор, пока условие `predicate` истинно.
+ `dropWhile(predicate)`: Пропускает элементы до тех пор, пока условие `predicate` истинно.
+ `findFirst()`: Возвращает первый элемент в потоке.
+ `anyMatch(predicate)`: Проверяет, существует ли хотя бы один элемент, удовлетворяющий условию `predicate`.
+ `allMatch(predicate)`: Проверяет, удовлетворяют ли все элементы условию `predicate`.
+ `noneMatch(predicate)`: Проверяет, не удовлетворяет ли ни один элемент условию `predicate`.

Пример:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Ограничение потока до первых 3 элементов
List<Integer> firstThree = numbers.stream().limit(3).collect(Collectors.toList());

// Пропускаем первые 2 элемента
List<Integer> skippedTwo = numbers.stream().skip(2).collect(Collectors.toList());

// Возвращаем элементы, пока они меньше 4
List<Integer> lessThanFour = numbers.stream().takeWhile(n -> n < 4).collect(Collectors.toList());
```

Важно: Stream API работает с "ленивой" оценкой, то есть операции выполняются только при необходимости. Это означает, что прерывание потока по аналогии с `break` не требуется, так как обработка данных завершается в момент, когда необходимая информация получена. 

Если вам нужно прервать обработку потока в середине, то есть несколько вариантов:

+ Разбить обработку на несколько этапов: вы можете разделить логику на несколько потоков и прервать обработку одного из них, используя `break` в цикле.
+ Использовать исключения: вы можете бросить исключение в середине обработки потока, чтобы остановить дальнейшие операции.
+ Использовать внешнюю переменную: вы можете использовать внешнюю переменную, которую можно изменить изнутри потока, чтобы указать, нужно ли продолжать обработку.

Выбор метода зависит от конкретной ситуации и требований к обработке данных.

[_к оглавлению_](#Оглавление)
#### 33. Возможно ли пропустить элемент потока по аналогии с continue?

В Java Stream API нет прямого аналога оператору `continue`, как в обычном цикле. Stream API работает с концепцией ленивых вычислений и неизменяемых данных, поэтому он не поддерживает явные операции изменения потока.

Однако, вы можете имитировать поведение `continue` с помощью следующих подходов:

1. Фильтрование элементов:

Используйте `filter()` для удаления элементов, которые вы хотите пропустить:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> filteredNumbers = numbers.stream()
        .filter(n -> n != 3) // пропускаем элемент 3
        .collect(Collectors.toList());
```

2. Использование `Optional`:

Если вы хотите пропустить только один элемент по определенному условию, используйте `Optional` и `orElse` для обработки пропуска:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
        .forEach(n -> {
            if (n == 3) { // пропускаем элемент 3
                return; 
            }
            System.out.println(n);
        });
```

3. Сборка промежуточных результатов:

Используйте `flatMap` для объединения результатов нескольких потоков, пропускающих элементы:

```java
List<String> words = Arrays.asList("apple", "banana", "orange");
List<String> filteredWords = words.stream()
        .flatMap(word -> {
            if (word.length() < 5) { // пропускаем короткие слова
                return Stream.empty();
            }
            return Stream.of(word);
        })
        .collect(Collectors.toList());
```

4. Создание собственного оператора:

Создайте собственный оператор, который будет имитировать поведение `continue`:

```java
public static <T> Stream<T> skipIf(Stream<T> stream, Predicate<T> predicate) {
    return stream.filter(t -> !predicate.test(t));
}

// Использование
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> skippedNumbers = skipIf(numbers.stream(), n -> n == 3)
        .collect(Collectors.toList());
```

Важно помнить, что Stream API предназначен для обработки данных в неизменяемом стиле, поэтому `continue` в его классическом виде не доступен. Однако, используя перечисленные методы, вы можете достичь аналогичного результата, удаляя или фильтруя элементы потока.

[_к оглавлению_](#Оглавление)
#### 34. Что такое Optional?

Optional в Java - это контейнер, который может содержать либо значение, либо null. Он был введен в Java 8, чтобы справиться с проблемой null-значений, которые могут привести к ошибкам NullPointerException.

Основные концепции:
+ Предотвращение NullPointerException: Optional предотвращает возникновение ошибок NullPointerException, так как он явно указывает, что значение может быть null.
+ Улучшенная читаемость кода: Использование Optional делает код более читабельным и понятным, так как он ясно указывает, что значение может быть отсутствующим.
+ Упрощение обработки null-значений: Optional предоставляет методы для безопасной обработки null-значений, такие как `isPresent()`, `get()`, `orElse()`, `orElseThrow()`.

Как работает Optional:

1. Создание объекта Optional:
   - `Optional.of(value)`: Создает объект Optional с заданным значением.
   - `Optional.empty()`: Создает пустой объект Optional.
   - `Optional.ofNullable(value)`: Создает объект Optional с заданным значением, если оно не null, иначе создает пустой объект Optional.

2. Проверка наличия значения:
   - `isPresent()`: Возвращает true, если значение присутствует, иначе false.

3. Получение значения:
   - `get()`: возвращает значение, если оно присутствует. Иначе выбрасывает NoSuchElementException.
   - `orElse(defaultValue)`: возвращает значение, если оно присутствует. Иначе возвращает заданное значение по умолчанию.
   - `orElseThrow(supplier)`: возвращает значение, если оно присутствует. Иначе выбрасывает исключение, созданное поставщиком исключений.

Пример:

```java
import java.util.Optional;

public class OptionalExample {

  public static void main(String[] args) {
    // Создаем объект Optional с значением
    Optional<String> name = Optional.of("John");

    // Проверяем наличие значения
    if (name.isPresent()) {
      System.out.println("Имя: " + name.get());
    } else {
      System.out.println("Имя отсутствует");
    }

    // Получение значения с использованием orElse()
    String nameOrDefault = name.orElse("Guest");
    System.out.println("Имя по умолчанию: " + nameOrDefault);

    // Создание пустого объекта Optional
    Optional<String> emptyName = Optional.empty();

    // Получение значения с использованием orElse() для пустого Optional
    String emptyNameOrDefault = emptyName.orElse("Guest");
    System.out.println("Имя по умолчанию (пустой Optional): " + emptyNameOrDefault);
  }
}
```

Преимущества использования Optional:
+ Повышенная безопасность: предотвращает ошибки NullPointerException.
+ Улучшенная читаемость: делает код более ясным и понятным.
+ Упрощенная обработка null-значений: предоставляет удобные методы для работы с null-значениями.
+ Стандартный подход: является стандартным способом работы с null-значениями в Java.

Важно отметить:
+ Optional не является заменой проверки null-значений.
+ Не следует использовать Optional для всех значений.
+ Необходимо использовать Optional только в тех случаях, когда значение может быть null.

[_к оглавлению_](#Оглавление)
#### 35. Перечислите методы Optional.

Создание `Optional`:
+ `Optional.empty()`: создает пустой `Optional`.
+ `Optional.of(T value)`: создает `Optional`, содержащий заданное значение. Бросает `NullPointerException`, если значение `null`. ***Противоречит назначению `Optional`.***
+ `Optional.ofNullable(T value)`: создает `Optional`, содержащий заданное значение, если оно не `null`, иначе создает пустой `Optional`.

Проверка наличия значения:
+ `isPresent()`: возвращает `true`, если `Optional` содержит значение, иначе `false`.
+ `isEmpty()`: возвращает `true`, если `Optional` пустой, иначе `false`.

Доступ к значению:
+ `get()`: возвращает значение, если оно присутствует, иначе бросает `NoSuchElementException`. ***Противоречит назначению `Optional`.***
+ `or(Supplier<? extends Optional<? extends T>> supplier)`: возвращает Optional со значением, если оно есть, если нет - Optional, заданный поставщиком (supplier).
+ `orElse(T other)`: возвращает значение, если оно присутствует, иначе возвращает заданное значение.
+ `orElseGet(Supplier<? extends T> other)`: возвращает значение, если оно присутствует, иначе возвращает результат вызова заданного поставщика.
+ `orElseThrow(Supplier<? extends X> exceptionSupplier)`: возвращает значение, если оно присутствует, иначе бросает исключение, сгенерированное заданным поставщиком.
+ `ifPresent(Consumer<? super T> consumer)`: выполняет заданное действие, если значение присутствует.
+ `ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)`: выполняет заданное действие, если значение присутствует, иначе выполняет другое действие.
+ `equals(Object obj)`: позволяет сравнить объект с текущим Optional.
+ `toString()`: dозвращает непустое строковое представление Optional, подходящее для отладки.

Преобразование:
+ `map(Function<? super T, ? extends R> mapper)`: применяет заданную функцию к значению, если оно присутствует, и возвращает новый `Optional`, содержащий результат.
+ `flatMap(Function<? super T, Optional<R>> mapper)`: применяет заданную функцию к значению, если оно присутствует, и возвращает результат функции, если он является `Optional`, иначе возвращает пустой `Optional`.
+ `filter(Predicate<? super T> predicate)`: фильтрует значение, если оно присутствует, и возвращает новый `Optional`, содержащий значение, только если оно соответствует предикату.

Другие:
+ `stream()`: возвращает `Stream`, содержащий значение, если оно присутствует, иначе пустой `Stream`.

Помните, что `Optional` не предназначен для замены исключений, а скорее для обработки случаев, когда значение может быть отсутствующим. 

[_к оглавлению_](#Оглавление)
#### 36. Расскажите про фабричные методы List.of(), Set.of(), Map.of()?

В Java 9 были добавлены фабричные методы для создания неизменяемых коллекций: `List.of()`, `Set.of()`, `Map.of()`. 

Преимущества фабричных методов:

+ Неизменяемость: cозданные коллекции неизменяемы, то есть их содержимое нельзя изменить после создания. Это обеспечивает безопасность данных и предотвращает непредвиденные изменения.
+ Простота использования: код становится более лаконичным и читаемым, так как нет необходимости создавать отдельные объекты коллекций и заполнять их элементами.
+ Эффективность: фабричные методы оптимизированы для создания неизменяемых коллекций, что делает их более эффективными, чем создание стандартных коллекций.

Примеры использования:

List.of()

```java
List<String> names = List.of("John", "Jane", "Peter");
```

Set.of()

```java
Set<Integer> numbers = Set.of(1, 2, 3, 4, 5);
```

Map.of()

```java
Map<String, Integer> ages = Map.of("John", 30, "Jane", 25, "Peter", 28);
```

Важные моменты:
+ Фабричные методы не работают с примитивными типами данных. Используйте автоупаковку или `Arrays.asList()` для создания списка из примитивов.
+ Для создания пустой коллекции используйте `Collections.emptyList()`, `Collections.emptySet()` и `Collections.emptyMap()`.
+ Фабричные методы могут быть использованы только для создания неизменяемых коллекций. 

Недостатки:
+ Невозможность изменить созданную коллекцию может быть ограничением в некоторых сценариях.

[_к оглавлению_](#Оглавление)
#### 37. Для чего используется var?

В Java ключевое слово `var` используется для объявления локальных переменных, не требуя явно указывать тип данных. Это называется выводом типа. Компилятор Java автоматически определяет тип данных на основе значения, присваиваемого переменной.

Преимущества использования `var`:
+ Упрощение кода:  Снижает количество кода, который нужно написать, особенно для сложных типов данных.
+ Повышение читаемости:  Код становится более лаконичным и легче читается.
+ Совместимость с лямбда-выражениями:  `var` упрощает использование лямбда-выражений, где явно указать тип данных может быть сложно.

Примеры использования `var`:

```java
// Определение целого числа
var num = 10;

// Определение строки
var str = "Привет!";

// Определение списка
var list = List.of(1, 2, 3);

// Определение лямбда-выражения
var sum = (a, b) -> a + b; 

// Использование в цикле for
for (var i = 0; i < 10; i++) {
  // ...
}
```

[_к оглавлению_](#Оглавление)
#### 38. В каких случаях можно использовать var?

В Java, ключевое слово `var` не используется для объявления переменных. Оно используется для автоматического вывода типа в Java 10 и более поздних версиях. 

Использование `var`:

1. Когда тип переменной очевиден из контекста:
  ```java
  var name = "John"; // Тип автоматически выводится как String
  var age = 30; // Тип автоматически выводится как int
  var isStudent = true; // Тип автоматически выводится как boolean
  ```
2. Для упрощения кода, когда тип не важен:
  ```java
  var list = new ArrayList<String>(); // Тип автоматически выводится как ArrayList<String>
  var map = new HashMap<String, Integer>(); // Тип автоматически выводится как HashMap<String, Integer>
  ```
Когда `var` может быть использован:
+ Инициализация с явным типом.
+ Использование коллекций: при создании коллекций с прямым присвоением значений.
+ Циклы и потоки: в циклах `for` при итерации по коллекциям использование `var` для итератора обеспечивает компактность кода и ясность.
+ Анонимные классы и lambda-выражения.
+ Объявление неизменяемых переменных: при объявлении переменных, которые не изменяют своё значение (не имеют сеттеров).

Когда `var` НЕ может быть использован:
+ В методах: `var` не может быть использован для объявления типов возвращаемых значений методов.
+ В параметрах методов: `var` не может быть использован для объявления типов параметров методов.
+ В объявлении полей класса: `var` не может быть использован для объявления полей класса.
+ В лямбда-выражениях: `var` не может быть использован для объявления параметров лямбда-выражений.

Примеры:

Правильный код:

```java
// Объявление переменных с автоматическим выводом типа
var name = "John";
var age = 30;

// Использование var в цикле for-each
for (var item : list) {
  System.out.println(item);
}
```

Неправильный код:

```java
// Некорректное использование var в объявлении метода
var int sum(int a, int b) {
  return a + b;
}

// Некорректное использование var в объявлении поля класса
var String name; 
```

Важно отметить:
+ `var` не является типом данных, а просто синтаксическим сахаром, который позволяет компилятору автоматически определить тип переменной.
+ `var` может использоваться только для локальных переменных, объявленных в блоках кода. 

Использование `var` может сделать код более кратким и читаемым, но его следует использовать с осторожностью, чтобы избежать путаницы и ошибок.

[_к оглавлению_](#Оглавление)
